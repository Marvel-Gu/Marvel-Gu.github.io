<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>西电B测-计算机网络综合实验</title>
      <link href="/2024/04/24/2024-4-24-B%E6%B5%8B/"/>
      <url>/2024/04/24/2024-4-24-B%E6%B5%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="西电B测-计算机网络综合实验"><a href="#西电B测-计算机网络综合实验" class="headerlink" title="西电B测-计算机网络综合实验"></a>西电B测-计算机网络综合实验</h2><h3 id="ensp安装踩坑"><a href="#ensp安装踩坑" class="headerlink" title="ensp安装踩坑"></a>ensp安装踩坑</h3><p>我这台电脑的环境比较混乱, virtualbox, vmware, docker什么的都有, 而且还是win11, 导致疯狂踩坑🤣, 整个安装大概花费3小时😇</p><h4 id="第一个坑"><a href="#第一个坑" class="headerlink" title="第一个坑"></a>第一个坑</h4><p>virtualbox版本不支持, 我电脑上的virtualbox是7.0.x版本的, 与老版ensp不兼容, 需要降级到5.2.x版本, 最终选了5.2.44版本, 5.2.44版本的virtualbox又和win11不兼容, 需要将<strong>内核隔离</strong>关闭才能正常安装, 路径: 设置—&gt;隐私与安全—&gt;windows安全中心—&gt;设备安全性—&gt;内核隔离</p><h4 id="第二个坑"><a href="#第二个坑" class="headerlink" title="第二个坑"></a>第二个坑</h4><p>重装之后启动路由器报错,错误代码41, 可以参考这篇<a href="https://blog.csdn.net/weixin_51515423/article/details/122304503" style="color: #177cb0; text-decoration: underline;text-decoration-style: dotted;">博客</a>, 操作之后再次启动路由器报错, 错误代码40, 接下来就是第三个坑</p><h4 id="第三个坑"><a href="#第三个坑" class="headerlink" title="第三个坑"></a>第三个坑</h4><p>路由器启动报错40之后, 我照着官方文档一通操作, 发现依旧报错40😅, 然后决定全部卸载重装.</p><p>步骤: </p><ol><li>控制面板卸载eNSP、VirtualBox、Wireshark、WinCap四个程序，如果存在USBCap、Npcap，也卸载</li><li>依次查看并删除:<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">C:\Program Files\huawei，若该目录下存在eNSP文件夹，请一并删除。</span><br><span class="line">C:\Program Files，若该目录下存在Npcap文件夹，请一并删除。</span><br><span class="line">C:\Program Files (x86)，若该目录下存在WinCap文件夹，请一并删除。</span><br><span class="line">C:\ProgramData，若该目录下存在VirtualBox文件夹，请一并删除。</span><br><span class="line">C:\Users\你的用户名，若该目录下存在.virtualbox文件夹，请一并删除。</span><br><span class="line">C:\Users\你的用户名\AppData\Local，若该目录下存在eNSP文件夹，请一并删除。</span><br></pre></td></tr></table></figure></li><li>清理无效注册表,cmd输入regedit进入, 删除相关注册表, 主要是virtualbox相关的</li></ol><p><strong>然后重装,发现还是报错40</strong>🥰</p><p>然后我用<strong>virtualbox去启动AR_Base</strong>, 得到报错<code>Raw-mode is unavailable courtesy of Hyper-V. (VERR_SUPDRV_NO_RAW_MODE_HYPER_V_ROOT)</code>, 这时我意识到是Hyper-V的问题, 但我的Hyper-v其实是没有勾选启用的, 其他<br>相关选项也没有勾选,如图: </p><p><img src="https://pb01.s3.bitiful.net/190.webp" alt="avatar"></p><p>我想到可能曾经安装Docker开启Hyper-V后, 即使现在不勾选了, 它仍然没有真正关闭. </p><p>管理员权限打开cmd, 输入<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bcdedit</span><br></pre></td></tr></table></figure><br>看到hypervisorlaunchtype的值是Auto,输入<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bcdedit /set hypervisorlaunchtype off</span><br></pre></td></tr></table></figure><br>就可以关闭</p><p><img src="https://pb01.s3.bitiful.net/191.webp" alt="avatar"></p><p>所以之前如果没有安装过Docker或者动过Hyper-v是不会出现这个问题的,解释如下:</p><p><strong>hypervisorlaunchtype</strong>是Windows操作系统的引导选项，用于控制处理器和虚拟化技术之间的交互方式。这个选项的值可以是”Auto”、”Off”或”Hypervisor”。它的默认值为”Auto”，表示处理器将根据需要自动启用或禁用虚拟化技术。1如果Windows中安装了Docker，想要正常使用的话就必须开启Hyper-V，否则会出现错误提示。但是如果Windows系统中同时存在VMware虚拟机的话，开启Hyper-V又会导致虚拟机用不了，这个时候就只能关闭Hyper-V。</p><h3 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h3><h4 id="实验内容和要求"><a href="#实验内容和要求" class="headerlink" title="实验内容和要求"></a>实验内容和要求</h4><p><strong>内容</strong>:</p><ol><li>利用华为eNSP网络模拟器，搭建与下图相对应的网络拓扑。在实验拓扑中共有3个网段（网1、网2和网3），其网络参数参见表格。每个网段使用1台交换机。</li><li>路由器R1连接网1与网2，路由器R2连接网2与网3。</li><li>按照要求对每台设备进行配置，最终保证所有设备的连通性。</li></ol><p><img src="https://s3.bitiful.net/pb01/192.webp" alt="avatar"></p><div class="table-container"><table><thead><tr><th>网络</th><th>子网掩码</th><th>网络号</th></tr></thead><tbody><tr><td>网1</td><td>255.255.255.0</td><td>192.168.1.0</td></tr><tr><td>网2</td><td>255.255.255.0</td><td>192.168.5.0</td></tr><tr><td>网3</td><td>255.255.255.0</td><td>192.168.3.0</td></tr></tbody></table></div><p><strong>要求</strong>:</p><ol><li>主机A与主机B的IPv4地址、子网掩码以及默认网关等参数由网络设备中的DHCP服务自动分配；</li><li>主机C和主机D的IPv4地址、子网掩码以及默认网关等参数由手动分配，且地址的最后一个字节必须设置为任一组员学号的后三位，否则测试不通过。</li><li>对主机A所连接的网络设备端口进行限速，其中入方向和出方向均限制为端口最大速率的50%。</li><li>选择合适的网络设备，配置至少两种防ARP泛洪攻击功能以及至少两种防ARP欺骗攻击功能。</li></ol><h4 id="保姆级教程"><a href="#保姆级教程" class="headerlink" title="保姆级教程"></a>保姆级教程</h4><p>选用设备: PC,交换机S5700,路由器AR1220</p><p>总的连接图:</p><p><img src="https://s3.bitiful.net/pb01/186.webp" alt="avatar"></p><p><strong>自动获取IP</strong>:<br>PC1和PC2右键打开设置,ipv4勾选DHCP</p><p><img src="https://s3.bitiful.net/pb01/187.webp" alt="avatar"></p><p><strong>配置AR2</strong>:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">sys <span class="comment"># 进入系统视图</span></span><br><span class="line">int g0/0/0 <span class="comment"># 配置GE 0/0/0端口</span></span><br><span class="line">ip address 192.168.1.195 24 <span class="comment"># 设置端口处IP mask</span></span><br><span class="line">dhcp <span class="built_in">enable</span> <span class="comment"># 启动DHCP服务</span></span><br><span class="line">ip pool ggls_p1 <span class="comment"># 创建IP池</span></span><br><span class="line">network 192.168.1.0 mask 24 <span class="comment"># 建立网段 网络号 mask</span></span><br><span class="line">gateway-list 192.168.1.195 <span class="comment"># 网关 IP</span></span><br><span class="line">int g0/0/0 </span><br><span class="line">dhcp <span class="keyword">select</span> global <span class="comment"># 启动分配</span></span><br><span class="line">int g0/0/1</span><br><span class="line">ip address 192.168.5.2 24 <span class="comment"># 将路由器GE 0/0/1拉入 192.168.5.0 网段，后面要用</span></span><br><span class="line">quit</span><br><span class="line"><span class="comment"># 配置静态路由，后面要用</span></span><br><span class="line"><span class="comment"># 想去192.168.5.0/24的下一跳是192.168.5.195</span></span><br><span class="line">ip route-static 192.168.5.0 24 192.168.5.195</span><br><span class="line"><span class="comment"># 想去192.168.3.0/24的下一跳是192.168.5.195</span></span><br><span class="line">ip route-static 192.168.3.0 24 192.168.5.195</span><br><span class="line">quit</span><br><span class="line">save</span><br></pre></td></tr></table></figure><br><code>一定要记得保存,不然重做虽然不难,但很麻烦,后面的也是</code></p><p><strong>配置LSW2</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">sys</span><br><span class="line">vlan 1 <span class="comment"># 创建vlan 1</span></span><br><span class="line">int vlanif 1</span><br><span class="line">ip address 192.168.5.195 24 <span class="comment"># 配置网关</span></span><br><span class="line">int g0/0/1 <span class="comment"># 让 GE 0/0/1加入vlan1</span></span><br><span class="line">port link-type access</span><br><span class="line">port default vlan 1</span><br><span class="line">int g0/0/2 <span class="comment"># 让 GE 0/0/2加入vlan1</span></span><br><span class="line">port link-type access</span><br><span class="line">port default vlan 1</span><br><span class="line">int g0/0/3 <span class="comment"># 让 GE 0/0/3加入vlan1</span></span><br><span class="line">port link-type access</span><br><span class="line">port default vlan 1</span><br><span class="line">quit</span><br><span class="line"><span class="comment"># 和AR3、AR4的静态路由配置对应，注意了这波</span></span><br><span class="line"><span class="comment"># 想去192.168.1.0/24的下一跳是192.168.5.2</span></span><br><span class="line">ip route-static 192.168.1.0 24 192.168.5.2</span><br><span class="line"><span class="comment"># 想去192.168.3.0/24的下一跳是192.168.5.3</span></span><br><span class="line">ip route-static 192.168.3.0 24 192.168.5.3 </span><br><span class="line">quit</span><br><span class="line">save</span><br></pre></td></tr></table></figure><p><strong>AR3配置</strong>:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sys</span><br><span class="line">int g0/0/0</span><br><span class="line">ip address 192.168.5.3 24</span><br><span class="line">int g0/0/1</span><br><span class="line">ip address 192.168.3.195 24</span><br><span class="line">quit</span><br><span class="line">ip route-static 192.168.1.0 24 192.168.5.195</span><br><span class="line">ip route-static 192.168.5.0 24 192.168.5.195</span><br></pre></td></tr></table></figure></p><p><strong>PC3和PC4配置</strong>:</p><p>网关与之前设置的一致即可,分别为192.168.5.195和192.168.3.195,ip自己设置</p><p><img src="https://s3.bitiful.net/pb01/188.webp" alt="avatar"></p><p>之后全部启动,看四台PC之间是否能互相ping通,如果不能,就去一个一个的ping接口,找到断的地方,排查问题</p><p>PC1和PC2的ip使用ipconfig命令查看,至此要求1,2就结束了</p><p><strong>限制速率</strong>:<br>因为是千兆的网口,限制到50%,就设置了500M</p><p>要配置LSW4,代码如下:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sys</span><br><span class="line">int g0/0/1</span><br><span class="line">qos lr inbound cir 500000 <span class="comment">#500*1000=&gt; 500Mbps</span></span><br><span class="line">qos lr outbound cir 500000</span><br></pre></td></tr></table></figure><p>查看结果:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sys</span><br><span class="line">int g0/0/1</span><br><span class="line">dispaly this</span><br></pre></td></tr></table></figure><p>![avatar]<a href="https://s3.bitiful.net/pb01/195.webp">https://s3.bitiful.net/pb01/195.webp</a></p><p><strong>应对ARP泛洪</strong>:<br>如果设备对收到的大量ARP报文全部进行处理，可能导致CPU负荷过重而无法处理其他业务。因此，在处理之前，设备需要对ARP报文进行限速，以保护CPU资源。</p><p>如果网络中有用户向设备发送大量目标IP地址不能解析的IP报文（即路由表中存在该IP报文的目的IP对应的路由表项，但设备上没有该路由表项中下一跳对应的ARP表项），将导致设备触发大量的ARP Miss消息。这种触发ARP Miss消息的IP报文会被上送到设备进行处理，设备会根据ARP Miss消息生成和下发大量临时ARP表项并向目的网络发送大量ARP请求报文，这样就增加了设备CPU的负担，同时严重消耗目的网络的带宽资源。</p><p><strong>在AR2和AR3中都要配置</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">sys </span><br><span class="line"><span class="comment"># ARP报文限速</span></span><br><span class="line">int g0/0/0</span><br><span class="line">arp anti-attack rate-limit <span class="built_in">enable</span> </span><br><span class="line">arp anti-attack rate-limit 80 1</span><br><span class="line">int g0/0/1</span><br><span class="line">arp anti-attack rate-limit <span class="built_in">enable</span> </span><br><span class="line">arp anti-attack rate-limit 80 1</span><br><span class="line"><span class="comment"># ARP Miss消息限速</span></span><br><span class="line">arp-miss anti-attack rate-limit <span class="built_in">enable</span></span><br></pre></td></tr></table></figure><p><strong>应对ARP欺骗</strong>:</p><p><code>ARP报文合法性检查</code>: 这些检查是用来<strong>判断ARP报文的格式跟ARP协议的规定是否一致</strong>。其中以太网数据帧首部中的源MAC地址和ARP报文数据区中的源MAC地址不一致的ARP报文是协议允许的报文，但是在实际的应用中，该类报文很可能是攻击报文。ARP报文合法性检查功能后，设备<strong>会对收到的ARP报文进行以太网数据帧首部中的源MAC地址和ARP报文数据区中的源MAC地址的一致性检查</strong>，如果两者不一致，则直接丢弃该ARP报文，否则允许该ARP报文通过</p><p><code>ARP表项固化</code>: </p><ul><li><p><strong>fixed-all方式</strong>, 只有当ARP报文对应的MAC地址、接口、VLAN信息和ARP表项中的信息完全匹配时，设备才可以更新ARP表项的其他内容。此方式适用于用户MAC地址固定，并且用户接入位置相对固定的场景。</p></li><li><p><strong>fixed-mac方式</strong>, 设备收到的ARP报文中的MAC地址与ARP表中对应条目的MAC地址不匹配，则直接丢弃该ARP报文；如果匹配，但是收到报文的接口或VLAN信息与ARP表中对应条目不匹配，则可以更新对应ARP条目中的接口和VLAN信息。此方式适用于用户MAC地址固定，但用户接入位置频繁变动的场景。当用户从不同接口接入设备时，设备上该用户对应的ARP表项中的接口信息可以及时更新。</p></li><li><p><strong>send-ack方式</strong>, 设备收到一个涉及MAC地址、VLAN、接口修改的ARP报文时，不会立即更新ARP表项，而是先向待更新的ARP表项现有MAC地址对应的用户发送一个单播的ARP请求报文进行确认，根据确认结果再决定是否更新ARP表项中的MAC地址、VLAN和接口信息。此方式适用于用户的MAC地址和接入位置均频繁变动的场景。</p></li></ul><p><strong>在AR2和AR3中都要配置</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sys</span><br><span class="line"><span class="comment"># ARP报文合法性检查</span></span><br><span class="line">arp anti-attack packet-check sender-mac</span><br><span class="line"><span class="comment"># ARP表项固化</span></span><br><span class="line">arp anti-attack entry-check fixed-all</span><br></pre></td></tr></table></figure><p>最后查看一下ARP安全配置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">display arp anti-attack configuration all</span><br></pre></td></tr></table></figure><p>如图:<br><img src="https://s3.bitiful.net/pb01/189.webp" alt="avatar"></p><h3 id="验收问题"><a href="#验收问题" class="headerlink" title="验收问题"></a>验收问题</h3><p>推荐看<a href="https://blog.csdn.net/qq_31028407/article/details/131118006" style="color: #177cb0; text-decoration: underline;text-decoration-style: dotted;">西电B测-计算机专业-计算机网络综合设计实验一站式指南（以2023.4为基准）</a>这篇博客, 老师问问题一般是按顺序问的, 对应的顺序就是你们进去坐的顺序.</p><p>我们组第一个人问的是: </p><ol><li>用的是什么路由?(静态路由) </li><li>还可以用什么?(动态路由RIP)</li><li>最常用的动态路由是什么?(OSPF)</li><li>静态路由路由表是在哪些设备上配置的，是如何配置的?</li></ol><p>第二个:</p><ol><li>dhcp分配地址在哪实现的？(指出配置的路由器)</li><li>dhcp的配置过程？(把代码口述一遍, 先设置路由器端口ip，然后允许dhcp，创建线程池，配置线程池网段、网关……)</li></ol><p>第三个:</p><ol><li>为什么是500000?(单位是kb,千兆端口…),直接问这个是我电脑上把这个交换机的配置display了, 老师看到就直接问了</li><li>arp泛洪攻击是什么?</li><li>arp泛洪攻击消耗的是什么资源?(arp表项资源)</li><li>arp欺骗是怎么做到的?(修改mac地址…)</li></ol>]]></content>
      
      
      <categories>
          
          <category> xdu </category>
          
      </categories>
      
      
        <tags>
            
            <tag> lab </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据安全检索</title>
      <link href="/2024/04/22/2024-4-22-%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8%E4%B8%8E%E9%9A%90%E7%A7%812/"/>
      <url>/2024/04/22/2024-4-22-%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8%E4%B8%8E%E9%9A%90%E7%A7%812/</url>
      
        <content type="html"><![CDATA[<h3 id="数据安全检索"><a href="#数据安全检索" class="headerlink" title="数据安全检索"></a>数据安全检索</h3><p>大数据安全与隐私这门课的lab2,要求如下图:</p><p><img src="https://pb01.s3.bitiful.net/184.webp" alt="avatar"></p><p>方案: </p><ol><li>采用OPE保序加密将NE.txt数据集加密为NE_encrypt.txt数据集</li><li>构建kd树</li><li>kd树搜索邻近节点</li></ol><h4 id="加密部分代码"><a href="#加密部分代码" class="headerlink" title="加密部分代码:"></a>加密部分代码:</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> numpy <span class="keyword">import</span> array</span><br><span class="line"><span class="keyword">from</span> pyope.ope <span class="keyword">import</span> OPE, ValueRange</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读入处理txt文件,返回二维数组，明文和密文</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">LoadTxtMethod</span>(<span class="params">filename</span>):</span><br><span class="line">    cipher = OPE(<span class="string">b&#x27;long key&#x27;</span> * <span class="number">2</span>, in_range=ValueRange(<span class="number">0</span>, <span class="number">10000000</span>),</span><br><span class="line">                 out_range=ValueRange(<span class="number">0</span>, <span class="number">100000000</span>))</span><br><span class="line">    result_m = <span class="built_in">list</span>()  <span class="comment"># 明文点</span></span><br><span class="line">    result_c = []</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> <span class="built_in">open</span>(filename):  <span class="comment"># 逐行打开文档.</span></span><br><span class="line">        plain_text = line.split(<span class="string">&#x27; &#x27;</span>, <span class="number">1</span>)</span><br><span class="line">        plain_text[<span class="number">0</span>] = <span class="built_in">float</span>(plain_text[<span class="number">0</span>])</span><br><span class="line">        plain_text[<span class="number">1</span>] = <span class="built_in">float</span>(plain_text[<span class="number">1</span>])</span><br><span class="line">        plain_text_arr = np.array(plain_text)  <span class="comment"># 转化数据格式</span></span><br><span class="line">        result_m.append(plain_text_arr)  <span class="comment"># 把第一列数据添加到result序列中</span></span><br><span class="line">        cipher_text = []</span><br><span class="line">        cipher_text.append(cipher.encrypt(<span class="built_in">int</span>(plain_text[<span class="number">0</span>] * <span class="number">1000000</span>)))</span><br><span class="line">        cipher_text.append(cipher.encrypt(<span class="built_in">int</span>(plain_text[<span class="number">1</span>] * <span class="number">1000000</span>)))</span><br><span class="line">        cipher_text_arr = np.array(cipher_text)  <span class="comment"># 转化数据格式</span></span><br><span class="line">        result_c.append(cipher_text_arr)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;加密&quot;</span> + <span class="built_in">str</span>(cipher_text_arr[<span class="number">0</span>]) + <span class="string">&#x27;,&#x27;</span> + <span class="built_in">str</span>(cipher_text_arr[<span class="number">1</span>]))</span><br><span class="line">    <span class="keyword">return</span> array(result_c)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">WriteTxt</span>(<span class="params">cipher_txt</span>):</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;NE_encrypt.txt&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> cipher_txt:</span><br><span class="line">            <span class="built_in">print</span>(<span class="built_in">type</span>(x))</span><br><span class="line">            strings = <span class="built_in">str</span>(x[<span class="number">0</span>]) + <span class="string">&#x27; &#x27;</span> + <span class="built_in">str</span>(x[<span class="number">1</span>]) + <span class="string">&#x27;\n&#x27;</span></span><br><span class="line">            f.write(strings)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    data = LoadTxtMethod(<span class="string">&#x27;NE.txt&#x27;</span>)  <span class="comment"># 调用上面数据处理程序</span></span><br><span class="line">    WriteTxt(data)  <span class="comment"># 加密之后的数据存放于cipherText.txt中</span></span><br></pre></td></tr></table></figure><h4 id="邻近搜索部分"><a href="#邻近搜索部分" class="headerlink" title="邻近搜索部分:"></a>邻近搜索部分:</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> numpy <span class="keyword">import</span> array</span><br><span class="line"><span class="keyword">from</span> pyope.ope <span class="keyword">import</span> OPE, ValueRange</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建类，用于保存结点的值，左右子树，以及用于划分左右子树的切分轴</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">decision_node</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, value=<span class="literal">None</span>, col=<span class="literal">None</span>, rb=<span class="literal">None</span>, lb=<span class="literal">None</span></span>):</span><br><span class="line">        self.value = value  <span class="comment"># 点</span></span><br><span class="line">        self.col = col  <span class="comment"># 切分的维度</span></span><br><span class="line">        self.rb = rb  <span class="comment"># 右子树</span></span><br><span class="line">        self.lb = lb  <span class="comment"># 左子树</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">LoadTxtMethod</span>(<span class="params">filename</span>):  <span class="comment"># 传入形参,txt的名字.</span></span><br><span class="line">    result = <span class="built_in">list</span>()  <span class="comment"># 创建要返回的数据.</span></span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> <span class="built_in">open</span>(filename):  <span class="comment"># 逐行打开文档.</span></span><br><span class="line">        data = line.split(<span class="string">&#x27; &#x27;</span>, <span class="number">1</span>)</span><br><span class="line">        data[<span class="number">0</span>] = <span class="built_in">float</span>(data[<span class="number">0</span>])</span><br><span class="line">        data[<span class="number">1</span>] = <span class="built_in">float</span>(data[<span class="number">1</span>])</span><br><span class="line">        data_float = np.array(data)</span><br><span class="line">        result.append(data_float)  <span class="comment"># 把第一列数据添加到result序列中</span></span><br><span class="line">    <span class="keyword">return</span> array(result)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 切分点为坐标轴上的中值，求一个序列的中值</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">median</span>(<span class="params">x</span>):</span><br><span class="line">    n = <span class="built_in">len</span>(x)</span><br><span class="line">    x = <span class="built_in">list</span>(x)</span><br><span class="line">    x_order = <span class="built_in">sorted</span>(x)</span><br><span class="line">    <span class="keyword">return</span> x_order[n // <span class="number">2</span>], x.index(x_order[n // <span class="number">2</span>])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 以j列的中值划分数据，左小右大，j=节点深度%列数，列数这里是2</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">build_tree</span>(<span class="params">x, j=<span class="number">0</span></span>):</span><br><span class="line">    rb = []</span><br><span class="line">    lb = []</span><br><span class="line">    m, n = x.shape</span><br><span class="line">    <span class="keyword">if</span> m == <span class="number">0</span>: <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    edge, row = median(x[:, j].copy())</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">        <span class="keyword">if</span> x[i][j] &gt; edge:</span><br><span class="line">            rb.append(i)</span><br><span class="line">        <span class="keyword">if</span> x[i][j] &lt; edge:</span><br><span class="line">            lb.append(i)</span><br><span class="line">    rb_x = x[rb, :]</span><br><span class="line">    lb_x = x[lb, :]</span><br><span class="line">    rightBranch = build_tree(rb_x, (j + <span class="number">1</span>) % n)</span><br><span class="line">    leftBranch = build_tree(lb_x, (j + <span class="number">1</span>) % n)</span><br><span class="line">    <span class="keyword">return</span> decision_node(x[row, :], j, rightBranch, leftBranch)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 搜索树：输出目标点的近邻点</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">travel_tree</span>(<span class="params">node, aim</span>):</span><br><span class="line">    <span class="keyword">global</span> pointlist  <span class="comment"># 存储排序后的k近邻点和对应距离</span></span><br><span class="line">    <span class="keyword">if</span> node <span class="keyword">is</span> <span class="literal">None</span>: <span class="keyword">return</span></span><br><span class="line">    col = node.col</span><br><span class="line">    <span class="keyword">if</span> aim[col] &gt; node.value[col]:  <span class="comment"># 顺着树进行搜索，分类</span></span><br><span class="line">        travel_tree(node.rb, aim)</span><br><span class="line">    <span class="keyword">if</span> aim[col] &lt; node.value[col]:</span><br><span class="line">        travel_tree(node.lb, aim)</span><br><span class="line">    dis = dist(node.value, aim)</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(knears) &lt; k:  <span class="comment"># k是输入的要查询的个数，前k个点就是目标点x的k近邻</span></span><br><span class="line">        knears.setdefault(<span class="built_in">tuple</span>(node.value.tolist()), dis)  <span class="comment"># 列表不能作为字典的键</span></span><br><span class="line">        pointlist = <span class="built_in">sorted</span>(knears.items(), key=<span class="keyword">lambda</span> item: item[<span class="number">1</span>], reverse=<span class="literal">True</span>)</span><br><span class="line">    <span class="keyword">elif</span> dis &lt;= pointlist[<span class="number">0</span>][<span class="number">1</span>]:</span><br><span class="line">        knears.setdefault(<span class="built_in">tuple</span>(node.value.tolist()), dis)</span><br><span class="line">        pointlist = <span class="built_in">sorted</span>(knears.items(), key=<span class="keyword">lambda</span> item: item[<span class="number">1</span>], reverse=<span class="literal">True</span>)</span><br><span class="line">    <span class="keyword">if</span> node.rb <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">or</span> node.lb <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="comment"># 对于父节点来说，如果目标点与其切分轴之间的距离不大于字典中各结点所对应距离的的最大值，便需要访问该父节点的另一个子节点</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">abs</span>(aim[node.col] - node.value[node.col]) &lt; pointlist[<span class="number">0</span>][<span class="number">1</span>]:</span><br><span class="line">            <span class="keyword">if</span> aim[node.col] &lt; node.value[node.col]:</span><br><span class="line">                travel_tree(node.rb, aim)</span><br><span class="line">            <span class="keyword">if</span> aim[node.col] &gt; node.value[node.col]:</span><br><span class="line">                travel_tree(node.lb, aim)</span><br><span class="line">    <span class="keyword">return</span> pointlist</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dist</span>(<span class="params">x1, x2</span>):  <span class="comment"># 欧式距离的计算</span></span><br><span class="line">    <span class="keyword">return</span> ((np.array(x1) - np.array(x2)) ** <span class="number">2</span>).<span class="built_in">sum</span>() ** <span class="number">0.5</span></span><br><span class="line"></span><br><span class="line">cipher = OPE(<span class="string">b&#x27;long key&#x27;</span> * <span class="number">2</span>, in_range=ValueRange(<span class="number">0</span>, <span class="number">10000000</span>),</span><br><span class="line">                 out_range=ValueRange(<span class="number">0</span>, <span class="number">100000000</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 保序加密</span></span><br><span class="line"><span class="comment"># 输入给的点，输出调用pyope库加密的点</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">encryption</span>(<span class="params">point</span>):</span><br><span class="line">    point[<span class="number">0</span>] = <span class="built_in">float</span>(point[<span class="number">0</span>])</span><br><span class="line">    point[<span class="number">1</span>] = <span class="built_in">float</span>(point[<span class="number">1</span>])  <span class="comment"># 把array中的点转化为float类型</span></span><br><span class="line">    en_point = []</span><br><span class="line">    en_point.append(cipher.encrypt(<span class="built_in">int</span>(point[<span class="number">0</span>] * <span class="number">1000000</span>)))</span><br><span class="line">    en_point.append(cipher.encrypt(<span class="built_in">int</span>(point[<span class="number">1</span>] * <span class="number">1000000</span>)))</span><br><span class="line">    en_point_arr = np.array(en_point)  <span class="comment"># 转化数据格式</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> en_point_arr</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 保序解密</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">decryption</span>(<span class="params">point</span>):</span><br><span class="line">    point[<span class="number">0</span>] = <span class="built_in">int</span>(point[<span class="number">0</span>])</span><br><span class="line">    point[<span class="number">1</span>] = <span class="built_in">int</span>(point[<span class="number">1</span>])</span><br><span class="line">    de_point = []</span><br><span class="line">    de_point.append(cipher.decrypt(point[<span class="number">0</span>]) / <span class="number">1000000</span>)</span><br><span class="line">    de_point.append(cipher.decrypt(point[<span class="number">1</span>]) / <span class="number">1000000</span>)</span><br><span class="line">    de_point_arr = np.array(de_point)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> de_point_arr</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    tmp = <span class="built_in">input</span>(<span class="string">&#x27;请输入目标点:&#x27;</span>)</span><br><span class="line">    tmp = tmp.split(<span class="string">&#x27;,&#x27;</span>)</span><br><span class="line">    point_tmp = encryption(tmp)</span><br><span class="line">    aim = []</span><br><span class="line">    <span class="keyword">for</span> num <span class="keyword">in</span> point_tmp:</span><br><span class="line">        aim.append(num)</span><br><span class="line">    knears = &#123;&#125;</span><br><span class="line">    k = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&#x27;请输入需要查询的点的个数&#x27;</span>))</span><br><span class="line">    file = <span class="string">&#x27;NE_encrypt.txt&#x27;</span></span><br><span class="line">    data_c = LoadTxtMethod(file)</span><br><span class="line">    tree = build_tree(data_c)  <span class="comment"># 构建KD tree</span></span><br><span class="line"></span><br><span class="line">    pointlist = travel_tree(tree, aim)  <span class="comment"># 对目标点进行检索</span></span><br><span class="line">    i = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> point <span class="keyword">in</span> pointlist[-k:]:  <span class="comment"># 里面存的有点，和欧式距离</span></span><br><span class="line">        x = [point[<span class="number">0</span>][<span class="number">0</span>], point[<span class="number">0</span>][<span class="number">1</span>]]</span><br><span class="line">        de_point = decryption(x)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;****************--------第&quot;</span> + <span class="built_in">str</span>(i) + <span class="string">&quot;条检索数据--------****************&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;检索结果: &quot;</span>, de_point)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;距离为:&quot;</span>, dist(tmp, de_point))</span><br><span class="line">        i = i + <span class="number">1</span></span><br></pre></td></tr></table></figure><h4 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h4><p><img src="https://pb01.s3.bitiful.net/185.webp" alt="avatar"></p>]]></content>
      
      
      <categories>
          
          <category> xdu </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 安全 </tag>
            
            <tag> lab </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>个人图床解决方案</title>
      <link href="/2024/04/21/2024-4-21-%E5%9B%BE%E5%BA%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
      <url>/2024/04/21/2024-4-21-%E5%9B%BE%E5%BA%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
      
        <content type="html"><![CDATA[<h3 id="个人图床解决方案"><a href="#个人图床解决方案" class="headerlink" title="个人图床解决方案"></a>个人图床解决方案</h3><p>原先我的解决方案是github做图床,套一层Cloudflare的cdn来加速国内访问, 但国内访问仍然过慢, 特别是一些图很多的文章, 加载非常慢. 所以我想着改善一下, 在对比了一些解决方案之后, 我选择了PicGo+<a href="https://www.bitiful.com/" style="color: #177cb0; text-decoration: underline;text-decoration-style: dotted;">缤纷云</a>搭建主图床, 部分图片放在 <a href="https://7bu.top/login" style="color: #177cb0; text-decoration: underline;text-decoration-style: dotted;">去不图床</a>, 原先的方案作为备用方案.</p><p>我用去不图床存储常用固定图片, 像背景图这些, 单图10G的流量, PicGo+缤纷云存储文章内插图, 每月10G免费流量, 虽然去不图床和缤纷云都不是像阿里云, 腾讯云这样的大厂, 如果它们跑路的话, 我的备用方案可以立马顶上, 两分钟之内就可以做到替换完成, 所以说还是没有太大隐患</p><h4 id="缤纷云"><a href="#缤纷云" class="headerlink" title="缤纷云"></a>缤纷云</h4><p>注册并实名之后就会拥有每月赠送的30G流量</p><p><strong>创建桶</strong><br><img src="https://pb01.s3.bitiful.net/173.webp" alt="avatar"><br><img src="https://pb01.s3.bitiful.net/174.webp" alt="avatar"></p><p><strong>防盗链配置</strong><br><img src="https://pb01.s3.bitiful.net/175.webp" alt="avatar"></p><p><strong>添加子用户</strong><br><img src="https://pb01.s3.bitiful.net/176.webp" alt="avatar"><br><img src="https://pb01.s3.bitiful.net/177.webp" alt="avatar"></p><p>Access Key和 Secret Key要记好,等会配置PicGo的时候要用到</p><h4 id="picGo"><a href="#picGo" class="headerlink" title="picGo"></a>picGo</h4><p><strong>下载picGo</strong>, 可以去看官方文档, 写得很详细, 我是从山东大学镜像下载的<br><img src="https://pb01.s3.bitiful.net/178.webp" alt="avatar"><br><img src="https://pb01.s3.bitiful.net/179.webp" alt="avatar"></p><p>由于缤纷云不是PicGo官方支持的云服务厂商, 所以得靠插件来实现, 由于支持s3 api, 所以我选择了Amazon s3插件<br><img src="https://pb01.s3.bitiful.net/180.webp" alt="avatar"></p><p><strong>配置</strong><br><img src="https://pb01.s3.bitiful.net/181.webp" alt="avatar"></p><p>应用秘钥ID填Access Key, 应用秘钥填Secret Key, 桶名填你创建的桶名, 文件路径随便填(符合格式就行), 地区和自定义节点在桶信息中都有</p><p><img src="https://pb01.s3.bitiful.net/182.webp" alt="avatar"></p><p>要注意的是在填自定义节点的时候前面要加上https://, 否则会报错<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">TypeError [ERR_INVALID_URL]: Invalid URL</span><br><span class="line">    at new NodeError (node:internal/errors:371:5)</span><br><span class="line">    at onParseError (node:internal/url:552:9)</span><br><span class="line">    at new URL (node:internal/url:628:5)</span><br><span class="line">    at parseUrl (C:\Users\levit\AppData\Roaming\picgo\node_modules\@smithy\url-parser\dist-cjs\index.js:29:21)</span><br><span class="line">    at toEndpointV1 (C:\Users\levit\AppData\Roaming\picgo\node_modules\@smithy\middleware-endpoint\dist-cjs\index.js:112:41)</span><br><span class="line">    at customEndpointProvider (C:\Users\levit\AppData\Roaming\picgo\node_modules\@smithy\middleware-endpoint\dist-cjs\index.js:232:65)</span><br></pre></td></tr></table></figure><br><img src="https://pb01.s3.bitiful.net/183.webp" alt="avatar"></p><p> 它们官方和插件文档写的是匹配的, 导致一开始让我以为是我的Node.js版本太高导致的</p><p> 差点忘了, PicGo插件需要16.0.0版本以上的Node.js才行</p>]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> blog </tag>
            
            <tag> 图床 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网站性能检测与优化</title>
      <link href="/2024/04/20/2024-4-20-%E7%BD%91%E7%AB%99%E6%80%A7%E8%83%BD/"/>
      <url>/2024/04/20/2024-4-20-%E7%BD%91%E7%AB%99%E6%80%A7%E8%83%BD/</url>
      
        <content type="html"><![CDATA[<h2 id="网站性能检测与优化"><a href="#网站性能检测与优化" class="headerlink" title="网站性能检测与优化"></a>网站性能检测与优化</h2><h3 id="性能检测"><a href="#性能检测" class="headerlink" title="性能检测"></a>性能检测</h3><h4 id="Lighthouse"><a href="#Lighthouse" class="headerlink" title="Lighthouse"></a>Lighthouse</h4><p>Lighthouse 是一个网站性能测评工具， 它是 Google Chrome 推出的一个开源自动化工具，能够对 PWA 和网页多方面的效果指标进行评测，并给出最佳实践的建议以帮助开发者改进网站的质量。它的使用方法也非常简单，我们只需要提供一个要测评的网址，它将针对此页面运行一系列的测试，然后生成一个有关页面性能的报告。通过报告我们就可以知道需要采取哪些措施来改进应用的性能和体验。</p><p>在高版本（应该是 &gt;= 60）的 Chrome 浏览器中，Lighthouse 已经直接集成到了调试工具 DevTools 中了，因此不需要进行任何安装或下载。按 F12 打开开发者工具，可以看到在 console、security 等选项后面有一个 Lighthouse （低版本的谷歌浏览器可能显示的是 Audits）选项，选择该选项，然后点击 Analyse page load 即可。</p><p><img src="https://pb01.s3.bitiful.net/171.webp" alt="avatar"></p><p>使用 Lighthouse 对网站进行测评后，我们会得到一份评分报告，它包含了性能（Performance），访问无障碍（Accessibility），最佳实践（Best Practice），搜索引擎优化（SEO），PWA（Progressive Web App）五个部分：</p><p><img src="https://pb01.s3.bitiful.net/169.webp" alt="avatar"></p><p>还有详细的分析:</p><p><img src="https://pb01.s3.bitiful.net/170.webp" alt="avatar"></p><p>从这张图我们可以看出来主要需要优化的有:图片,文本,css和js等静态资源</p><h5 id="性能（Performance）"><a href="#性能（Performance）" class="headerlink" title="性能（Performance）"></a>性能（Performance）</h5><p>性能评分的分值区间是0到100，如果出现0分，通常是在运行 Lighthouse 时发生了错误，满分100分代表了网站已经达到了98分位值的数据，而50分则是75分位值的数据。</p><p>影响评分的性能指标：性能测试结果会分成 Metrics，Diagnostic，Opportunities 三部分，但只有 Metrics 部分的指标项会对分数产生直接影响。</p><p>Lighthouse 会衡量以下 Metrics 性能指标项：</p><ul><li>首次内容绘制（First Contentful Paint）。即浏览器首次将任意内容（如文字、图像、canvas 等）绘制到屏幕上的时间点。</li><li>首次有效绘制（First Meaningful Paint）。衡量了用户感知页面的主要内容（primary content）可见的时间。对于不同的站点，首要内容是不同的，例如：对于博客文章，标题及首屏文字是首要内容，而对于购物网站来说，图片也会变得很重要。</li><li>首次 CPU 空闲（First CPU Idle）。即页面首次能够对输入做出反应的时间点，其出现时机往往在首次有效绘制完成之后。该指标目前仍处于实验阶段。</li><li>可交互时间（Time to Interactive）。指的是所有的页面内容都已经成功加载，且能够快速地对用户的操作做出反应的时间点。该指标目前仍处于实验阶段。</li><li>速度指标（Speed Index）。衡量了首屏可见内容绘制在屏幕上的速度。在首次加载页面的过程中尽量展现更多的内容，往往能给用户带来更好的体验，所以速度指标的值约小越好。</li><li>输入延迟估值（Estimated Input Latency）。这个指标衡量了页面对用户输入行为的反应速度，其基准值应低于 50ms。</li></ul><p>Metrics 部分的指标项会直接影响分数，可以作为我们的主要参考点。</p><p>另外的两部分中， Opportunities 指的是优化机会，它提供了详细的建议和文档，来解释低分的原因，帮助我们具体进行实现和改进。Diagnostics 指的是现在存在的问题，为进一步改善性能的实验和调整给出了指导。这两者不会纳入分数的计算。</p><p>每一项性能指标对评分的贡献都有其计算逻辑，Lighthouse 会将原始的性能值映射成为 0-100 之间的数字。</p><p>针对不同的评分，Lighthouse 用了不同的颜色进行标注，分值区间和颜色的对应关系如下：</p><ul><li><code>0 - 49（慢）：红色</code></li><li><code>50 - 89（平均值）： 橙色</code></li><li><code>90 - 100（快）： 绿色</code></li></ul><h5 id="访问无障碍（Accessibility）"><a href="#访问无障碍（Accessibility）" class="headerlink" title="访问无障碍（Accessibility）"></a>访问无障碍（Accessibility）</h5><p>访问无障碍评分的分值由相关指标的加权平均值计算而来。可以在评分详情查阅每项指标的具体权重。同理，较大权重的指标项对分数的影响较大。</p><p>无障碍性的每个指标项测试结果为pass或者fail，与性能指标项的计算方式不同，当页面只是部分通过某项指标时，页面的这项指标将不会得分。例如，如果页面中的一些元素有屏幕阅读器友好的命名，而其他的元素没有，那么这个页面的 screenreader-friendly-names 指标项得分为0。</p><h5 id="最佳实践（优化）（Best-Practice）"><a href="#最佳实践（优化）（Best-Practice）" class="headerlink" title="最佳实践（优化）（Best Practice）"></a>最佳实践（优化）（Best Practice）</h5><p>最佳实践评分的分数区间为0-100。影响这项评分的指标项的权重都是相同的。</p><p>比如：推荐使用 https，跨域的跳转链接需要使用 rel 标识，不能使用废弃的 API等等。</p><h5 id="搜索引擎优化（SEO）"><a href="#搜索引擎优化（SEO）" class="headerlink" title="搜索引擎优化（SEO）"></a>搜索引擎优化（SEO）</h5><p>比如：图片元素使用 alt 属性等等提高搜索引擎搜索排名，便于搜索引擎能找到你这个网站。</p><h5 id="PWA（Progressive-Web-App）"><a href="#PWA（Progressive-Web-App）" class="headerlink" title="PWA（Progressive Web App）"></a>PWA（Progressive Web App）</h5><p>Lighthouse 使用 PWA 基准检查项列表（Baseline PWA Checklist）进行测评，测评结果将这些指标项分成了四个类别，共包含12个自动测试项和3个手动测试项，其中各个自动测试项的评分权重是相同的。PWA 的评测指标对我们来说非常重要，我们可以从这四个类别详细了解一下基准指标项。</p><p><strong>快速可靠</strong>：</p><ol><li>页面在移动网络条件下能够快速加载。</li><li>在离线条件下页面能够返回状态码200。</li><li>start_url 在离线条件下返回状态码200。打开该 PWA 时加载的 URL。</li></ol><p><strong>可安装</strong>：</p><ol><li>始终使用 HTTPS。</li><li>注册 Service Worker 来缓存页面以及 start_url。</li><li>使用 manifest 文件来实现安装 PWA 的需求，浏览器能够主动通知用户将应用添加到桌面，增加留存率。</li></ol><p><strong>PWA 优化</strong>：</p><ol><li>将 HTTP 流量重定向到 HTTPS。</li><li>配置自定义启动画面。</li><li>设置地址栏主题颜色。</li><li>页面内容针对视口大小自适应，对移动用户的展示更友好。</li><li>使用了标签，并设置了 width 或 initial-scale 属性。</li><li>当 JavaScript 文件不可用时，提供降级措施，页面能显示基本内容而不出现白屏。</li></ol><p><strong>手动测试项</strong>：</p><ol><li>站点跨浏览器可用，如主流浏览器 Chrome, Edge, Firefox 及 Safari 等。</li><li>页面间切换流畅，即使在较差的网络环境下，切换动画也应该简洁顺畅，这是提高用户感知体验的关键。</li><li>保证每个页面都有独一无二的 URL，能够在新的浏览器窗口打开，且方便在社交媒体上进行分享。</li><li>除了上述基准指标项之外，为了让 PWA 的体验更加完美，还有一些 Lighthouse 未实现检查的进阶指标，也就是可以作为示范性参考的 PWA 的指标，比如用户体验、缓存、推送通知等等。</li></ol><h3 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h3><h4 id="图片优化"><a href="#图片优化" class="headerlink" title="图片优化"></a>图片优化</h4><p>整体思路就是<code>压缩图片</code>，减少图片体积，提高加载速度.推荐采用webp格式,在图片质量相似的情况下可以节省约50%的体积</p><p>我之前的图片以png为主,还有一部分是webp,由于图片太多,全转很麻烦,我先将部分常用png(背景图,封面图等)转成了webp,然后将全部png进行压缩,之后新增的图片全转为webp格式</p><p>使用工具:<a href="https://imagestool.com/zh_CN/" style="color: #177cb0; text-decoration: underline;text-decoration-style: dotted;">imagestool</a>,支持批量转换,转换速度很快</p><p>还有就是<code>懒加载</code>,有节省流量与提高性能的作用。Butterfly主题内置了图片懒加载的选项，在_config.butterfly.yml文件下将对应项设置为如下即可：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Lazyload (圖片懶加載)</span></span><br><span class="line"><span class="comment"># https://github.com/verlok/vanilla-lazyload</span></span><br><span class="line"><span class="attr">lazyload:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">field:</span> <span class="string">site</span> <span class="comment"># site/post 选择在哪些地方启用图片懒加载</span></span><br><span class="line">  <span class="attr">placeholder:</span> <span class="comment"># 你自己喜欢的图片</span></span><br><span class="line">  <span class="attr">blur:</span> <span class="literal">true</span><span class="comment"># 模糊效果</span></span><br></pre></td></tr></table></figure><h4 id="字体优化"><a href="#字体优化" class="headerlink" title="字体优化"></a>字体优化</h4><p>从Lighthouse的详情分析中我得知网站首页的字体加载速度很慢,如图:</p><p><img src="https://pb01.s3.bitiful.net/172.webp" alt="avatar"></p><p>我们从网上下载的字体通常都是TTF格式，ttf(TrueTypeFont)是一种字库名称，是Apple公司和Microsoft公司共同推出的字体文件格式，也是最常用的格式之一，但是一些好看的字体往往体积都会很大，网站每次进去都要加载一个这么大的文件，速度肯定会很慢！</p><p>采用fonttools编码压缩+转woff2格式二级压缩,参考<a href="https://blog.csdn.net/littleduo/article/details/124563106" style="color: #177cb0; text-decoration: underline;text-decoration-style: dotted;">有效的字体压缩方法</a></p><h4 id="静态资源优化"><a href="#静态资源优化" class="headerlink" title="静态资源优化"></a>静态资源优化</h4><p>安装Gulp插件：在博客根目录[Blogroot]打开终端，输入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install --global gulp-cli <span class="comment">#全局安装gulp指令集</span></span><br><span class="line">npm install gulp --save <span class="comment">#安装gulp插件</span></span><br></pre></td></tr></table></figure><p>安装各个下属插件以实现对各类静态资源的压缩</p><p><strong>HTML压缩</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm install gulp-htmlclean --save-dev</span><br><span class="line">npm install gulp-html-minifier-terser --save-dev</span><br><span class="line"><span class="comment"># 用gulp-html-minifier-terser可以压缩HTML中的ES6语法</span></span><br></pre></td></tr></table></figure></p><p><strong>CSS压缩</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install gulp-htmlclean --save-dev</span><br></pre></td></tr></table></figure></p><p><strong>JS压缩</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install gulp-terser --save-dev</span><br></pre></td></tr></table></figure></p><p><strong>字体包压缩</strong><br>font-min仅支持压缩ttf格式的字体包<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install gulp-fontmin --save-dev</span><br></pre></td></tr></table></figure></p><p>为Gulp创建gulpfile.js任务脚本。在博客根目录[Blogroot]下新建gulpfile.js,打开[Blogroot]\gulpfile.js,输入以下内容<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用到的各个插件</span></span><br><span class="line"><span class="keyword">var</span> gulp = <span class="built_in">require</span>(<span class="string">&#x27;gulp&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> cleanCSS = <span class="built_in">require</span>(<span class="string">&#x27;gulp-clean-css&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> htmlmin = <span class="built_in">require</span>(<span class="string">&#x27;gulp-html-minifier-terser&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> htmlclean = <span class="built_in">require</span>(<span class="string">&#x27;gulp-htmlclean&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> fontmin = <span class="built_in">require</span>(<span class="string">&#x27;gulp-fontmin&#x27;</span>);</span><br><span class="line"><span class="comment">// gulp-tester</span></span><br><span class="line"><span class="keyword">var</span> terser = <span class="built_in">require</span>(<span class="string">&#x27;gulp-terser&#x27;</span>);</span><br><span class="line"><span class="comment">// 压缩js</span></span><br><span class="line">gulp.<span class="title function_">task</span>(<span class="string">&#x27;compress&#x27;</span>, <span class="title function_">async</span>() =&gt;&#123;</span><br><span class="line">  gulp.<span class="title function_">src</span>([<span class="string">&#x27;./public/**/*.js&#x27;</span>, <span class="string">&#x27;!./public/**/*.min.js&#x27;</span>])</span><br><span class="line">    .<span class="title function_">pipe</span>(<span class="title function_">terser</span>())</span><br><span class="line">    .<span class="title function_">pipe</span>(gulp.<span class="title function_">dest</span>(<span class="string">&#x27;./public&#x27;</span>))</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//压缩css</span></span><br><span class="line">gulp.<span class="title function_">task</span>(<span class="string">&#x27;minify-css&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> gulp.<span class="title function_">src</span>([<span class="string">&#x27;./public/**/*.css&#x27;</span>])</span><br><span class="line">        .<span class="title function_">pipe</span>(<span class="title function_">cleanCSS</span>(&#123;</span><br><span class="line">            <span class="attr">compatibility</span>: <span class="string">&#x27;ie11&#x27;</span></span><br><span class="line">        &#125;))</span><br><span class="line">        .<span class="title function_">pipe</span>(gulp.<span class="title function_">dest</span>(<span class="string">&#x27;./public&#x27;</span>));</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//压缩html</span></span><br><span class="line">gulp.<span class="title function_">task</span>(<span class="string">&#x27;minify-html&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> gulp.<span class="title function_">src</span>(<span class="string">&#x27;./public/**/*.html&#x27;</span>)</span><br><span class="line">        .<span class="title function_">pipe</span>(<span class="title function_">htmlclean</span>())</span><br><span class="line">        .<span class="title function_">pipe</span>(<span class="title function_">htmlmin</span>(&#123;</span><br><span class="line">            <span class="attr">removeComments</span>: <span class="literal">true</span>, <span class="comment">//清除html注释</span></span><br><span class="line">            <span class="attr">collapseWhitespace</span>: <span class="literal">true</span>, <span class="comment">//压缩html</span></span><br><span class="line">            <span class="attr">collapseBooleanAttributes</span>: <span class="literal">true</span>,</span><br><span class="line">            <span class="comment">//省略布尔属性的值，例如：&lt;input checked=&quot;true&quot;/&gt; ==&gt; &lt;input /&gt;</span></span><br><span class="line">            <span class="attr">removeEmptyAttributes</span>: <span class="literal">true</span>,</span><br><span class="line">            <span class="comment">//删除所有空格作属性值，例如：&lt;input id=&quot;&quot; /&gt; ==&gt; &lt;input /&gt;</span></span><br><span class="line">            <span class="attr">removeScriptTypeAttributes</span>: <span class="literal">true</span>,</span><br><span class="line">            <span class="comment">//删除&lt;script&gt;的type=&quot;text/javascript&quot;</span></span><br><span class="line">            <span class="attr">removeStyleLinkTypeAttributes</span>: <span class="literal">true</span>,</span><br><span class="line">            <span class="comment">//删除&lt;style&gt;和&lt;link&gt;的 type=&quot;text/css&quot;</span></span><br><span class="line">            <span class="attr">minifyJS</span>: <span class="literal">true</span>, <span class="comment">//压缩页面 JS</span></span><br><span class="line">            <span class="attr">minifyCSS</span>: <span class="literal">true</span>, <span class="comment">//压缩页面 CSS</span></span><br><span class="line">            <span class="attr">minifyURLs</span>: <span class="literal">true</span>  <span class="comment">//压缩页面URL</span></span><br><span class="line">        &#125;))</span><br><span class="line">        .<span class="title function_">pipe</span>(gulp.<span class="title function_">dest</span>(<span class="string">&#x27;./public&#x27;</span>))</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//压缩字体</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">minifyFont</span>(<span class="params">text, cb</span>) &#123;</span><br><span class="line">  gulp</span><br><span class="line">    .<span class="title function_">src</span>(<span class="string">&#x27;./public/fonts/*.ttf&#x27;</span>) <span class="comment">//原字体所在目录</span></span><br><span class="line">    .<span class="title function_">pipe</span>(<span class="title function_">fontmin</span>(&#123;</span><br><span class="line">      <span class="attr">text</span>: text</span><br><span class="line">    &#125;))</span><br><span class="line">    .<span class="title function_">pipe</span>(gulp.<span class="title function_">dest</span>(<span class="string">&#x27;./public/fontsdest/&#x27;</span>)) <span class="comment">//压缩后的输出目录</span></span><br><span class="line">    .<span class="title function_">on</span>(<span class="string">&#x27;end&#x27;</span>, cb);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">gulp.<span class="title function_">task</span>(<span class="string">&#x27;mini-font&#x27;</span>, <span class="function">(<span class="params">cb</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">var</span> buffers = [];</span><br><span class="line">  gulp</span><br><span class="line">    .<span class="title function_">src</span>([<span class="string">&#x27;./public/**/*.html&#x27;</span>]) <span class="comment">//HTML文件所在目录请根据自身情况修改</span></span><br><span class="line">    .<span class="title function_">on</span>(<span class="string">&#x27;data&#x27;</span>, <span class="keyword">function</span>(<span class="params">file</span>) &#123;</span><br><span class="line">      buffers.<span class="title function_">push</span>(file.<span class="property">contents</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">    .<span class="title function_">on</span>(<span class="string">&#x27;end&#x27;</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">var</span> text = <span class="title class_">Buffer</span>.<span class="title function_">concat</span>(buffers).<span class="title function_">toString</span>(<span class="string">&#x27;utf-8&#x27;</span>);</span><br><span class="line">      <span class="title function_">minifyFont</span>(text, cb);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 运行gulp命令时依次执行以下任务</span></span><br><span class="line">gulp.<span class="title function_">task</span>(<span class="string">&#x27;default&#x27;</span>, gulp.<span class="title function_">parallel</span>(</span><br><span class="line">  <span class="string">&#x27;compress&#x27;</span>, <span class="string">&#x27;minify-css&#x27;</span>, <span class="string">&#x27;minify-html&#x27;</span>,<span class="string">&#x27;mini-font&#x27;</span></span><br><span class="line">))</span><br></pre></td></tr></table></figure></p><p>在每次运行完hexo generate生成静态页面后，运行gulp对其进行压缩。指令流程如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo generate</span><br><span class="line">gulp</span><br><span class="line">hexo server 或 hexo deploy</span><br></pre></td></tr></table></figure></p><p>当然还可以通过<code>减少加载项</code>的方式来优化:</p><ul><li>减少卡片的出场动画wowjs、Live2D、canvas元素等(其中Live2D是比较消耗资源的)</li><li>如果部分js和css文件只有部分页面需要引用，尽量不全局引用，同时删除空格、空行、注释、减少无意义的单位</li><li>css文件尽量添加media字段指定加载设备，js文件的引入可以加入 的 async、defer 属性异步加载，不阻塞 DOM 渲染</li></ul>]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> blog </tag>
            
            <tag> 优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis线程模型</title>
      <link href="/2024/04/16/2024-4-14-redis%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/"/>
      <url>/2024/04/16/2024-4-14-redis%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="Redis线程模型和IO多路复用"><a href="#Redis线程模型和IO多路复用" class="headerlink" title="Redis线程模型和IO多路复用"></a>Redis线程模型和IO多路复用</h2><h4 id="Redis是单线程的吗？"><a href="#Redis是单线程的吗？" class="headerlink" title="Redis是单线程的吗？"></a>Redis是单线程的吗？</h4><p>redis6.0后，全面支持多线程。redis单线程指的是 <code>接收请求、解析请求、进行数据读写操作、返回数据</code>给客户端这个过程是由一个线程来完成的以及Redis的网络IO是由一个线程来完成的。所以我们称redis为单线程。</p><p>但是redis服务在启动的时候，会启动后台线程，常见的有两个</p><ul><li>后台刷盘线程：当我们配置AOF策略为everysec时，每隔一秒，由后台线程完成刷盘操作</li><li>后台释放内存线程：redis 提供unlink命令，异步释放内存，特别是大key</li></ul><p>之所以有后台线程，只为了不让主线程去执行这些操作，避免阻塞主线程，无法响应请求。</p><h4 id="Redis为什么采用单线程？"><a href="#Redis为什么采用单线程？" class="headerlink" title="Redis为什么采用单线程？"></a>Redis为什么采用单线程？</h4><p>Redis 的大部分操作都在内存中完成，并且采用了高效的数据结构，因此 Redis 瓶颈可能是机器的内存或者网络带宽，而并非 CPU，所以 Redis 核心网络模型使用单线程并没有什么问题，而且单线程避免了多线程之间并发竞争问题，省去了多线程切换带来的时间和性能上的开销，也不会导致死锁问题。</p><p><code>Redis 6.0引入多线程后，会产生并发安全问题吗？</code><br>不会,引入的多线程只是针对网络IO，在执行命令的时候，仍然是单线程执行</p><h4 id="Redis-6-0-之后为什么引入了多线程？"><a href="#Redis-6-0-之后为什么引入了多线程？" class="headerlink" title="Redis 6.0 之后为什么引入了多线程？"></a>Redis 6.0 之后为什么引入了多线程？</h4><p>虽然 Redis 的主要工作（网络 I/O 和执行命令）一直是单线程模型，但是在 Redis 6.0 版本之后，也采用了多个 I/O 线程来处理网络请求，这是因为随着网络硬件的性能提升，Redis 的性能瓶颈有时会出现在网络 I/O 的处理上。</p><p>所以为了提高网络 I/O 的并行度，Redis 6.0 对于网络 I/O 采用多线程来处理。对于命令的执行，Redis 仍然使用单线程来处理，不要误解 Redis 有多线程同时执行命令。Redis 官方表示，Redis 6.0 版本引入的多线程 I/O 特性对性能提升至少是一倍以上。</p><h4 id="Redis-采用单线程为什么还这么快？"><a href="#Redis-采用单线程为什么还这么快？" class="headerlink" title="Redis 采用单线程为什么还这么快？"></a>Redis 采用单线程为什么还这么快？</h4><ol><li>Redis 的大部分操作都在内存中完成，并且采用了高效的数据结构，</li><li>Redis 采用单线程模型避免了多线程之间并发竞争问题，省去了多线程切换带来的时间和性能上的开销，也不会导致死锁问题。</li><li>Redis 采用了 I/O 多路复用的网络模型，来处理客户端产生的事件,即让一个线程同时与多个已完成连接socket进行通信，所以称为多路复用。用户态的线程怎么感知呢？实现这一机制的核心是：内核提供的 select() / epoll() 系统调用函数，来允许Redis 只运行单线程的情况下，同时和多个已完成连接的 Socket进行通信。让处于用户态的线程，发现请求网络事件的socket，线程才可以做出相应的处理.类似于CPU并发调度线程，一旦有请求到达，就会交给 Redis 线程处理，这就实现了一个 Redis 线程处理多个 IO 流（客户端连接）的效果。</li></ol><h4 id="Redis-单线程模式是怎样的？（难点）"><a href="#Redis-单线程模式是怎样的？（难点）" class="headerlink" title="Redis 单线程模式是怎样的？（难点）"></a>Redis 单线程模式是怎样的？（难点）</h4><p>Redis 6.0 版本之前的单线程模式如下图：<br><img src="https://pb01.s3.bitiful.net/168.webp" alt="avatar"></p><p>Redis 初始化的时候，会做下面这几件事情：</p><ul><li>首先，调用 epoll_create() 创建一个 epoll 对象和调用 socket() 创建一个服务端 socket</li><li>然后，调用 bind() 绑定服务端IP、端口和调用 listen() 服务端开始监听该端口；</li><li>然后，将调用 epoll_ctl() 将 listen socket 加入到 epoll，同时注册「连接事件」处理函数。</li></ul><p>初始化完后，主线程就进入到一个事件循环函数，主要会做以下事情：</p><ul><li>首先，先调用处理发送队列函数，看是发送队列里是否有任务，如果有发送任务，则通过 write 函数将客户端发送缓存区里的数据发送出去，如果这一轮数据没有发送完，就会注册写事件处理函数，等待 epoll_wait 发现可写后再处理 。</li><li><p>接着，调用 epoll_wait 函数等待事件的到来：</p><p>  ○如果是连接事件到来，则会调用连接事件处理函数，该函数会做这些事情：调用 accpet 获取已连接的 socket -&gt; 调用 epoll_ctl 将已连接的 socket 加入到 epoll -&gt; 注册「读事件」处理函数；</p><p>  ○如果是读事件到来，则会调用读事件处理函数，该函数会做这些事情：调用 read 获取客户端发送的数据 -&gt; 解析命令 -&gt; 处理命令 -&gt; 将客户端对象添加到发送队列 -&gt; 将执行结果写到发送缓存区等待发送；</p><p>  ○如果是写事件到来，则会调用写事件处理函数，该函数会做这些事情：通过 write 函数将客户端发送缓存区里的数据发送出去，如果这一轮数据没有发送完，就会继续注册写事件处理函数，等待 epoll_wait 发现可写后再处理 。</p></li></ul><h3 id="什么是I-O多路复用模型？"><a href="#什么是I-O多路复用模型？" class="headerlink" title="什么是I/O多路复用模型？"></a>什么是I/O多路复用模型？</h3><h4 id="基于TCP协议的Socket通信"><a href="#基于TCP协议的Socket通信" class="headerlink" title="基于TCP协议的Socket通信"></a>基于TCP协议的Socket通信</h4><p>客户端与服务端之间要进行通信，最基本的网络I/O模型就是通过socket进行TCP协议通信，流程如下：</p><ul><li>服务端调用socket()函数，创建一个监听请求的socket，</li><li>服务端调用bind()函数，在此监听socket上，绑定服务端的IP、应用程序的端口号</li><li>这是为了让服务端的内核能够收到客户端发来的请求数据，并且发送到相应的应用程序</li><li>服务端调用listen()函数，开始监听端口,客户端通过调用connect()函数，绑定服务端的IP、端口号，进行TCP三次握手.握手成功后，会将<strong>已完成连接的socket</strong>，放入服务端内核的TCP全连接队列中</li><li>服务端通过调用accept()函数，从内核获取已完成连接的socket进行通信,若TCP全连接队列中，无已完成连接的socket，那么就会阻塞等待客户端连接的到来</li></ul><p>基于TCP协议的socket通信，是<strong>同步阻塞</strong>的，当服务端还没处理完一个客户端的网络 I/O ，或者读写操作发生阻塞，其他客户端是无法与服务端连接的,即服务端只能与客户端进行一对一连接通信，一个服务端只能服务一个客户，很低效</p><h4 id="基于多进程模型改进网络I-O"><a href="#基于多进程模型改进网络I-O" class="headerlink" title="基于多进程模型改进网络I/O"></a>基于多进程模型改进网络I/O</h4><p>要想实现服务端同时服务多个客户端，最原始的方式就是用多进程，即为每一个客户端分配一个进程来处理请求。每当服务端与客户端完成连接，调用accept()函数返回一个已完成连接的socket，主进程就会通过fork()调用，产生一个子进程，与客户端进行通信</p><p>这样虽然解决了只能服务于一个客户端的问题，但是因为每产生一个进程，必会占据一定的系统资源，而且进程间上下文切换的代价很大，性能大打折扣。</p><h4 id="基于多线程模型改进网络I-O"><a href="#基于多线程模型改进网络I-O" class="headerlink" title="基于多线程模型改进网络I/O"></a>基于多线程模型改进网络I/O</h4><p>改进多进程代价高的缺点，使用多线程模型来服务于客户端<br>线程是运行在进程的执行流，所以可以共享进程的很多资源，对于一些私有数据，才需要进行线程上下文切换，减少了很多开销。<br>通过线程池，来避免频繁的创建线程，销毁线程。提高性能</p><p>但是还不够完美，因为本质上，客户端与服务端的通信，还是基于一对一的方式，只不过模型缩小为线程,能不能让一个进程同时与多个socket进行通信呢？</p><h4 id="引入I-O多路复用模型"><a href="#引入I-O多路复用模型" class="headerlink" title="引入I/O多路复用模型"></a>引入I/O多路复用模型</h4><p>一个进程，可以维护多个已完成连接的socket</p><p><code>进程怎么知道，哪个socket有事件请求呢？</code><br>内核提供了三个系统调用函数，select()/poll()/epoll()，用户态的进程通过调用这些函数，就可以得知，哪些socket有事件请求。</p><p><strong>select()/poll()</strong>:</p><p>本质都是在用户态线性存储socket文件描述符集合，当调用函数select()/poll()时，会将存储的集合拷贝到内核，内核通过遍历判断，哪些socket有事件请求，具体分为读/写事件，进行相应的标记。</p><p>内核标记完成后，将集合拷贝回用户态，用户态通过遍历的方式，查看哪些文件描述符被标记，进而得知哪些socket有事件请求，具体分为读/写事件，进行相应的处理。</p><p>缺点：<br>对于 select()/poll() 方式，需要进行 2 次「遍历」文件描述符集合，一次是在内核态里，一次是在用户态里，还会发生 2 次「拷贝」文件描述符集合，先从用户空间传入内核空间，由内核标记后，再传出到用户空间中。</p><p>显而易见，随着并发数量提示，拷贝 &amp; 遍历 产生的性能消耗，将会非常大。</p><p><strong>epoll()</strong>:<br>epoll()函数，不同于以上两个系统调用函数的地方在于: 在内核中会用红黑树结构，保存进程维护的socket文件描述符集合，即将已完成连接的socket，通过epoll_ctl() 函数加入内核中的红黑树里, 红黑树进行查找、添加、删除的时间复杂度都为log(N)，性能好</p><p>并且在内核中，会维护一个有事件发生的socket链表，用户态进程通过epoll_wait()函数，即可得到有事件发生的socket,节省了用户态与内核态进行遍历的过程，提升性能</p><p>采用 epoll 模型进行网络I/O，被称为解决 <strong>C10K</strong> 问题的利器：<br>支持一个进程打开大数目的socket描述符(FD),它所支持的FD上限是最大可以打开文件的数目</p><p>IO效率不随FD数目增加而线性下降, select/poll每次调用都会线性轮询扫描全部的fd集合，导致效率呈现线性下降。epoll不存在这个问题，它只会对<code>活跃</code>的socket进行操作，这是因为在内核实现中epoll是根据每个fd上面的回调函数实现的</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
            <tag> OS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis持久化(AOF|RDB)</title>
      <link href="/2024/04/12/2024-4-12-redis%E6%8C%81%E4%B9%85%E5%8C%96/"/>
      <url>/2024/04/12/2024-4-12-redis%E6%8C%81%E4%B9%85%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h2 id="Redis持久化-AOF-RDB"><a href="#Redis持久化-AOF-RDB" class="headerlink" title="Redis持久化(AOF|RDB)"></a>Redis持久化(AOF|RDB)</h2><h3 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h3><h4 id="AOF是什么"><a href="#AOF是什么" class="headerlink" title="AOF是什么?"></a>AOF是什么?</h4><p>AOF全称是append only file, 即只追加文件。</p><p>AOF持久化是通过保存Redis服务器执行的写命令来记录数据库状态的。</p><p>AOF默认是不开启的,,需要在redis.conf文件中配置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">appendonly yes</span><br><span class="line">appendfilename &quot;appendonly.aof&quot;</span><br></pre></td></tr></table></figure><p>AOF持久化配置项说明：</p><ul><li>appendonly：是否开启AOF持久化</li><li>appendfilename：持久化文件名</li></ul><p>redis处理写命令的时,会采取先写内存数据,再记录AOF日志的方式,这样做有两个好处:</p><ul><li>减少额外检查开销: 只有内存数据被修改成功后才会写AOF日志,保证了日志都是可执行且正确的</li><li>不会阻塞当前的写操作</li></ul><p><strong>风险</strong></p><p>如果命令执行完成，写日志之前宕机了，会丢失数据。</p><p>可能会阻塞下一条写命令的执行: 写操作和记录日志都是主进程(主进程中的redis_aof_write_thread线程),如果在刷盘时,服务器I/O压力过大,导致写硬盘速度很慢,就会阻塞后续的写命令</p><h4 id="写AOF日志的过程"><a href="#写AOF日志的过程" class="headerlink" title="写AOF日志的过程"></a>写AOF日志的过程</h4><p>redis在执行完一个写命令之后，会以协议格式将被执行的写命令追加到日志缓存server.aof_buf中,接下来通过系统调用write(),将日志缓存server.aof_buf中的内容写入到AOF文件中。</p><p>有三种写回策略,需要通过设置redis.conf文件中appendfsync参数来配置：</p><p>AOF持久化配置项说明：</p><ul><li>appendfsync：持久化策略<ul><li>always：每个写命令执行完，立马同步地将日志写回磁盘，数据安全性最高，但性能最差</li><li>everysec：每个写命令执行完，只是先把日志写到AOF文件的内存缓冲区，<code>redis的后台异步线程</code>每隔一秒把缓冲区中的内容写入磁盘</li><li>no：每个写命令执行完，只是先把日志写到AOF文件的内存缓冲区，由<code>操作系统</code>决定何时将缓冲区内容写回磁盘</li></ul></li></ul><h4 id="AOF重写"><a href="#AOF重写" class="headerlink" title="AOF重写"></a>AOF重写</h4><p>AOF重写是指对AOF文件进行压缩，只保留可以恢复数据的最小命令集合,可以有效减小AOF文件的体积，以提升数据恢复的性能。</p><p>重写触发的条件:</p><ul><li><code>auto-aof-rewrite-min-size</code>:表示运行AOF重写时文件的最小大小，默认为64MB。</li><li><code>auto-aof-rewrite-percentage</code>:这个值的计算方式是，当前aof文件大小和上一次重写后aof文件大小的差值，再除以上一次重写后aof文件大小。也就是当前aof文件比上一次重写后aof文件的增量大小，和上一次重写后aof文件大小的比值。</li></ul><p><strong>流程</strong>:读取当前数据库中的所有键值对，然后将每一个键值对用一条命令记录到<code>新的 AOF 文件</code>，等到全部记录完后，就将新的 AOF 文件替换掉现有的 AOF 文件</p><p><strong>为什么要新建一个AOF文件?</strong><br>如果在原先的AOF文件进行重写,如果重写失败,就会出现数据不一致,导致污染,可能无法用于恢复</p><p><code>为什么是后台子进程而不用子线程?</code><br>子线程会共享内存,主进程要写,子线程要读,要加锁防止读写并发操作,性能差</p><p><strong>采用子进程，写时复制提高性能:</strong><br>采用子进程，主进程会为子进程分配与主进程相同的页表，即虚拟空间映射到相同的物理空间，达到数据共享，并且不需要加锁操作.但会对这块共享的物理内存设置为只读状态,如果主进程 或 子进程 对这块内存发生写操作，会触发写时复制.CPU 触发写保护中断，这个写保护中断是由于违反权限导致的，然后操作系统会在「写保护中断处理函数」里进行物理内存的复制，并重新设置其内存映射关系，将父子进程的内存读写权限设置为可读写，最后才会对内存进行写操作,这样就避免了加锁操作，通过写时复制，来提高性能.(简单来说就是如果主进程在子进程进行AOF重写时,没有执行写入操作,就不会真正分配内存资源,就是写时复制技术COW的应用)</p><h4 id="AOF后台重写机制描述"><a href="#AOF后台重写机制描述" class="headerlink" title="AOF后台重写机制描述"></a>AOF后台重写机制描述</h4><p>进行AOF日志后台重写时，主进程fork子进程，并且为子进程分配与主进程相同的页表，即虚拟空间映射到相同的物理空间，达到数据共享，并且通过写时复制，来避免加锁</p><p>子进程收集内存中的键值对转化为一条命令，写入新的AOF文件，但在写入过程，主进程仍然可以处理命令，当碰到写操作命令时，会发生以下操作：<br>触发写时复制过程，CPU 触发写保护中断，这个写保护中断是由于违反权限导致的，然后操作系统会在「写保护中断处理函数」里进行物理内存的复制，并重新设置其内存映射关系，将父子进程的内存读写权限设置为可读写，最后主进程才会对内存进行写操作</p><p><code>但子进程收集的AOF文件 数据就不一致了，如何解决？</code></p><p>redis 在AOF后台重写触发时，会分配一个AOF重写缓冲区,重写过程，主进程执行更新内存数据时，需要执行以下几件事情：</p><ol><li>执行命令，更新内存数据</li><li>将命令记录到两个位置:旧的AOF文件和AOF重写缓冲区</li><li>当子进程 AOF重写完毕，会发送一个信号告诉主进程，主进程调用信号处理函数会做以下事情：将AOF重写缓冲区的数据直接追加到新的 AOF文件末尾，替换旧的AOF文件，重写过程就结束。信号处理函数执行完毕，主进程就可以继续处理命令了</li></ol><p><code>后台重写，什么阶段会阻塞主进程？</code></p><ol><li>创建子进程的途中,由于要复制父进程的页表等数据结构: 阻塞的时间跟页表的大小有关,页表越大,阻塞的时间也越长</li><li>创建完子进程后,如果父进程修改了共享数据（子进程一般只读）,就会发生写时复制,这期间会拷贝物理内存,如果内存越大,自然阻塞的时间也越长</li><li>子进程 AOF重写完毕,发送信号通知主进程,主进程会调用信号处理函数,执行时也会对主进程造成阻塞</li></ol><p><code>什么优化，让主进程阻塞时间尽量缩小？</code><br><strong>写时复制</strong>，在发生写操作的时候，操作系统才会去复制物理内存，这样是为了防止 fork 创建子进程时，由于物理内存数据的复制时间过长而导致主进程长时间阻塞的问题。当冲突发生，再进行解决，来提高效率。也可以减少内存分配。</p><h3 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h3><h4 id="RDB快照是什么-如何生成"><a href="#RDB快照是什么-如何生成" class="headerlink" title="RDB快照是什么?如何生成?"></a>RDB快照是什么?如何生成?</h4><p>RDB 快照记录的是内存中的实际数据，二进制格式；所以在redis重启恢复数据时，只需要加载rdb文件到内存即可，速度较快</p><p>redis提供了两个命令来主动生成rdb文件<br>●save：主进程来执行全量快照操作，若内存数据太多，会阻塞主进程，不推荐<br>●bgsave：主进程fork 子进程，来执行全量快照操作，这种思想在AOF后台重写日志也用过，避免主线程的阻塞</p><p>还可以通过配置参数，来生成快照<br>默认配置：执行的是 bgsave 命令，也就是会创建子进程来生成 RDB 快照文件。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">save 900 1</span><br><span class="line">save 300 10</span><br><span class="line">save 60 10000</span><br></pre></td></tr></table></figure><br>只要满足上面条件的任意一个，就会执行 bgsave，它们的意思分别是：<br>900 秒之内，对数据库进行了至少 1 次修改；<br>300 秒之内，对数据库进行了至少 10 次修改；<br>60 秒之内，对数据库进行了至少 10000 次修改。</p><h4 id="执行RDB快照过程是怎样的？执行快照时，数据能被修改吗？"><a href="#执行RDB快照过程是怎样的？执行快照时，数据能被修改吗？" class="headerlink" title="执行RDB快照过程是怎样的？执行快照时，数据能被修改吗？"></a>执行RDB快照过程是怎样的？执行快照时，数据能被修改吗？</h4><p>Redis 同样采用<code>写时复制</code>技术，来支持快照，执行快照时数据能被修改，具体过程：</p><p>主进程fork创建一个子进程，来执行bgsave命令,主进程会将自己的页表复制一份给子进程，虚拟空间指向相同的物理空间，来达到空间共享.子进程在记录实际数据到RDB文件过程中，若主进程没有执行写操作命令，那么共享空间就不会发生冲突，也不会发生写时复制。</p><p>若主进程需要执行写操作命令，如主线程（父进程）要修改共享数据里的某一块数据（比如键值对 A）时，就会发生写时复制，这块数据的物理内存就会被复制一份（键值对 A’），然后主线程在这个数据副本（键值对 A’）进行修改操作。与此同时，bgsave 子进程可以继续把原来的数据（键值对 A）写入到 RDB 文件。</p><p>bgsave 快照过程中，<strong>如果主线程修改了共享数据，发生了写时复制后，本次RDB 快照保存的是原本的内存数据，而主线程刚修改的数据，是没办法在这一时间写入 RDB 文件的，只能交由下一次的 bgsave 快照</strong></p><p><code>怎么将RDB文件加载到内存？</code></p><p>RDB 文件的加载工作是在redis服务器启动时自动执行的，Redis 并没有提供专门用于加载 RDB 文件的命令。</p><p><strong>RDB 快照的缺点</strong><br>每一次执行RDB快照，记录的是内存中的所有数据，相当于一个全量快照，当数据较多时，频繁记录快照，虽然可以采用子进程来执行，但还是会影响redis的性能,如果记录的太不频繁，那么当服务器宕机，丢失的数据就非常多</p><h4 id="写时复制有什么极端场景？"><a href="#写时复制有什么极端场景？" class="headerlink" title="写时复制有什么极端场景？"></a>写时复制有什么极端场景？</h4><p>在 Redis 执行 RDB 持久化期间，刚 fork 时，主进程和子进程共享同一物理内存，但是途中主进程处理了写操作，修改了共享内存，于是当前被修改的数据的物理内存就会被复制一份。那么极端情况下，如果所有的共享内存都被修改，则此时的内存占用是原先的 2 倍。所以，针对写操作多的场景，我们要留意下快照过程中内存的变化，防止内存被占满了。</p><h4 id="AOF日志-amp-RDB快照-区别"><a href="#AOF日志-amp-RDB快照-区别" class="headerlink" title="AOF日志 &amp; RDB快照 区别"></a>AOF日志 &amp; RDB快照 区别</h4><p>它们都是redis数据库内存持久化的技术</p><ol><li>记录的内容不同：AOF 文件的内容是操作命令；RDB 文件的内容是二进制数据。</li><li>恢复数据时，耗费的时间不同：RDB 恢复数据的效率会比 AOF 高些，因为直接将 RDB 文件读入内存就可以，AOF 需要额外执行操作命令的步骤才能恢复数据，速度慢</li><li>在服务器发生故障时，丢失数据多少方面：RDB是一个全量快照，不能频繁执行，否则会影响性能,所以丢失数据相对来说较多.AOF支持秒级记录命令到AOF文件中,所以丢失的数据相对来说较少</li></ol><h3 id="AOF-RDB混合持久化"><a href="#AOF-RDB混合持久化" class="headerlink" title="AOF|RDB混合持久化"></a>AOF|RDB混合持久化</h3><h4 id="AOF-RDB进行混合持久化有什么优点？"><a href="#AOF-RDB进行混合持久化有什么优点？" class="headerlink" title="AOF|RDB进行混合持久化有什么优点？"></a>AOF|RDB进行混合持久化有什么优点？</h4><p><code>混合持久化可以利用这两种日志的优点：</code>AOF可以支持秒级记录日志，使得数据更少的丢失,RDB在数据恢复时非常快，不需要重新执行命令</p><p><code>混合持久化的过程只发生在AOF日志重写的过程</code>，如下：</p><ol><li>当AOF日志达到阈值时，触发后台重写机制,主进程fork创建子进程，并且将主进程的页表复制一份给子进程</li><li>子进程与主进程共享空间，对当前内存数据执行RDB快照，将RDB格式的日志记录到新的AOF文件中</li><li>并且在重写过程，主线程处理的写操作命令会被记录在AOF重写缓冲区里，当RDB快照记录完毕，AOF重写缓冲区里的增量命令会以 AOF 方式写入到 AOF 文件</li><li>写入完成后通知主进程,将新的含有 RDB 格式和 AOF 格式的 AOF 文件替换旧的的 AOF 文件。</li></ol><p>使用了混合持久化，AOF 文件的前半部分是 RDB 格式的全量数据，后半部分是 AOF 格式的增量数据。</p><p><strong>好处</strong>：<br>重启Redis加载数据的时候，由于前半部分是RDB内容，这样加载的时候速度会很快。加载完 RDB 的内容后，才会加载后半部分的 AOF 内容，这里的内容是 Redis 后台子进程重写 AOF 期间，主线程处理的操作命令，可以使得数据更少的丢失。</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IELTS备考经验(个人向)</title>
      <link href="/2024/04/10/2024-04-10/"/>
      <url>/2024/04/10/2024-04-10/</url>
      
        <content type="html"><![CDATA[<h3 id="IELTS备考经验-个人向"><a href="#IELTS备考经验-个人向" class="headerlink" title="IELTS备考经验(个人向)"></a>IELTS备考经验(个人向)</h3><p>首考6.5(6), 虽然没考到小分6.5, 我也接受了, 过段时间再考吧.</p><h4 id="机考or纸笔"><a href="#机考or纸笔" class="headerlink" title="机考or纸笔"></a>机考or纸笔</h4><p>雅思有机考也有传统的纸笔考试形式, 个人更推荐机考, 原因如下:</p><ol><li>机考口语和笔试一般都在同一天, 而纸笔的口语和笔试一般不在同一天, 有时候可能会差一个星期, 如果考点离你住的地方比较远的话, 非常不方便, 像我这种学校在郊区的, 果断选择机考</li><li>机考的考位多, 考试时间灵活, 纸笔一般一个星期只有两场, 而机考几乎每天都有两场</li><li>机考对于那些写字不好看的人来说很友好, 而且打字比较快, 还有时间去检查和调整</li><li>机考对于阅读也比较友好, 不用翻来翻去的</li></ol><p>当然机考也有一些<strong>缺点</strong>: 听力时间会更短, 对于我来说就是读题时间会减少, 而且我考的那场感觉耳机很烂, 漏音比较严重, 如果是比较容易受环境影响的同学, 可能会比较吃亏, 我考出来就比平时自己限时练低了0.5分</p><p>总的来说, 对于时间比较充裕, 写字比较好看的同学(或者打字特别慢), 我还是挺建议纸笔的, 其他同学我都建议去考机考</p><h4 id="关于难度"><a href="#关于难度" class="headerlink" title="关于难度"></a>关于难度</h4><p>可以看到, 网上有很多人在散播焦虑, 说什么正式考试比剑桥雅思难多了, 其实个人体感下来是差不多的, 因为平时剑雅也有难度波动, 不能拿正式考试和平时最简单的卷子进行比较. 当然, 机考的抽题比较随机, 所以难度波动会更大, 不过总体来说, 机考的难度和剑雅是差不多的.</p><h4 id="平时练习"><a href="#平时练习" class="headerlink" title="平时练习"></a>平时练习</h4><p>我在同桌英语这个平台进行练习, 几乎和真实机考是没太大区别的(90+%的相似度吧), 要了解自己的考场是否采用新机考, 切换到对应的模式, 现在应该是全国的考场都换新机考系统了</p><h4 id="听力"><a href="#听力" class="headerlink" title="听力"></a>听力</h4><p>听力感觉我没什么可分享的经验, 就是先熟悉题型, 熟悉完题型后再做题几乎就是能评估出自己的真实水平了, 根据自己薄弱的题型再去刻意地刷, 像我的匹配和多选题就比较烂, 我就会多刷一些, 个人觉得平时练习比自己目标分高0.5就基本稳了</p><h4 id="阅读"><a href="#阅读" class="headerlink" title="阅读"></a>阅读</h4><p>阅读的话我其实没怎么刷, 做了几套基本稳7.5之后我就不刷了, 也没什么技巧, 先看题目, 再看文章, 要将文章的大意和结构搞明白就可以, 然后去定位, 特别是第一篇, 太简单了, 千万不要精读, 10-15分钟解决, 第二篇15-20分钟解决, 留下充足时间给最后一篇, 个人觉得最好留够30分钟, 不然真有可能来不及</p><h4 id="作文"><a href="#作文" class="headerlink" title="作文"></a>作文</h4><p>小作文的话我看了(粗读)simon的<code>跟雅思考官simon学写作</code>, 值得看的就是每种题型的描述重点, 文章结构就是四段体, 第一段改写题目, 第二段写总体, 第三四段将图表分为两个部分分析, 可以是按时间, 趋势, 品类等分. 我还看了b站上丸子tina的两个小作文的视频, 我觉得写得还是很好的, 剩下的就是自己总结一下自己喜欢的描述语句.</p><p>大作文的话,先要把大作文的结构搞清楚, 我用的是b站上vincce的五段结构, 第一段根据题目引出议题并阐明观点, 第二三段每段一个论点,然后解释,最后论证,多用举例和条件语句,连接词要丰富. 第四段部分肯定对立观点,然后论证肯定自己的观点. 第五段就是常规总结. 然后多看文章, 积累一些素材, 也可以偶尔训练一两篇.</p><p>可以去看vince他们的公众号,里面文章的素材还是很不错的, 另外推荐一个网站 <a href="https://www.ieltsessaybank.com/" style="color: #177cb0; text-decoration: underline;text-decoration-style: dotted;">ieltsessaybank</a>,这是油管上一个博主的网站, 虽然感觉部分观点的论证和中国人有很大区别, 但是素材还是不错的, 比较符合西方思维. </p><h4 id="口语"><a href="#口语" class="headerlink" title="口语"></a>口语</h4><p>个人的口语虽然准备了,但还是准备的不太充分,考场上的状态几乎就是裸考, 准备的一个没考到, 推荐过一遍题库思考一下怎么回答即可, 回答思路可以看一下up主Ethan英格利什, 还有就是up主刘黑眼圈子, 她真的带给了我一些启发, 虽然我临场想不出来这样的回答, 但如果按这个思路备考感觉是能出分的.雅思考试考的就是你能不能像人一样交流, 而不是你能不能背下来, 很多备考的内容会让人觉得这不是在正常交流中会说出来的, 说简单的话, 说人话(对于一般人来说, 思想高深, 语言能力强的人另说).</p>]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IELTS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>现代密码学基础技能</title>
      <link href="/2024/04/09/2024-4-9-%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8%E4%B8%8E%E9%9A%90%E7%A7%811/"/>
      <url>/2024/04/09/2024-4-9-%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8%E4%B8%8E%E9%9A%90%E7%A7%811/</url>
      
        <content type="html"><![CDATA[<h3 id="现代密码学基础技能"><a href="#现代密码学基础技能" class="headerlink" title="现代密码学基础技能"></a>现代密码学基础技能</h3><p>大数据安全与隐私这门课的lab1,要求如下图:</p><p><img src="https://pb01.s3.bitiful.net/164.webp" alt="avatar"></p><p>采用的方案是RSA和AES相结合, 利用RSA来加密传输AES的密钥, 用AES的密钥来加密数据. 如果使用RSA加密数据, 虽然安全性会更高, 但效率低. AES加解密效率高, 但安全性会差一些, 所以采用RSA加密AES的密钥, 然后用AES加密数据, 这样既保证了效率也保证了安全性.</p><p>为了保证相同文件每次发送的加密文件不同, 将随机生成的秘钥与当前时间戳结合为随机AES秘钥. 注释写得很详细了, 有些细节的东西我就不解释了.</p><p>运行结果如下:<br><img src="https://pb01.s3.bitiful.net/165.png" alt="avatar"></p><p><img src="https://pb01.s3.bitiful.net/166.png" alt="avatar"></p><h4 id="服务端代码"><a href="#服务端代码" class="headerlink" title="服务端代码"></a>服务端代码</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> struct</span><br><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> AES</span><br><span class="line"><span class="keyword">import</span> rsa</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">iv = <span class="string">&#x27;1425374853627180&#x27;</span>  <span class="comment"># 初始向量</span></span><br><span class="line">BUFF = <span class="number">1024</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 去除末尾填充字符</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">unpadding</span>(<span class="params">text</span>):</span><br><span class="line">    length = <span class="built_in">len</span>(text)</span><br><span class="line">    <span class="built_in">print</span>(text[length - <span class="number">1</span>])</span><br><span class="line">    <span class="keyword">return</span> text[<span class="number">0</span>:length - text[length - <span class="number">1</span>]]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">socket_service</span>():</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">        <span class="comment">#  设置socket可以重用已绑定地址</span></span><br><span class="line">        s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, <span class="number">1</span>)</span><br><span class="line">        s.bind((<span class="string">&#x27;localhost&#x27;</span>, <span class="number">9001</span>))  <span class="comment"># 绑定端口为9001</span></span><br><span class="line">        s.listen(<span class="number">10</span>)  <span class="comment"># 设置监听数,最多允许10个客户端连接</span></span><br><span class="line">    <span class="keyword">except</span> socket.error <span class="keyword">as</span> msg:</span><br><span class="line">        <span class="built_in">print</span>(msg)</span><br><span class="line">        sys.exit(<span class="number">1</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;等待连接...&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">        <span class="comment"># 调用accept阻塞： 等待请求并接受(程序会停留在这一旦收到连接请求即开启接受数据的线程)</span></span><br><span class="line">        conn, addr = s.accept()</span><br><span class="line">        <span class="comment"># 接收数据</span></span><br><span class="line">        t = threading.Thread(target=deal_data, args=(conn, addr))</span><br><span class="line">        t.start()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">deal_data</span>(<span class="params">conn, addr</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;接收到来自 &#123;0&#125;的连接&#x27;</span>.<span class="built_in">format</span>(addr))</span><br><span class="line">    <span class="comment"># 收到请求后的回复</span></span><br><span class="line">    conn.send(<span class="string">&#x27;welcome!&#x27;</span>.encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line"></span><br><span class="line">    key = <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> key:</span><br><span class="line">            s1_recv_data = conn.recv(BUFF)</span><br><span class="line">            <span class="keyword">if</span> s1_recv_data.decode(<span class="string">&#x27;utf-8&#x27;</span>) == <span class="string">&#x27;changekey&#x27;</span>:</span><br><span class="line">                <span class="built_in">print</span>(time.strftime(<span class="string">&#x27;%Y-%m-%d %H:%M:%S&#x27;</span>, time.localtime(time.time())) + <span class="string">&#x27; 开始交换秘钥!&#x27;</span>)</span><br><span class="line">                <span class="comment"># 使用RSA产生一对公钥和私钥</span></span><br><span class="line">                (pubkey, privkey) = rsa.newkeys(<span class="number">512</span>, poolsize=<span class="number">8</span>)</span><br><span class="line">                <span class="built_in">print</span>(time.strftime(<span class="string">&#x27;%Y-%m-%d %H:%M:%S&#x27;</span>, time.localtime(time.time())) + <span class="string">&#x27; 创建RSA秘钥对!&#x27;</span>)</span><br><span class="line">                <span class="comment"># 将公钥模数和指数发送给客户端</span></span><br><span class="line">                modulus = pubkey.n</span><br><span class="line">                exponent = pubkey.e</span><br><span class="line">                conn.send(<span class="built_in">str</span>(modulus).encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">                conn.send(<span class="built_in">str</span>(exponent).encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line"></span><br><span class="line">                <span class="built_in">print</span>(time.strftime(<span class="string">&#x27;%Y-%m-%d %H:%M:%S&#x27;</span>, time.localtime(time.time())) + <span class="string">&#x27; 发送RSA公钥&#x27;</span>)</span><br><span class="line">                <span class="comment"># 服务端收到消息</span></span><br><span class="line">                key = conn.recv(BUFF)</span><br><span class="line">                <span class="built_in">print</span>(time.strftime(<span class="string">&#x27;%Y-%m-%d %H:%M:%S&#x27;</span>,</span><br><span class="line">                                    time.localtime(time.time())) + <span class="string">&#x27; 接收加密后的AES秘钥:&#x27;</span> + key.decode(<span class="string">&#x27;utf8&#x27;</span>,</span><br><span class="line">                                                                                                           <span class="string">&#x27;ignore&#x27;</span>))</span><br><span class="line">                <span class="comment"># 服务端用私钥进行解密，得到AES密钥</span></span><br><span class="line">                key = rsa.decrypt(key, privkey)</span><br><span class="line">                <span class="built_in">print</span>(time.strftime(<span class="string">&#x27;%Y-%m-%d %H:%M:%S&#x27;</span>, time.localtime(time.time())) + <span class="string">&#x27; 解密AES秘钥中&#x27;</span>)</span><br><span class="line">                key = key.decode()</span><br><span class="line">                <span class="built_in">print</span>(time.strftime(<span class="string">&#x27;%Y-%m-%d %H:%M:%S&#x27;</span>, time.localtime(time.time())) + <span class="string">&#x27; AES秘钥:&#x27;</span> + key)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 申请相同大小的空间存放发送过来的文件名与文件大小信息</span></span><br><span class="line">        fileinfo_size = struct.calcsize(<span class="string">&#x27;128sl&#x27;</span>)</span><br><span class="line">        <span class="comment"># 接收文件名与文件大小信息</span></span><br><span class="line">        buf = conn.recv(fileinfo_size)</span><br><span class="line">        <span class="comment"># 判断是否接收到文件头信息</span></span><br><span class="line">        <span class="keyword">if</span> buf:</span><br><span class="line">            <span class="comment"># 获取文件名和文件大小</span></span><br><span class="line">            filename, filesize = struct.unpack(<span class="string">&#x27;128sl&#x27;</span>, buf)</span><br><span class="line">            fn = filename.strip(<span class="string">b&#x27;\00&#x27;</span>)</span><br><span class="line">            fn = fn.decode()</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;文件名是 &#123;0&#125;, 文件大小是 &#123;1&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="built_in">str</span>(fn), filesize))</span><br><span class="line">            recvd_size = <span class="number">0</span>  <span class="comment"># 定义已接收文件的大小</span></span><br><span class="line">            <span class="comment"># 存储在该脚本所在目录下面</span></span><br><span class="line">            fp = <span class="built_in">open</span>(<span class="string">&#x27;./&#x27;</span> + <span class="built_in">str</span>(fn), <span class="string">&#x27;wb&#x27;</span>)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;开始接收...&#x27;</span>)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> filesize % <span class="number">16</span> == <span class="number">0</span>:</span><br><span class="line">                filesize += <span class="number">16</span> - filesize % <span class="number">16</span></span><br><span class="line">            <span class="comment"># 将分批次传输的二进制流依次写入到文件</span></span><br><span class="line">            <span class="keyword">while</span> <span class="keyword">not</span> recvd_size == filesize:</span><br><span class="line">                <span class="keyword">if</span> filesize - recvd_size &gt; <span class="number">1024</span>:</span><br><span class="line">                    data = conn.recv(<span class="number">1024</span>)</span><br><span class="line">                    recvd_size += <span class="built_in">len</span>(data)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    data = conn.recv(filesize - recvd_size)</span><br><span class="line">                    recvd_size = filesize</span><br><span class="line"></span><br><span class="line">                <span class="built_in">print</span>(<span class="built_in">len</span>(data))</span><br><span class="line">                <span class="built_in">print</span>(data)</span><br><span class="line"></span><br><span class="line">                <span class="comment"># 将加密数据转换位bytes类型数据</span></span><br><span class="line">                cipher = AES.new(key.encode(<span class="string">&#x27;utf8&#x27;</span>), AES.MODE_CBC, iv.encode(<span class="string">&#x27;utf8&#x27;</span>))</span><br><span class="line">                text_decrypted = cipher.decrypt(data)</span><br><span class="line">                <span class="built_in">print</span>(<span class="built_in">len</span>(text_decrypted))</span><br><span class="line">                <span class="built_in">print</span>(text_decrypted)</span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">len</span>(text_decrypted) &lt; <span class="number">1024</span>:</span><br><span class="line">                    text_decrypted = unpadding(text_decrypted)</span><br><span class="line">                <span class="built_in">print</span>(text_decrypted)</span><br><span class="line">                fp.write(text_decrypted)</span><br><span class="line">            fp.close()</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;结束接收...&#x27;</span>)</span><br><span class="line">        <span class="comment"># 传输结束断开连接</span></span><br><span class="line">        conn.close()</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    socket_service()</span><br></pre></td></tr></table></figure><h4 id="客户端代码"><a href="#客户端代码" class="headerlink" title="客户端代码"></a>客户端代码</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> struct</span><br><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> AES</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> rsa</span><br><span class="line"></span><br><span class="line">key0 = os.urandom(<span class="number">16</span>).<span class="built_in">hex</span>()  <span class="comment"># 随机生成秘钥,16位字符串</span></span><br><span class="line">iv = <span class="string">&#x27;1425374853627180&#x27;</span>  <span class="comment"># 初始向量</span></span><br><span class="line">BUFF = <span class="number">1024</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">padding</span>(<span class="params">text</span>):</span><br><span class="line">    bs = AES.block_size  <span class="comment"># 16字节</span></span><br><span class="line">    length = <span class="built_in">len</span>(text)   <span class="comment"># 获取明文长度,字符</span></span><br><span class="line">    bytes_length = <span class="built_in">len</span>(<span class="built_in">bytes</span>(text, encoding=<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">    padding = length <span class="keyword">if</span> (bytes_length == length) <span class="keyword">else</span> bytes_length</span><br><span class="line">    padding_size = bs - padding % bs</span><br><span class="line">    padding_text = <span class="built_in">chr</span>(padding_size) * padding_size   <span class="comment"># 按照PKCS7填充方式生成填充文本</span></span><br><span class="line">    <span class="keyword">return</span> text + padding_text</span><br><span class="line"></span><br><span class="line"><span class="comment"># 函数功能：对明文进行PKCS7填充</span></span><br><span class="line"><span class="comment"># 参数text：需要填充的明文</span></span><br><span class="line"><span class="comment"># 返回值：填充后的明文</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">socket_client</span>():</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="comment"># 创建socket,ipv4+流</span></span><br><span class="line">        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">        s.connect((<span class="string">&#x27;localhost&#x27;</span>, <span class="number">9001</span>))</span><br><span class="line">    <span class="keyword">except</span> socket.error <span class="keyword">as</span> msg:</span><br><span class="line">        <span class="built_in">print</span>(msg)</span><br><span class="line">        sys.exit(<span class="number">1</span>)</span><br><span class="line">    <span class="built_in">print</span>(s.recv(<span class="number">1024</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 加上给密钥加上时间戳，保证相同的明文，每次发送的密文不同</span></span><br><span class="line">    t = time.time()</span><br><span class="line">    t_str = <span class="built_in">str</span>(<span class="built_in">int</span>(t))</span><br><span class="line">    key = key0[<span class="number">0</span>:<span class="number">8</span>] + t_str[<span class="number">2</span>:<span class="number">10</span>]  <span class="comment"># 取key0前八位和时间戳中的后八位生成新key</span></span><br><span class="line">    <span class="built_in">print</span>(time.strftime(<span class="string">&#x27;%Y-%m-%d %H:%M:%S&#x27;</span>, time.localtime(time.time())) + <span class="string">&#x27; 开始交换秘钥!&#x27;</span>)</span><br><span class="line">    s.send(<span class="string">&#x27;changekey&#x27;</span>.encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">    modulus = <span class="built_in">int</span>(s.recv(BUFF).decode(<span class="string">&#x27;utf-8&#x27;</span>))  <span class="comment"># 接收公钥模数</span></span><br><span class="line">    exponent = <span class="built_in">int</span>(s.recv(BUFF).decode(<span class="string">&#x27;utf-8&#x27;</span>))  <span class="comment"># 接收公钥指数</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(time.strftime(<span class="string">&#x27;%Y-%m-%d %H:%M:%S&#x27;</span>, time.localtime(time.time())) + <span class="string">&#x27; 开始构建RSA公钥&#x27;</span>)</span><br><span class="line">    pubkey = rsa.PublicKey(modulus, exponent)  <span class="comment"># 构建公钥</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(time.strftime(<span class="string">&#x27;%Y-%m-%d %H:%M:%S&#x27;</span>, time.localtime(time.time())) + <span class="string">&#x27; 加密AES秘钥&#x27;</span>)</span><br><span class="line">    crypto = rsa.encrypt(key.encode(<span class="string">&#x27;utf-8&#x27;</span>), pubkey)  <span class="comment"># 用RSA公钥对AES密钥进行加密</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(time.strftime(<span class="string">&#x27;%Y-%m-%d %H:%M:%S&#x27;</span>, time.localtime(time.time())) + <span class="string">&#x27; 发送加密后的AES秘钥:&#x27;</span> + crypto.decode(</span><br><span class="line">        <span class="string">&#x27;utf8&#x27;</span>, <span class="string">&#x27;ignore&#x27;</span>))</span><br><span class="line">    s.send(crypto)  <span class="comment"># 发送加密后的AES密钥</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 需要传输的文件路径</span></span><br><span class="line">    filepath = <span class="string">&#x27;C:/XingYan/1.png&#x27;</span></span><br><span class="line">    <span class="comment"># 判断是否为文件</span></span><br><span class="line">    <span class="keyword">if</span> os.path.isfile(filepath):</span><br><span class="line">        <span class="comment"># 定义定义文件信息。128s表示文件名为128bytes长，l表示一个int或long，在此为文件大小</span></span><br><span class="line">        fileinfo_size = struct.calcsize(<span class="string">&#x27;128sl&#x27;</span>)</span><br><span class="line">        <span class="comment"># 打包文件名和大小</span></span><br><span class="line">        filehead = struct.pack(<span class="string">&#x27;128sl&#x27;</span>, os.path.basename(filepath).encode(<span class="string">&#x27;utf-8&#x27;</span>), os.stat(filepath).st_size)</span><br><span class="line">        s.send(filehead)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 将传输文件以二进制的形式分多次上传至服务器</span></span><br><span class="line">        fp = <span class="built_in">open</span>(filepath, <span class="string">&#x27;rb&#x27;</span>)</span><br><span class="line">        <span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">            data = fp.read(<span class="number">1024</span>)</span><br><span class="line">            <span class="built_in">print</span>(data)</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> data:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&#x27;&#123;0&#125; 发送结束...&#x27;</span>.<span class="built_in">format</span>(os.path.basename(filepath)))</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(data) &lt; <span class="number">1024</span>:</span><br><span class="line">                newdata = data.decode(<span class="string">&#x27;utf8&#x27;</span>, <span class="string">&#x27;ignore&#x27;</span>)</span><br><span class="line">                <span class="built_in">print</span>(<span class="built_in">len</span>(newdata))</span><br><span class="line">                newdata = padding(newdata)</span><br><span class="line">                <span class="built_in">print</span>(<span class="built_in">len</span>(newdata))</span><br><span class="line">                data = newdata.encode(<span class="string">&#x27;utf8&#x27;</span>)</span><br><span class="line">            cipher = AES.new(key.encode(<span class="string">&#x27;utf8&#x27;</span>), AES.MODE_CBC, iv.encode(<span class="string">&#x27;utf8&#x27;</span>))  <span class="comment"># AES加密对象</span></span><br><span class="line">            encryptedbytes = cipher.encrypt(data)</span><br><span class="line">            s.send(encryptedbytes)</span><br><span class="line">            <span class="built_in">print</span>(encryptedbytes)</span><br><span class="line">            <span class="built_in">print</span>(<span class="built_in">len</span>(encryptedbytes))</span><br><span class="line">        s.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    socket_client()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> xdu </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 安全 </tag>
            
            <tag> lab </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IELTS口语</title>
      <link href="/2024/04/01/2024-4-1-IELTS%E5%8F%A3%E8%AF%AD/"/>
      <url>/2024/04/01/2024-4-1-IELTS%E5%8F%A3%E8%AF%AD/</url>
      
        <content type="html"><![CDATA[<p>记录下个人做的部分准备,可以准备一遍,但千万不要背诵,很容易被发现的,特别是part 3是完全不能准备的,所以容易被判背题</p><h2 id="Part-1"><a href="#Part-1" class="headerlink" title="Part 1"></a>Part 1</h2><h3 id="Memory"><a href="#Memory" class="headerlink" title="Memory"></a>Memory</h3><h4 id="Are-you-good-at-memorizing-things"><a href="#Are-you-good-at-memorizing-things" class="headerlink" title="Are you good at memorizing things?"></a>Are you good at memorizing things?</h4><p>I would say my memory is average. I don’t consider myself good at memorizing things, but I can usually remember important information when needed.</p><h4 id="Have-you-ever-forgotten-something-important？"><a href="#Have-you-ever-forgotten-something-important？" class="headerlink" title="Have you ever forgotten something important？"></a>Have you ever forgotten something important？</h4><p>Actually,I can’t recall a time when I forgot something important.</p><h4 id="What-do-you-need-to-remember-in-your-daily-life"><a href="#What-do-you-need-to-remember-in-your-daily-life" class="headerlink" title="What do you need to remember in your daily life?"></a>What do you need to remember in your daily life?</h4><p>I need to remember my plan. Every night I lie in bed thinking about what I did today and what I should do tomorrow. The next day I wake up and think about the plan I made last night</p><h4 id="How-do-you-remember-important-things"><a href="#How-do-you-remember-important-things" class="headerlink" title="How do you remember important things?"></a>How do you remember important things?</h4><p>For important things, I always record them in my todolist and set a reminder time to remind me not to forget them.</p><h3 id="Celebrities"><a href="#Celebrities" class="headerlink" title="Celebrities"></a>Celebrities</h3><h4 id="Who-is-your-favourite-celebrity-in-your-country"><a href="#Who-is-your-favourite-celebrity-in-your-country" class="headerlink" title="Who is your favourite celebrity in your country?"></a>Who is your favourite celebrity in your country?</h4><p>My favourite celebrity is Lei Jun.He founded the brand Xiaomi(mi) from scratch, which is a high-tech company just like Apple. In addition, he majored in computer science at university, which is the same as mine.</p><h4 id="What-kind-of-famous-people-do-you-often-see-in-the-news"><a href="#What-kind-of-famous-people-do-you-often-see-in-the-news" class="headerlink" title="What kind of famous people do you often see in the news?"></a>What kind of famous people do you often see in the news?</h4><p>Singers and the founders of some Internet companies.Like Jack Ma, who is the founder of Alibaba.Like Taylor swift, kanye west…</p><h4 id="Do-you-pay-attention-to-famous-people-in-the-news"><a href="#Do-you-pay-attention-to-famous-people-in-the-news" class="headerlink" title="Do you pay attention to famous people in the news?"></a>Do you pay attention to famous people in the news?</h4><p>No,I don’t pay attention to them.</p><h4 id="Do-you-believe-that-the-news-about-famous-people-in-the-media-is-true"><a href="#Do-you-believe-that-the-news-about-famous-people-in-the-media-is-true" class="headerlink" title="Do you believe that the news about famous people in the media is true?"></a>Do you believe that the news about famous people in the media is true?</h4><p>It can’t be all true. As we all know, some people/media will create rumors to get attention.</p><h4 id="Would-you-like-to-be-famous"><a href="#Would-you-like-to-be-famous" class="headerlink" title="Would you like to be famous?"></a>Would you like to be famous?</h4><p>Of course. Despite all the trouble that comes with being famous, that’s the price of making money this way.</p><h3 id="Singing"><a href="#Singing" class="headerlink" title="Singing"></a>Singing</h3><h4 id="Do-you-like-singing-Why"><a href="#Do-you-like-singing-Why" class="headerlink" title="Do you like singing? Why?"></a>Do you like singing? Why?</h4><p>To be honest, I don’t like singing very much. It’s mainly because I’m tone-deaf, so I can’t sing well.</p><h4 id="Did-you-learn-to-sing-at-school"><a href="#Did-you-learn-to-sing-at-school" class="headerlink" title="Did you learn to sing at school?"></a>Did you learn to sing at school?</h4><p>Yes, we did. In primary school and middle school, we had music classes where our music teacher would sometimes teach us how to sing.</p><h4 id="Who-do-you-want-to-sing-for"><a href="#Who-do-you-want-to-sing-for" class="headerlink" title="Who do you want to sing for?"></a>Who do you want to sing for?</h4><p>Honestly, because I’m tone-deaf, I don’t really want to sing for anyone in particular. I don’t feel confident enough to perform for a specific person or audience.</p><h4 id="Do-you-think-singing-can-bring-happiness-to-people"><a href="#Do-you-think-singing-can-bring-happiness-to-people" class="headerlink" title="Do you think singing can bring happiness to people?"></a>Do you think singing can bring happiness to people?</h4><p>Absolutely! Singing brings joy to people, especially for those who are talented singers.</p><h3 id="Crowded-place"><a href="#Crowded-place" class="headerlink" title="Crowded place"></a>Crowded place</h3><h4 id="Is-the-city-where-you-live-crowded"><a href="#Is-the-city-where-you-live-crowded" class="headerlink" title="Is the city where you live crowded?"></a>Is the city where you live crowded?</h4><p>Yes, you know, Xi ‘an is a tourist city and many places are very crowded.</p><h4 id="ls-there-a-crowded-place-near-where-you-live"><a href="#ls-there-a-crowded-place-near-where-you-live" class="headerlink" title="ls there a crowded place near where you live?"></a>ls there a crowded place near where you live?</h4><p>No, there isn’t a crowded place near where I live. My school is located in the suburb, so there are very few people around.</p><h4 id="Do-you-like-crowded-places"><a href="#Do-you-like-crowded-places" class="headerlink" title="Do you like crowded places?"></a>Do you like crowded places?</h4><p>NO. It just makes me feel annoyed when there are too many people around.</p><h4 id="Do-most-people-like-crowded-places"><a href="#Do-most-people-like-crowded-places" class="headerlink" title="Do most people like crowded places?"></a>Do most people like crowded places?</h4><p>Well, it really depends on the person. Like me, I don’t like crowded places. But some of my friends, they like crowded places.</p><h4 id="When-was-the-last-time-you-were-in-a-crowded-place"><a href="#When-was-the-last-time-you-were-in-a-crowded-place" class="headerlink" title="When was the last time you were in a crowded place?"></a>When was the last time you were in a crowded place?</h4><p>Last year’s National Day holidays, I went to Mountain Hua, not far from xian, and it was very crowded.</p><h3 id="Feeling-bored"><a href="#Feeling-bored" class="headerlink" title="Feeling bored"></a>Feeling bored</h3><h4 id="Do-you-often-feel-bored"><a href="#Do-you-often-feel-bored" class="headerlink" title="Do you often feel bored?"></a>Do you often feel bored?</h4><p>Yes. I often feel bored.</p><h4 id="When-do-you-feel-bored"><a href="#When-do-you-feel-bored" class="headerlink" title="When do you feel bored?"></a>When do you feel bored?</h4><p>I usually feel bored when I’m exhausted . It’s like I have no energy to do anything, but at the same time, I find everything around me quite boring.</p><h4 id="What-do-you-do-when-you-feel-bored"><a href="#What-do-you-do-when-you-feel-bored" class="headerlink" title="What do you do when you feel bored?"></a>What do you do when you feel bored?</h4><p>When I’m bored, I often lie in bed, watch funny videos on Tiktok, or listen to podcasts.</p><h4 id="Do-you-think-childhood-is-boring-or-adulthood-is-boring"><a href="#Do-you-think-childhood-is-boring-or-adulthood-is-boring" class="headerlink" title="Do you think childhood is boring or adulthood is boring?"></a>Do you think childhood is boring or adulthood is boring?</h4><p>…</p><h3 id="Collecting-things"><a href="#Collecting-things" class="headerlink" title="Collecting things"></a>Collecting things</h3><h4 id="Do-you-collect-things"><a href="#Do-you-collect-things" class="headerlink" title="Do you collect things?"></a>Do you collect things?</h4><p>No,I don’t have such a hobby.</p><h4 id="Are-there-any-things-you-have-kept-from-childhood"><a href="#Are-there-any-things-you-have-kept-from-childhood" class="headerlink" title="Are there any things you have kept from childhood?"></a>Are there any things you have kept from childhood?</h4><p>Yes, I have a piggy bank that my grandmother gave me when I was a child. I usually put my spare change in it.</p><h4 id="Where-do-you-usually-keep-things-you-need"><a href="#Where-do-you-usually-keep-things-you-need" class="headerlink" title="Where do you usually keep things you need?"></a>Where do you usually keep things you need?</h4><p>I usually keep things I need in easily accessible places like the bookshelf, desk, or my bag. It’s convenient to have them within reach so that I can easily find and use them when needed.</p><h4 id="Would-you-keep-old-things-for-a-long-time-Why"><a href="#Would-you-keep-old-things-for-a-long-time-Why" class="headerlink" title="Would you keep old things for a long time? Why?"></a>Would you keep old things for a long time? Why?</h4><p>Yes, I would keep some old things for a long time. It’s because these things either have a practical use or hold sentimental value for me.</p><h3 id="Music"><a href="#Music" class="headerlink" title="Music"></a>Music</h3><h4 id="Do-a-lot-of-people-like-music"><a href="#Do-a-lot-of-people-like-music" class="headerlink" title="Do a lot of people like music?"></a>Do a lot of people like music?</h4><p>Absolutely! Music has this unique healing power.It has the ability to touch our souls and uplift our spirits</p><h4 id="What-kind-of-music-do-you-listen-to"><a href="#What-kind-of-music-do-you-listen-to" class="headerlink" title="What kind of music do you listen to?"></a>What kind of music do you listen to?</h4><p>I’m really into country music, like Hotel California, Mine. I love how country music is all about storytelling . It’s like a window into someone’s life and experiences.(taylor的专辑Speak Now)</p><h4 id="ls-it-easy-to-learn-music"><a href="#ls-it-easy-to-learn-music" class="headerlink" title="ls it easy to learn music?"></a>ls it easy to learn music?</h4><p>No, .. I often can’t get the beat right</p><h4 id="Did-you-have-music-lessons-at-school"><a href="#Did-you-have-music-lessons-at-school" class="headerlink" title="Did you have music lessons at school?"></a>Did you have music lessons at school?</h4><p>yes..</p><h3 id="Money"><a href="#Money" class="headerlink" title="Money"></a>Money</h3><h4 id="How-do-you-save-money"><a href="#How-do-you-save-money" class="headerlink" title="How do you save money?"></a>How do you save money?</h4><p>Well, one way I save money is by eating at the canteen instead of going out to restaurants.  Additionally, I try to cut back on buying unnecessary clothing and electronics. </p><h4 id="Do-you-prefer-to-save-money-or-spend-money"><a href="#Do-you-prefer-to-save-money-or-spend-money" class="headerlink" title="Do you prefer to save money or spend money?"></a>Do you prefer to save money or spend money?</h4><p>Oh, I definitely enjoy spending money and the happiness it brings. Of course, I also save money, but for me, saving is just a way to be able to spend better in the future.</p><h4 id="Do-you-use-a-payment-app-on-your-mobile-phone-to-buy-things"><a href="#Do-you-use-a-payment-app-on-your-mobile-phone-to-buy-things" class="headerlink" title="Do you use a payment app on your mobile phone to buy things?"></a>Do you use a payment app on your mobile phone to buy things?</h4><p>yes, …</p><h4 id="Do-you-use-a-credit-card-to-buy-things"><a href="#Do-you-use-a-credit-card-to-buy-things" class="headerlink" title="Do you use a credit card to buy things?"></a>Do you use a credit card to buy things?</h4><p>No, I don’t have a credit card. I’m still a student and I don’t have a full-time job, so I can’t apply for one.</p><h4 id="Do-you-think-cash-will-still-be-popular-in-the-future"><a href="#Do-you-think-cash-will-still-be-popular-in-the-future" class="headerlink" title="Do you think cash will still be popular in the future?"></a>Do you think cash will still be popular in the future?</h4><p>…</p><h3 id="Cake"><a href="#Cake" class="headerlink" title="Cake"></a>Cake</h3><h4 id="Do-you-know-how-to-bake-a-cake"><a href="#Do-you-know-how-to-bake-a-cake" class="headerlink" title="Do you know how to bake a cake?"></a>Do you know how to bake a cake?</h4><p>Oh, I’m completely clueless when it comes to baking.</p><h4 id="Do-you-like-to-have-dessert-after-a-meal"><a href="#Do-you-like-to-have-dessert-after-a-meal" class="headerlink" title="Do you like to have dessert after a meal?"></a>Do you like to have dessert after a meal?</h4><p>no,…</p><h4 id="Do-you-like-to-eat-cakes-or-other-sweet-foods"><a href="#Do-you-like-to-eat-cakes-or-other-sweet-foods" class="headerlink" title="Do you like to eat cakes or other sweet foods?"></a>Do you like to eat cakes or other sweet foods?</h4><p>no,…</p><h4 id="Did-you-like-to-eat-cakes-as-a-child"><a href="#Did-you-like-to-eat-cakes-as-a-child" class="headerlink" title="Did you like to eat cakes as a child?"></a>Did you like to eat cakes as a child?</h4><p>definately, every child likes cakes, doesn’t he?</p><h4 id="Are-there-any-traditional-Chinese-cakes"><a href="#Are-there-any-traditional-Chinese-cakes" class="headerlink" title="Are there any traditional Chinese cakes?"></a>Are there any traditional Chinese cakes?</h4><p>Yes,.. For instance, there’s mooncake, which is essential during the Mid-Autumn Festival. We also have rice cakes for Chinese New Year, which are very popular in the south.</p><h3 id="Colors"><a href="#Colors" class="headerlink" title="Colors"></a>Colors</h3><h4 id="What-is-your-favorite-color"><a href="#What-is-your-favorite-color" class="headerlink" title="What is your favorite color?"></a>What is your favorite color?</h4><p>My favorite color is sky blue.This color makes me feel relaxed, as if I was lying on the grass looking at the blue sky.</p><h4 id="Are-there-any-colors-that-have-a-special-meaning-in-your-country"><a href="#Are-there-any-colors-that-have-a-special-meaning-in-your-country" class="headerlink" title="Are there any colors that have a special meaning in your country?"></a>Are there any colors that have a special meaning in your country?</h4><p>In my country, the color green, especially when it comes to a green hat, means that your partner is being unfaithful. </p><h4 id="Do-you-think-different-types-of-people-like-different-colors"><a href="#Do-you-think-different-types-of-people-like-different-colors" class="headerlink" title="Do you think different types of people like different colors?"></a>Do you think different types of people like different colors?</h4><p>Definitely! People’s preferences for colors can vary greatly.  It’s all about personal taste and individuality.</p><h4 id="What’s-the-colour-you-dislike-Why"><a href="#What’s-the-colour-you-dislike-Why" class="headerlink" title="What’s the colour you dislike?Why?"></a>What’s the colour you dislike?Why?</h4><p>Honestly, I don’t really have a color that I dislike, but if I had to choose one, it would probably be yellow. It’s not that I hate it, but it’s just not a color that I’m particularly fond of. I guess it’s because it can be quite bright and overwhelming at times.</p><h3 id="others"><a href="#others" class="headerlink" title="others"></a>others</h3><h4 id="What-do-people-often-do-on-social-media"><a href="#What-do-people-often-do-on-social-media" class="headerlink" title="What do people often do on social media?"></a>What do people often do on social media?</h4><p>Connecting with others, Sharing updates, Following interests</p><h4 id="ls-there-an-advertisement-that-made-an-impression-on-you-when-you-were-a-child"><a href="#ls-there-an-advertisement-that-made-an-impression-on-you-when-you-were-a-child" class="headerlink" title="ls there an advertisement that made an impression on you when you were a child?"></a>ls there an advertisement that made an impression on you when you were a child?</h4><p>It was a commercial for a game console endorsed by Jackie Chan, which I remember was kind of funny.</p><h4 id="What-kind-of-clothes-do-you-like-to-wear"><a href="#What-kind-of-clothes-do-you-like-to-wear" class="headerlink" title="What kind of clothes do you like to wear?"></a>What kind of clothes do you like to wear?</h4><p>I like to wear casual clothes.They are comfortable and practical, suitable for most occasions, not too expensive.</p><h4 id="Do-you-prefer-to-chat-with-a-group-of-people-or-with-only-one-friend"><a href="#Do-you-prefer-to-chat-with-a-group-of-people-or-with-only-one-friend" class="headerlink" title="Do you prefer to chat with a group of people or with only one friend?"></a>Do you prefer to chat with a group of people or with only one friend?</h4><p>Personally, I prefer to chat with just one friend. When chatting with a group of people, the topics can easily digress. But with one friend, we can have a more focused and meaningful conversation.</p><h4 id="Do-you-argue-with-friends"><a href="#Do-you-argue-with-friends" class="headerlink" title="Do you argue with friends?"></a>Do you argue with friends?</h4><p>Yes, sometimes. I think it’s unavoidable, even best friends can sometimes get into arguments.</p>]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IELTS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IELTS优秀大作文分享</title>
      <link href="/2024/03/23/2024-3-23-IELTS%E5%A4%A7%E4%BD%9C%E6%96%87/"/>
      <url>/2024/03/23/2024-3-23-IELTS%E5%A4%A7%E4%BD%9C%E6%96%87/</url>
      
        <content type="html"><![CDATA[<h3 id="IELTS优秀大作文分享"><a href="#IELTS优秀大作文分享" class="headerlink" title="IELTS优秀大作文分享"></a>IELTS优秀大作文分享</h3><h4 id="Agree-Disagree"><a href="#Agree-Disagree" class="headerlink" title="Agree/Disagree"></a>Agree/Disagree</h4><p>这篇7.5-8.5分</p><p><strong>题目</strong>: Women and men are commmonly seen as having different strengthes and weakness. Some people think it is right to excludemales and females from certian professions because of their gender. To extend do you agree or disagree?</p><p><strong>正文</strong>:</p><p>Social issues related to gender have been widely discussed among people over centuries. Due to gender differences, some people have claimed that certain jobs should accept either men or women. However, such a statement suffers from logical and factual problems. I hardly agree with this one-side proposal.</p><p>To begin with, limiting the access to certain occupations on the basis of gender may ignore the individualities since the over-generalized characteristics of men and women are not always universal. Such an act may hurt the whole society. For instance, if females are only allowed to enter particular careers be them nurses, teachers or accountants, those who are unenthusiastic and unable to handle these work and rejected from other professions might take these important positions. Males that are authentically passionate about these jobs will be faced with the risks of being jobless. Hence, the overall domestic unemployment rate will increase. </p><p>Additionally, in a society where the exclusion of men or women from certain jobs is taken for granted by people, pre-existing gender stereotypes tend to be reinforced, which is undesirable for social equality. For example, in many parts of the world girls are either explicitly or implicitly barred from entering certain professions such as science. As a result, girls might be discouraged from taking science classes at an early age, and later have less chance of finding good jobs. Had it not been for such bias, the society would have been more productive.</p><p>Admittedly, females and males with naturally-selected biological dissimilarities either on brain structures or genes grant differentiated cognitive skills or physical strengths. Hence, labor division according to genders might enable a society to achieve productive efficiency. However, the collaboration and cooperation between women and men making full use of their distinctive advantages might further facilitate the efficiency of working, which has been studied extensively by multiple groups of researchers worldwide.</p><p>In conclusion, having considered both sides of the statement, I still believe that in a diverse and dynamic society, people, regardless of their gender, ought to have equal opportunities and access to compete for the jobs that they desire for.</p><h4 id="Agree-Disagree-1"><a href="#Agree-Disagree-1" class="headerlink" title="Agree/Disagree"></a>Agree/Disagree</h4><p>这是我自己仿写的一篇, 大概6.5的样子,开头段比较草率,第四段的转折也不够充分</p><p><strong>题目</strong>: Some countries spend a lot of money preparing competitors to take part in major competitions such as Olympic Games or football World Cup. Some people say that it would be better to spend this money encouraging children to take up sports from a young age. To what extent do you agree or disagree? </p><p><strong>正文</strong>:</p><p>Nowadays, various countries are investing a large amount of money in major competitions. Some people claim that it would be better to use the budget to encourage children to take part in sports from a young age. I completely agree with this opinion.</p><p>To begin with, children are the future of society. <code>No amount of money is too much to invest in the cultivation of children</code>. If such a budget is used to invest in children’s sports competition, more and more children will participate in the sport which they are interested in. As a result, the next generation of our country will be stronger and more healthy. Hence, disease rates would decrease and life expectancy would increase.</p><p>Additionally, investing in children has a higher <code>return on investment</code>.  The current competitors for sports will soon age and become unable to participate in sporting events. By contrast, children are unshaped, and it is much easier to develop them into good athletes than it is to develop adult athletes. Therefore, spending the government’s national budget on children will facilitate the early preparation and training of successful sportsmen in the future. </p><p>It cannot be denied that spending the budget on existing athletes is effective and we may achieve certain results in the short term. However, in the long run, the only way to achieve greater success is to develop their sports interests and skills in childhood.</p><p>In conclusion, having considered both sides of the statement, I firmly maintain the perspective that investing the funds in promoting early engagement in sports among children is preferable to investing in training athletes for participation in major competitions.</p><h4 id="Positive-Negative"><a href="#Positive-Negative" class="headerlink" title="Positive/Negative"></a>Positive/Negative</h4><p>7.5/8.0</p><p><strong>题目</strong>: Nowdays it’s become easier and more affordable for people to visit other countries. Is it a positive or negative development?</p><p><strong>正文</strong>:</p><p>It cannot be denied that as international travel is becoming easier and more affordable, certain issues and inconvenience have been brought to both the travelers and locals. As a result, some impressionable(易受影响的) people might form the bias(偏见) that the development of international travel is more of a negative development. Nevertheless(不过), as far as culture and globalization, international economy, and environmental protection are concerned, such a development is for sure a positive one. </p><p>First and foremost, the increasing easiness and affordability of international travel promotes both the spread of domestic culture and learning of foreign culture, contributing to a deeper international mutual understanding. Due to difference in ideology and value, nations around the world usually hold stereotype opinions on others, causing difficulties in personal, business, and political communication and cooperation. Easier international travel not only enables travelers to show the world what their true life is, but showcase the world right in front of the travelers. </p><p>Second, the fact that easier international travel promotes the growth of international economy indicates that it is definitely a positive development. Take Thailand, a country that benefits greatly from tourism, for example. Thanks to the easiness of international travel in modern days, the reasonable cost of living, fantastic sightseeing spots, and charming culture in Thailand can be enjoyed by people around the world. As a result, about 25% of Thailand’s economy is closely associated with tourism, which has provided tons of jobs for locals. Had it not been for the easiness and affordability in international travel, Thailand would not have been able to attract international travels or create jobs for citizens.</p><p>A voice arises that international travel could bring devastating effects to the local environment due to pollution. Ironically, it is usually not the travelers who bring damage but lack of funding or poor management. Particularly in developing regions, without the income from travelers, the locals would have no choice but to exploit natural resources and damage the environment; on the other hand, effective tourism management can not only generate funding for the environmental protection but keep the sightseeing spots from being affected.</p><p>Therefore, in terms of culture and globalization, international economy, and environmental protection, I strongly hold the opinion that easier international travel is a positive development. <code>While one sees a circle and another sees a zero</code>(仁者见仁智者见智), I believe my opponents will compromise upon being shown to my article</p><h4 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h4><p>7.5/8.0</p><p><strong>题目</strong>: In some countries, the number of people who use bicycles as their main form of transport is decreasing even though riding bicycles has many benefits. What are the reasons? What could be done to encourage the use of bicycles.</p><p><strong>正文</strong>:</p><p>It cannot be denied that bicycle is an invention that has existed for a long time in human history, and such a fact leads some to have the idea that bicycle is a thing of the past. However, such an idea needs to be scrutinized meticulously before a conclusion can be reached. </p><p>First and foremost, it is a fact that due to the development of technology, the use of bicycle has declined dramatically as people’s main form of transport. We now have faster and more efficient ways of communication – private cars, subways, and bus rapid transit – which take us to our intended destinations easily and conveniently, without the need to keep the bulky bikes with us when we hang out with friends, and not to mention the trouble of keeping them in a safe place from theft. </p><p>Although some might claim that bikes are outdated, bicycles in fact have significant benefits to both individuals and the society in terms of health and the environment. For us, riding bikes not only helps us dodge traffic congestions during peak hours, but promote our physical health through moderate aerobic exercise and mental health through distracting us from intensive study or professional work; on the other hand, the use of vehicles has caused major cities around the globe the problem of air pollution such as smog, and the wide adoption of bikes could contain such issues – the success in Amsterdam, Netherland and Copenhagen, Denmark are two successful cases in point. </p><p>In my opinion, it is through the combination of technology and governmental policy that we can best encourage the use of bicycles. To be more specific, the wide adoption of mobile devices and GPS technology has enabled the birth of shared bikes, which not only complements conventional ways of transportation but eliminates the need for carrying or storage; furthermore, governmental subsidies could be provided to companies that operate shared bikes, and those who do not own private cars and frequently use bicycles. The synergy from such a combination will effectively work as an incentive to boost the use of bicycles.</p><p>In conclusion, the use of bicycles has numerous advantages to our modern society, and it should be promoted. While one sees a zero and another sees a circle, I am confident that my opponents will compromise after being shown to my article. </p><h4 id="Analysis-1"><a href="#Analysis-1" class="headerlink" title="Analysis"></a>Analysis</h4><p>7.5+</p><p><strong>题目</strong>: In education and employment, some people work harder than others. Why do some people work harder than others? Is it always a good thing to work hard?</p><p><strong>正文</strong>:</p><p>It cannot be denied that spending more time and effort on our work and study could usually yield more results, and such a fact leads some to generate the opinion that working harder than others is the very principle of life. However, such an idea needs to be scrutinized meticulously before a conclusion can be reached.</p><p>First and foremost, it is a fact that due to the accelerating pace of life caused by the growth of economy, many tend to work harder than others. More goods and services are now available to us, combined with the effect of advertising, it is a natural tendency for people to desire what they do not have, resulting in an increasing number of diligent students and workers who aim to enjoy these products, tangible or intangible; furthermore, the growth of economy in recent centuries has also conglomerated societal wealth into the hands of a few, further burdening the ordinary working class who do not have power.</p><p>Second, the fact that technology has allowed the fast spread of information indicates that people work harder as they see more “role models.” Take the case of the successful stories of entrepreneurs that we almost hear about every day on social media via mobile devices: while they are indeed a tiny portion of the population, the high frequency in which we hear about the stories leaves us the impression that such is the norm for every individual. Had it not been for such development in the society, we would never have formed such a value.</p><p>Although some might claim that working hard is a virtue, such philosophy in fact might compromise multiple aspects of our life and the society. For us, extended working or study hours could lead to a lack of physical exercise and communication with our family and beloved ones, damaging our physical and mental health and then forming a vicious cycle in the efficiency of our work and study; on the other hand, a society with a heavy focus on “working hard,” namely material wealth, will produce an atmosphere with an animosity between people as they view everyone else a competitor, losing the capacity of humanity in the culture of the city, eventually forcing its citizens out due to excessive pressure and mental suffering. </p><p>In conclusion, always working harder is a belief that carrys risk to both individuals and the society. While one sees a zero and another sees a circle, I am confident that my opponents will compromise after being shown to my article.</p>]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IELTS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis缓存问题:穿透,击穿,雪崩,双写一致性等</title>
      <link href="/2024/03/15/2024-3-15-redis%E7%BC%93%E5%AD%98%E9%97%AE%E9%A2%98/"/>
      <url>/2024/03/15/2024-3-15-redis%E7%BC%93%E5%AD%98%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="Redis缓存问题-Redis缓存问题-穿透-击穿-雪崩-双写一致性等"><a href="#Redis缓存问题-Redis缓存问题-穿透-击穿-雪崩-双写一致性等" class="headerlink" title="Redis缓存问题:Redis缓存问题:穿透,击穿,雪崩,双写一致性等"></a>Redis缓存问题:Redis缓存问题:穿透,击穿,雪崩,双写一致性等</h2><p>在高并发场景下,数据库往往是最薄弱的环节,我们通常选择使用<code>redis</code>来进行缓存,以起到缓冲作用,来降低数据库的压力,但是一旦缓存出现问题,也会导致数据库瞬间压力过大甚至崩溃,从而导致整个系统崩溃.今天就聊聊常见的<code>redis</code>缓存问题.</p><h3 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h3><p>缓存击穿一般指redis中的一个热点数据过期,导致大量请求直接访问数据库的情况,导致数据库瞬间压力过大甚至崩溃.</p><p><strong>解决方案:</strong></p><ol><li>设置热点数据永不过期,这是一个不错的方案(要考虑业务特性,体量以及成本),<strong>前提</strong>是热点数据不能频繁发生改变,否则就会出现缓存污染.最好是根据一定的策略进行定时更新</li><li>重要接口限流,做好熔断和降级的准备,sentinel是个不错的选择</li><li>使用互斥锁,保证同一时刻只有一个线程可以访问数据库,这何尝不是一种限流呢</li></ol><h3 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h3><p>缓存穿透指缓存和数据库中都没有的数据,用户不断发起请求.这种情况最可能就是有人试图恶意攻击系统</p><p><strong>解决方案:</strong></p><ol><li>加校验:拦截非法请求,用户鉴权等</li><li>redis缓存一个无效值,以防止对同一个key在数据库中的多次查询,但redis中可能会出现大量无效值,导致缓存污染,所以要将有效时间设置得短一些</li><li>添加布隆过滤器,在对数据库进行查询前,先通过布隆过滤器判断是否存在</li></ol><p>一般来说这三种方案是<strong>同时使用</strong>的,第一层一般是校验,拦截部分非法用户和不合理请求(拦截不可能全部拦截而且如果攻击者通过某些方式掌握了大量合法用户呢),第二层是布隆过滤器,尽量避免对数据库的直接访问,但仍然有误判的可能性,第三层再缓存一个无效值,做到尽可能降低风险</p><h3 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h3><p>缓存雪崩一般指reids中大批量数据在极短时间内(同时)过期,导致大量的查询数据库</p><p><strong>解决方案:</strong></p><ol><li>在存储数据时,设置过期时间为一个随机值(也可以理解成给固定的过期时间加上一个随机值,类似密码学中的加盐),尽量保证不会有大量数据在同一时间过期</li><li>将热点数据尽量均匀地分布在不同的数据库中</li><li>多级缓存</li><li>设置热点数据永不过期(同缓存击穿中的)</li></ol><h3 id="缓存污染"><a href="#缓存污染" class="headerlink" title="缓存污染"></a>缓存污染</h3><p>缓存污染指的是缓存中一些只会被访问一次或者几次的的数据,被访问完后,再也不会被访问到,但这部分数据依然留存在缓存中,消耗缓存空间,也会在一定程度上影响redis的性能</p><p>redis缓存的maxmemory应该设置多大,这是一个关乎性能和成本的问题,需要根据实际情况进行权衡,但普遍推荐的是设置为总数据量的15%-30%(其他博客都这么写,而且范围还挺大,应该没什么问题🤔)</p><h4 id="缓存淘汰策略"><a href="#缓存淘汰策略" class="headerlink" title="缓存淘汰策略"></a>缓存淘汰策略</h4><p>官方文档写了8种,如下图:<br><img src="https://pb01.s3.bitiful.net/157.png" alt="avatar"></p><ul><li><p>noeviction(不驱逐,即不淘汰)</p><p>默认策略,当缓存达到maxmemory时,redis会拒绝所有写请求,并返回错误信息,此时redis已经进入只读模式,无法再进行写操作,但仍然可以进行读操作</p></li><li><p>allkeys-lru<br>所有key采用LRU算法进行淘汰,即优先删除最近最少使用的key</p></li><li><p>allkeys-lfu<br>所有key采用LFU算法进行淘汰,即优先删除最不常用的key</p></li><li><p>volatile-lru<br>只淘汰设置了过期时间的key,采用LRU算法进行淘汰</p></li><li><p>volatile-lfu<br>只淘汰设置了过期时间的key,采用LFU算法进行淘汰</p></li><li><p>allkeys-random<br>所有key采用随机删除</p></li><li><p>volatile-random<br>只淘汰设置了过期时间的key,采用随机删除</p></li><li><p>volatile-ttl<br>删除过期字段设置为true和剩余最短生存时间（TTL）值的密钥。</p></li></ul><h2 id="缓存和数据库一致性"><a href="#缓存和数据库一致性" class="headerlink" title="缓存和数据库一致性"></a>缓存和数据库一致性</h2><p>不管是先写MySQL数据库，再删除Redis缓存；还是先删除缓存，再写数据库，都有可能出现数据不一致的情况。举一个例子：如果删除了缓存Redis，还没有来得及写库MySQL，另一个线程就来读取，发现缓存为空，则去数据库中读取数据写入缓存，此时缓存中为脏数据。</p><p>更新缓存有四种设计模式: Cache aside, Read through, Write through, Write behind caching</p><h3 id="缓存更新模式"><a href="#缓存更新模式" class="headerlink" title="缓存更新模式"></a>缓存更新模式</h3><h4 id="Cache-Aside-旁路缓存"><a href="#Cache-Aside-旁路缓存" class="headerlink" title="Cache Aside(旁路缓存)"></a>Cache Aside(旁路缓存)</h4><ul><li>失效：应用程序先从cache取数据，没有得到，则从数据库中取数据，成功后，放到缓存中。</li><li>命中：应用程序从cache中取数据，取到后返回。</li><li>更新：更新数据库, 更新/删除缓存</li></ul><p><strong>那么到底是更新缓存还是删除缓存呢?</strong></p><p>如果读的频率高, 选择更新缓存, 这样可以提高缓存命中率</p><p>如果写的频率高, 选择删除缓存, 等到要读的时候再写入缓存, 可以减少无效的写操作和减少缓存数据量</p><h4 id="Read-Through-读穿"><a href="#Read-Through-读穿" class="headerlink" title="Read Through(读穿)"></a>Read Through(读穿)</h4><p>Read Through 套路就是在查询操作中更新缓存，也就是说，当缓存失效的时候，Cache Aside是由调用方负责把数据加载入缓存，而Read Through则用缓存服务自己来加载，从而对应用方是透明的。</p><h4 id="Write-Through-写穿"><a href="#Write-Through-写穿" class="headerlink" title="Write Through(写穿)"></a>Write Through(写穿)</h4><p>Write Through 套路和Read Through相仿，不过是在更新数据时发生。当有数据更新的时候，如果没有命中缓存，直接更新数据库，然后返回。如果命中了缓存，则更新缓存，然后再由Cache自己更新数据库（这是一个同步操作）</p><h4 id="Write-Behind-Caching-写回"><a href="#Write-Behind-Caching-写回" class="headerlink" title="Write Behind Caching(写回)"></a>Write Behind Caching(写回)</h4><p>在更新数据的时候，只更新缓存，不更新数据库，而我们的缓存会异步地批量更新数据库。这个设计的好处就是让数据的I/O操作飞快无比（因为直接操作内存嘛 ），因为异步，还可以合并对同一个数据的多次操作，所以性能的提高是相当可观的。但是，其带来的问题是，数据不是强一致性的，而且可能会丢失</p><p>一般而言(即不是特殊的业务场景), 我们<strong>选用Cache Aside(旁路缓存)模式</strong>, 下面我们的讨论也基于此模式.</p><h3 id="操作缓存-amp-操作数据库，哪个先？"><a href="#操作缓存-amp-操作数据库，哪个先？" class="headerlink" title="操作缓存 &amp; 操作数据库，哪个先？"></a>操作缓存 &amp; 操作数据库，哪个先？</h3><h4 id="针对删除缓存的情况："><a href="#针对删除缓存的情况：" class="headerlink" title="针对删除缓存的情况："></a>针对删除缓存的情况：</h4><p><strong>如果采用先删除缓存，在更新数据库，会有什么后果？</strong></p><ol><li>线程A先把缓存的A数据删除，发生上下文切换</li><li>线程B想要读取A数据，发现缓存失效，从数据库读取A数据，并且更新缓存，</li><li>切换回线程A，线程A更新数据库数据。</li></ol><p>至此，数据不一致的情况已经出现，数据库的写入较慢，容易出现此现象</p><p><strong>先更新数据库，再删除缓存 怎么样？</strong></p><ol><li>线程A读取缓存A数据，发现缓存失效，所以去数据库读取，此时还未写入缓存，发生上下文切换</li><li>线程B更新数据库，并且删除对应的缓存，</li><li>切换回线程A，线程A将读取到的旧值，写入缓存</li></ol><p>又出现了数据不一致的情况，但是相比先删除缓存，发生概率小很多，必须<strong>同时满足</strong>:</p><ul><li>读请求的时候，缓存刚好失效</li><li>读请求 与 写请求 并发</li></ul><p>所以在实际中很难出现请求 B 已经更新了数据库并且删除了缓存，请求 A 才更新完缓存的情况。所以推荐先<code>更新数据库，再删除缓存</code></p><p><strong>还是存在不一致的可能，怎么实现最终的一致性呢？</strong></p><ol><li>延迟双删策略<br>延迟双删策略是分布式系统中数据库存储和缓存数据保持一致性的常用策略，但它不是强一致。其实不管哪种方案，都避免不了Redis存在脏数据的问题，只能减轻这个问题，要想彻底解决，得要用到同步锁和对应的业务逻辑层面解决。</li></ol><p>不采用先更新数据库，在删除缓存的方案, 而是用先删除缓存，再更新数据库，里面的不一致问题，用延迟双删解决<br>1、先删除缓存 2、再写数据库 3、休眠500ms（统计线程读取数据和写缓存的时间） （休眠的作用是当前线程等其他线程读完了数据后写入缓存后，删除缓存） 4、再删除缓存</p><ol><li>设置较短的缓存过期时间<br>沿用先更新数据库，再删除缓存,就给缓存设置一个较短的过期时间(只要它够短,就不容易读到错误数据)</li></ol><h4 id="针对更新缓存的情况：（面试说上面那种即可）"><a href="#针对更新缓存的情况：（面试说上面那种即可）" class="headerlink" title="针对更新缓存的情况：（面试说上面那种即可）"></a>针对更新缓存的情况：（面试说上面那种即可）</h4><p><strong>如果采用先更新缓存，再更新数据库</strong></p><ol><li>线程A更新了缓存，此时发生上下文切换</li><li>线程B更新缓存，更新数据库，此时切换回线程A</li><li>线程A更新数据库</li></ol><p>此时就出现了数据不一致的现象，数据库的写入较慢，容易出现此现象。</p><p><strong>反过来，先更新数据库，再更新缓存呢?</strong></p><ol><li>线程A更新了数据库，还未写入缓存，发生上下文切换</li><li>线程B更新了数据库，并且写入缓存，此时切换到线程A</li><li>线程A把缓存写入，覆盖了之前线程B的缓存</li></ol><p>至此，数据不一致的情况，又出现了。缓存的写入通常要远远快于数据库的写入，所以在实际中很难出现请求 B 已经更新了数据库并且更新了缓存，请求 A 才更新完缓存的情况。所以<code>推荐先更新数据库，再更新缓存</code></p><h3 id="保证操作原子性"><a href="#保证操作原子性" class="headerlink" title="保证操作原子性"></a>保证操作原子性</h3><p>操作数据库和操作缓存其实是两个操作，前面的所有分析都是建立在这两个操作都能同时执行成功，只要出现一个执行成功，一个执行失败的情况，就会造成数据库和缓存数据不一致的问题，会对敏感业务造成影响。下面就是两种解决方案.</p><h4 id="队列-重试机制"><a href="#队列-重试机制" class="headerlink" title="队列+重试机制"></a>队列+重试机制</h4><p><img src="https://pb01.s3.bitiful.net/158.png" alt="avatar"></p><ul><li>更新数据库数据；</li><li>缓存因为种种问题删除失败</li><li>将需要删除的key发送至消息队列</li><li>自己消费消息，获得需要删除的key</li><li>继续重试删除操作，直到成功</li></ul><p>该方案有一个缺点，会对业务线代码造成大量的侵入。</p><h4 id="基于订阅binlog的同步机制"><a href="#基于订阅binlog的同步机制" class="headerlink" title="基于订阅binlog的同步机制"></a>基于订阅binlog的同步机制</h4><p><img src="https://pb01.s3.bitiful.net/159.png" alt="avatar"></p><p>本方案启动一个订阅程序去订阅数据库的binlog，获得需要操作的数据。在应用程序中，另起一段程序，获得这个订阅程序传来的信息，进行删除缓存操作。关键是使用canal框架订阅binlog</p><ul><li><p>要开启mysql的binlog，需要设置binlog_format为ROW模式，并且设置server_id，保证唯一性。修改my.cnf配置文件，重启mysql服务。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">log-bin=mysql-bin # 开启 binlog</span><br><span class="line">binlog-format=ROW # 选择 ROW 模式</span><br><span class="line">server_id=1 # 配置 MySQL replaction 需要定义，不要和 canal 的 slaveId 重复</span><br></pre></td></tr></table></figure></li><li><p>查看是否修改 Binlog 成功。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看 binlog 日志是否开启</span></span><br><span class="line">show variables like &#x27;log_%&#x27;;</span><br></pre></td></tr></table></figure></li><li><p>MySQL 执行 SQL 语句创建 canal 单独使用的账号，用来进行 Binlog 的同步和监听</p></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> canal IDENTIFIED <span class="keyword">BY</span> <span class="string">&#x27;canal&#x27;</span>;  </span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">SELECT</span>, REPLICATION SLAVE, REPLICATION CLIENT <span class="keyword">ON</span> <span class="operator">*</span>.<span class="operator">*</span> <span class="keyword">TO</span> <span class="string">&#x27;canal&#x27;</span>@<span class="string">&#x27;%&#x27;</span>;</span><br><span class="line">FLUSH PRIVILEGES;</span><br></pre></td></tr></table></figure><h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference:"></a>Reference:</h4><ol><li><a href="https://coolshell.cn/articles/17416.html" style="color: #177cb0; text-decoration: underline;text-decoration-style: dotted;">缓存更新的套路</a></li><li>Java全栈知识体系</li></ol>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>海外访问阿里云服务器失败</title>
      <link href="/2024/03/04/2024-3-4-%E6%B5%B7%E5%A4%96%E8%AE%BF%E9%97%AE%E9%98%BF%E9%87%8C%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%A4%B1%E8%B4%A5/"/>
      <url>/2024/03/04/2024-3-4-%E6%B5%B7%E5%A4%96%E8%AE%BF%E9%97%AE%E9%98%BF%E9%87%8C%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%A4%B1%E8%B4%A5/</url>
      
        <content type="html"><![CDATA[<h3 id="海外访问阿里云服务器失败"><a href="#海外访问阿里云服务器失败" class="headerlink" title="海外访问阿里云服务器失败"></a>海外访问阿里云服务器失败</h3><p>由于我的图床是挂在github上,然后使用cloudflare的CDN加速,但在国内访问时,图片的加载速度仍然较慢,所以我经常使用魔法访问已获得更好的体验。但我发现,最近使用魔法访问时,我无法访问到我的网站。我去检查了下,安全组规则配置是没问题的,那么原因很可能就出现在防火墙上.</p><p>我去检查了下,发现我的服务器根本就没开防火墙,这是一个很奇怪的事,没开就不应该有问题啊.然后我尝试将防火墙打开,开放80和443端口,重启防火墙,然后就可以成功访问了.</p><p>步骤如下:</p><h4 id="查看防火墙状态"><a href="#查看防火墙状态" class="headerlink" title="查看防火墙状态:"></a>查看防火墙状态:</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl status firewalld</span><br></pre></td></tr></table></figure><h4 id="打开防火墙"><a href="#打开防火墙" class="headerlink" title="打开防火墙"></a>打开防火墙</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl start firewalld</span><br></pre></td></tr></table></figure><h4 id="查看已开放的端口"><a href="#查看已开放的端口" class="headerlink" title="查看已开放的端口"></a>查看已开放的端口</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --list-ports</span><br></pre></td></tr></table></figure><h4 id="打开80和443端口"><a href="#打开80和443端口" class="headerlink" title="打开80和443端口"></a>打开80和443端口</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --zone=public --add-port=80/tcp --permanent</span><br><span class="line">firewall-cmd --zone=public --add-port=443/tcp --permanent</span><br></pre></td></tr></table></figure><h4 id="重启防火墙"><a href="#重启防火墙" class="headerlink" title="重启防火墙"></a>重启防火墙</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --reload</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> blog </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库分库分表</title>
      <link href="/2024/03/02/2024-3-2-%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/"/>
      <url>/2024/03/02/2024-3-2-%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="数据库分库分表"><a href="#数据库分库分表" class="headerlink" title="数据库分库分表"></a>数据库分库分表</h2><h3 id="分库分表到底是什么"><a href="#分库分表到底是什么" class="headerlink" title="分库分表到底是什么"></a>分库分表到底是什么</h3><p>分库分表其实是分库,分表,分库分表的总称</p><h4 id="分库"><a href="#分库" class="headerlink" title="分库"></a>分库</h4><p>将数据按照一定规则存储到不同的数据库中,每个数据库存储一部分数据</p><p><code>分库主要解决的是并发量过大的问题</code>，并发量一旦上升，那么数据库就可能成为系统的瓶颈，因为数据库的连接数量是有上限的，虽然可以进行调整，但并不是无限调整的。所以，当数据库的读或者写的 QPS(每秒查询数) 太高，从而导致你的数据库连接数量不足的时候，就需要考虑到分库了，通过在增加数据库实例的方式来提供更多的数据库连接，从而提升系统的并发度。<br>这里拿一个电商系统的数据库来举例，当你微服务在做服务拆分的时候，你会按照功能模块去把你的系统进行服务拆分，这个时候，就需要将每个模块的数据从一个单独的数据库中拆开，分成订单、物流、商品、用户等多个数据库，然后随着业务的发展，每个单独的业务数据库也需要进行分库了，如下图所是。</p><p><img src="https://pb01.s3.bitiful.net/154.png" alt="avatar"></p><h4 id="分表"><a href="#分表" class="headerlink" title="分表"></a>分表</h4><p>将一张表按照一定规则拆分成多张表,每张表存储一部分数据</p><p><code>相比较于分库，分表主要解决的是数据量大的问题</code>，即通过将数据拆分到多个表，减少单表的数据量，从而提升查询速度。</p><h4 id="分库分表"><a href="#分库分表" class="headerlink" title="分库分表"></a>分库分表</h4><p>这一般发生在数据库连接不够（分库解决的问题）以及单表数据量过大导致查询速度比较慢（分表解决的问题）这两个问题共同存在的时候，不过在分库分表之前，可以先考虑一下能不能优化先。</p><p>一般来说，单表的行数如果超过了 1000 万行之后，就需要考虑做分库分表了，小于这个数据量的时候，遇到性能问题可以通过其他方式来进行优化。但其实这么说是不准确的,需要根据表字段数量、表中数据数量以及业务的具体情况来综合考虑,无法给出一个确切的值.</p><ul><li><strong>常⻅的优化手段</strong></li></ul><ol><li>数据库的基本优化：做好索引、减少多表 join、减少冗余字段</li><li>减少数据库压力：在数据库之前加一层缓存，把一些可以接受延迟的，以及数据库变化频率较低的内容放到本地缓存或者分布式缓存当中。</li><li>冷热数据的隔离：即数据归档，可以将一些更新以及不经常使用的数据单独隔离出来，可以放到历史表或者离线数仓当中，减少表中的数据量来提升效率</li><li>数据库分区：数据库分区之后，将数据存储在不同的表当中，尽量减少单表的数据量，提升查询性能。</li><li>分布式数据库：将数据分散到多个节点上，提升容量</li></ol><h4 id="分区和分表的区别"><a href="#分区和分表的区别" class="headerlink" title="分区和分表的区别"></a>分区和分表的区别</h4><p>我们上面提过一个点，就是在数据库中，如果数据量比较大的话，优先考虑的是如何对数据进行优化，而不是进行分库分表，我们在优化里面提到了一个点，就是对数据实现分区操作，那么这个过程要怎么理解呢？以及这两个过程有什么区别？</p><p>首先我们先说一个点，就是分区和分表相同的点，都是按照一定的规则，对一张数据量特别大的表进行分解，使得表的数据量减少，从而提高查询效率。这样听起来你可能感觉没差多少，因为两者的区别都是把表进行拆分，那具体有什么差别吗？主要就是分区和分表后数据的存储方式发生了变化。</p><p>这个要从 MySQL 的索引说起，在 Innodb 中（8.0之前），表存储主要依赖两个文件，分别是 .frm 文件和.ibd 文件。.frm文件用于存储表结构定义信息，而.ibd文件则用于存储表数据。</p><p>拿order表来举例,分区存储时会在 MySQL 的 data 目录下创建一个用户名+表名+分区名.ibd 的文件（如：order_p1.ibd），用来存储 order 表中第一个分区的数据，同样会有 order_p2.ibd 和order_p3.ibd 来存储第二和第三个分区的数据：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">order_p1.ibd</span><br><span class="line">order_p2.ibd</span><br><span class="line">order_p3.ibd</span><br><span class="line">order.frm</span><br></pre></td></tr></table></figure><p>分表存储的时候会在 MySQL 的 Data 目录下创建一个后缀为 .frm，名字为”order_1.frm”的表格文件，存储 order表中第一个分表的数据，同样会有另外的 order_2.frm 和order_3.frm 来存储第二个和第三个分表的数据:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">order_1.ibd</span><br><span class="line">order_1.frm</span><br><span class="line">order_2.ibd</span><br><span class="line">order_2.frm</span><br><span class="line">order_3.ibd</span><br><span class="line">order_3.frm</span><br></pre></td></tr></table></figure><p><code>所以简单来说,两者的区别是:</code></p><ul><li>数据在做了分区后，表面是还是只有一张表，只不过数据保存在不同的位置上了（同一个.frm文件），在做数据读取的时候操作的表名还是users表，数据库会自己去组织各个分区的数据。</li><li>数据在进行了分表后，不管是表面上还是实际上，都已经不是同一张表了，其分成了多张表（多个.frm 文件 ）。所以数据库在进行操作的时候需要去指定对应的表名</li></ul><h3 id="如何分库分表"><a href="#如何分库分表" class="headerlink" title="如何分库分表"></a>如何分库分表</h3><p>分库和分表都有两种拆分方式，一种是垂直拆分，一种是水平拆分。</p><h4 id="垂直拆分"><a href="#垂直拆分" class="headerlink" title="垂直拆分"></a>垂直拆分</h4><p>垂直拆分就是通过将数据库表中的字段减少，然后数据的行数不变，列数减少，来使得每个表中的数据量下降.比如之前提到的电商数据库,将其拆分为订单数据库,商品数据库,用户数据库等,这就属于垂直拆分.如果将用户表常用信息分为用户主表,不常用信息分为用户扩展表,就是表的垂直拆分.垂直拆分主要是根据<code>业务</code>来决定的,不同的业务有着不同的拆分方案.</p><h4 id="水平拆分"><a href="#水平拆分" class="headerlink" title="水平拆分"></a>水平拆分</h4><p>水平拆分就是将数据库中的表数据分散到多个表中，即数据表中列数不变，行数减少，来使得每个表中的数据量下降.水平拆分的<code>关键</code>在于<strong>分片键的选择</strong>,分片键是用于将数据库（表）水平拆分的数据库字段,它直接影响了分库分表的性能和可扩展性。以下是一些选择分片键的关键因素：</p><ul><li>选择一个<code>尽量均匀</code>的分片键，这样可以使得数据尽量均匀的分布到各个数据库中,避免出现热点数据集中在某个分片上的情况。</li><li>选择一个<code>尽量唯一</code>的分片键，这样可以避免数据重复，提高数据的唯一性。</li><li>选择一个<code>尽量不变</code>的分片键，这样可以避免对拆分结果的多次修改，提高系统的稳定性和可维护性。</li><li>选择分片键还应考虑数据的访问频率。将经常访问的数据放在同一个分片上，可以提高查询性能和降低跨分片查询的开销。</li></ul><h4 id="常见的水平拆分算法"><a href="#常见的水平拆分算法" class="headerlink" title="常见的水平拆分算法"></a>常见的水平拆分算法</h4><h5 id="哈希取模-HASH-MOD"><a href="#哈希取模-HASH-MOD" class="headerlink" title="哈希取模(HASH_MOD)"></a>哈希取模(HASH_MOD)</h5><p>这是最常用的水平拆分算法，它通过将分片键的哈希值对分片数量取模，来确定数据应该存储的分片。哈希值可能出现负数,要先对其求绝对值之后再取模,下面是ShardingSphere中HASH_MOD算法的实现:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">HashModShardingAlgorithm</span> <span class="keyword">implements</span> <span class="title class_">StandardShardingAlgorithm</span>&lt;Comparable&lt;?&gt;&gt;, ShardingAutoTableAlgorithm &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">SHARDING_COUNT_KEY</span> <span class="operator">=</span> <span class="string">&quot;sharding-count&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> shardingCount;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(<span class="keyword">final</span> Properties props)</span> &#123;</span><br><span class="line">        shardingCount = getShardingCount(props);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">getShardingCount</span><span class="params">(<span class="keyword">final</span> Properties props)</span> &#123;</span><br><span class="line">        ShardingSpherePreconditions.checkState(props.containsKey(SHARDING_COUNT_KEY), () -&gt; <span class="keyword">new</span> <span class="title class_">ShardingAlgorithmInitializationException</span>(getType(), <span class="string">&quot;Sharding count cannot be null.&quot;</span>));</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> Integer.parseInt(String.valueOf(props.getProperty(SHARDING_COUNT_KEY)));</span><br><span class="line">        ShardingSpherePreconditions.checkState(result &gt; <span class="number">0</span>, () -&gt; <span class="keyword">new</span> <span class="title class_">ShardingAlgorithmInitializationException</span>(getType(), <span class="string">&quot;Sharding count must be a positive integer.&quot;</span>));</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">doSharding</span><span class="params">(<span class="keyword">final</span> Collection&lt;String&gt; availableTargetNames, <span class="keyword">final</span> PreciseShardingValue&lt;Comparable&lt;?&gt;&gt; shardingValue)</span> &#123;</span><br><span class="line">        ShardingSpherePreconditions.checkNotNull(shardingValue.getValue(), NullShardingValueException::<span class="keyword">new</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">suffix</span> <span class="operator">=</span> String.valueOf(hashShardingValue(shardingValue.getValue()) % shardingCount);</span><br><span class="line">        <span class="keyword">return</span> ShardingAutoTableAlgorithmUtils.findMatchedTargetName(availableTargetNames, suffix, shardingValue.getDataNodeInfo()).orElse(<span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Collection&lt;String&gt; <span class="title function_">doSharding</span><span class="params">(<span class="keyword">final</span> Collection&lt;String&gt; availableTargetNames, <span class="keyword">final</span> RangeShardingValue&lt;Comparable&lt;?&gt;&gt; shardingValue)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> availableTargetNames;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> <span class="title function_">hashShardingValue</span><span class="params">(<span class="keyword">final</span> Object shardingValue)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Math.abs((<span class="type">long</span>) shardingValue.hashCode());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAutoTablesAmount</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> shardingCount;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getType</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;HASH_MOD&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="一致性哈希算法"><a href="#一致性哈希算法" class="headerlink" title="一致性哈希算法"></a>一致性哈希算法</h5><p>我们在做分库分表的时候，最开始根据业务分析，只需要 128 张表就可以满足数据量的要求了，但是随着业务的扩展，128 张表可能已经不够用了，这个时候就需要重新分表了，比如增加一张新的表，这个时候如果采用 Hash取模的方式，就会导致 128 + 1 张表的数据需要重新进行分配，成本非常高。而一致性哈希算法就是专门解决这类问题的算法，其可以有效地解决分布式系统中增加或者删除节点时的失效问题。</p><p>实现一致性哈希算法首先需要构造一个<strong>哈希环</strong>，然后划分固定数量的虚拟节点，一般都是 2的32次方。接下来将128张表作为节点映射到这些虚拟节点上，每个节点在哈希环上面都有一个对应的虚拟节点。然后我们就需要存储数据了，现在我们要把分片键也根据同样的算法进行 Hash，并且也将其映射到哈希环上面。经过以上步骤，在这个 Hash 环上面的虚拟节点就包含两部分数据的映射了，一部分是存储数据的分表的映射，一部分是真实要存储的数据的映射。</p><p>我们最终目的是将这些数据存储到数据库分表中，那么做好哈希之后，这些数据又要保存在哪个数据库表节点中呢？这个其实很简单，就是按照数据的位置，沿着顺时针的方向进行查找，找到的第一个数据库表节点就是数据要存放的数据库表节点。</p><p>回到开头的问题,我们要添加第129张表,只要将第129张表的虚拟节点映射到哈希环上,然后将数据重新分配即可,这样只会影响到哈希环上新增节点顺时针旋转的<strong>下一个节点的数据</strong>,而不会影响到其他节点。</p><p><strong>一致性哈希算法的优缺点：</strong></p><p><code>优点:</code></p><ul><li>数据均衡：在增加或者删除节点的时候，一致性哈希算法只会影响到少量的数据迁移，保持了数据的均衡性。</li><li>高扩展性：当节点数目发生变化的时候，对于已经存在的数据，只有部分数据需要重新分布，不会影响到整体的数据结构。</li></ul><p><code>缺点:</code></p><ul><li>Hash 倾斜：在节点数较少的情况下，由于哈希空间是有限的，节点的分布可能不够均匀，导致数据倾斜。</li><li>节点的频繁变更： 如果频繁添加或删除节点，可能会导致大量的数据迁移，从而造成系统压力。</li></ul><p><strong>Hash 倾斜的解决方案:</strong></p><ol><li><p>力大砖飞,增加节点,尽可能地分散节点，使得数据分布较为均匀,但这不太现实,因为有这个条件也就不会出现 Hash 倾斜的问题了。</p></li><li><p>引入虚拟节点,即我们将一个服务器节点拆分成多个虚拟节点，然后数据在映射的时候先将数据映射到虚拟节点上，然后虚拟节点在对应的物理节点进行存储和读取就可以了，有了虚拟节点的接入，数据在分布的时候就会尽可能地分散，然后在增加或者减少服务器数量的时候，受到影响的数据范围也不会有那么多。</p></li></ol><h5 id="其他算法"><a href="#其他算法" class="headerlink" title="其他算法"></a>其他算法</h5><p>ShardingSphere的分片算法还有如下图这些:</p><p><img src="https://pb01.s3.bitiful.net/155.png" alt="avatar"></p><h3 id="分表之后的全局-ID-如何保证全局唯一性？"><a href="#分表之后的全局-ID-如何保证全局唯一性？" class="headerlink" title="分表之后的全局 ID 如何保证全局唯一性？"></a>分表之后的全局 ID 如何保证全局唯一性？</h3><p>我们在单表中可以采用数据库主键来做唯一的 ID，但是如果使用了分库分表的形式，那么多张单表中的自增主键就一定会发生冲突，那这样的话你生成的ID 就不具备全局唯一性了</p><h4 id="UUID"><a href="#UUID" class="headerlink" title="UUID"></a>UUID</h4><p>UUID是可以做到全局唯一性的，而且生成方式也很简单，而且性能很高，不依赖于网络，使用起来也比较方便。但是我们通常不使用他作为唯一 ID，主要原因有两个：</p><ol><li>UUID 太⻓了，它有 32 位 16进制的数字，且字符串的查询效率也比较慢，在作为分布式 ID 查询的时候存在查询效率较低，不适合范围查询以及不方便展示等问题。</li><li><strong>不具有业务性</strong>，标准的 UUID 格式为：xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx (8-4-4-4-12)，一共32个字符，这个时候我们随便举一个例子，“340a3413-b8a2-c1e6-f922-895398142390”,对于这个字符串来说，很难看出其表达的含义，如果使用其作为全局唯一标识，在分布式系统中，很难进行问题的排查以及开发过程中的调试，所以我们一般不考虑 UUID 作为全局唯一标识</li></ol><h4 id="基于某个单表做自增主键"><a href="#基于某个单表做自增主键" class="headerlink" title="基于某个单表做自增主键"></a>基于某个单表做自增主键</h4><p>利用一个表来存放自增 ID ，然后所有的表在需要主键的时候来这张表里面取就可以了，这样做就可以实现全局唯一，还实现了自增效果，一举两得。这样不否定，确实可以实现全局唯一而且还能实现自增效果，但是有一个问题，就是<strong>这张单表最终会成为了系统扩展的瓶颈</strong>，而且也存在<strong>单点问题</strong>，一旦这张表有一天突然挂了，那整个数据库的插入不就瘫痪了吗？</p><h4 id="基于多个单表-步⻓做自增主键"><a href="#基于多个单表-步⻓做自增主键" class="headerlink" title="基于多个单表+步⻓做自增主键"></a>基于多个单表+步⻓做自增主键</h4><p>设置起始值和步长,比如table_001起始值为10000,步长为10000,其范围就为10000-19999,table_002起始值为20000,步长为10000,其范围就为20000-29999,以此类推,这样就可以实现全局唯一,而且还能实现自增效果.但是又有了一个新的问题,那就是table_001如果 ID 到了19999 ，这个怎么办？那就重新生成一个起始值：table_001的新起始值为80000,其范围为80000-89999,以此类推.</p><h4 id="雪花算法"><a href="#雪花算法" class="headerlink" title="雪花算法"></a>雪花算法</h4><p>雪花算法是一种比较常⻅的分布式 ID 的生成方式，它具有全局唯一、递增、高可用的特点。它的核心思想就是将一个 64位的ID划分成多个部分，每个部分都有不同的含义，包括时间戳、数据中心标识、机器标识和序列号等。</p><p><img src="https://pb01.s3.bitiful.net/156.png" alt="avatar"></p><p>一般来说，雪花算法生成的 ID 有以下几个部分：</p><ol><li>最高1位固定值0，因为生成的 id 是正整数，如果是1就是负数了。</li><li>接下来41位存储毫秒级时间戳，2^41/(1000606024365)=69，大概可以使用69年。</li><li>再接下10位存储机器码，包括5位 datacenterId 和5位 workerId。最多可以部署2^10=1024台机器。</li><li>最后12位存储序列号。同一毫秒时间戳时，通过这个递增的序列号来区分。即对于同一台机器而言，同一毫秒时间戳下，可以生成2^12=4096个不重复 id。</li></ol><p>可以将雪花算法作为一个单独的服务进行部署，然后需要全局唯一 id 的系统，请求雪花算法服务获取 id 即可。对于每一个雪花算法服务，需要先指定10位的机器码，这个根据自身业务进行设定即可。例如机房号+机器号，机器号+服务号，或者是其他可区别标识的10位比特位的整数值都行。</p><p>当然雪花算法也有其缺点:<strong>依赖服务器时间，服务器时钟回拨时可能会生成重复 id</strong>。算法中可通过记录最后一个生成 id 时的时间戳来解决，每次生成 id 之前比较当前服务器时钟是否被回拨，避免生成重复 id。</p><p>像百度,美团等大厂都在github上开源了自己的分布式ID生成器，有兴趣的可以自行了解。</p><h3 id="分库分表后的查询"><a href="#分库分表后的查询" class="headerlink" title="分库分表后的查询"></a>分库分表后的查询</h3><h4 id="带分片键的查询"><a href="#带分片键的查询" class="headerlink" title="带分片键的查询"></a>带分片键的查询</h4><p>由于带有分片键,我们可以定位到具体的库和表,然后进行查询.</p><h4 id="不带分片键的关键查询"><a href="#不带分片键的关键查询" class="headerlink" title="不带分片键的关键查询"></a>不带分片键的关键查询</h4><p>以电商网站为例，电商网站上不仅有买家，还有卖家，他们的查询也很高频，该怎么做呢？针对卖家查询，一般会采用<strong>空间换时间</strong>的方案，同步出一张按照卖家维度做分表的表来。虽然这种情况下可能存在秒级的延迟，但是一般业务上来说都是可以接受的。也就是说，当一条订单创建出来之后，会在买家表创建一条记录，以买家ID作为分表字段，同时，也会在卖家表创建一条记录出来，用卖家ID进行分表。并且这张卖家表不会做任何写操作，只提供查询服务，完全可以用一些比较廉价的机子去部署数据库实例。这样，卖家的分⻚等查询就可以直连卖家表做查询了。</p><h4 id="不带分片键的聚合查询"><a href="#不带分片键的聚合查询" class="headerlink" title="不带分片键的聚合查询"></a>不带分片键的聚合查询</h4><p>一般来说，大厂用的比较多的方案就是使用分布式数据仓库来实现，也就是说我们会把这些数据同步到像TiDB、PolarDB、HBase等这些数据库中，或者同步到ES中，然后在这些数据库中做数据的聚合查询。</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>博客网站遇到的一些问题</title>
      <link href="/2024/03/01/2024-3-1-%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/"/>
      <url>/2024/03/01/2024-3-1-%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="博客网站遇到的一些问题"><a href="#博客网站遇到的一些问题" class="headerlink" title="博客网站遇到的一些问题"></a>博客网站遇到的一些问题</h2><h3 id="错把版本升级"><a href="#错把版本升级" class="headerlink" title="错把版本升级"></a>错把版本升级</h3><p>最近阿里云显示我的博客网站有漏洞,我便想着去把它给修了,由于经验不足且没有认真看官方的解决方案,我把centos从版本7直接升到了版本8,导致博客网站挂了,服务不可用.由于是大版本升级,而且之前也错误升级了一些东西,于是我选择了重置环境然后重新部署.事后想了一下,主要问题有两点:</p><ol><li>没有仔细看官方的解决方案,使用了更宽范围的update命令,导致centos和一些组件错误升级,从而导致博客网站无法正常访问.</li><li>没有备份手段,阿里云其实提供了快照,但我以为自己不会用上,而且能省一笔钱,也就没开通</li></ol><p>阿里云重置环境的方法:</p><ol><li><p>停止云服务器<br><img src="https://pb01.s3.bitiful.net/144.png" alt="avatar"></p></li><li><p>找到更换操作系统选项,选择更换系统盘<br><img src="https://pb01.s3.bitiful.net/145.png" alt="avatar"></p></li><li><p>对系统盘做初始设置<br><img src="https://pb01.s3.bitiful.net/146.png" alt="avatar"></p></li></ol><h3 id="博客网站无法正常访问"><a href="#博客网站无法正常访问" class="headerlink" title="博客网站无法正常访问"></a>博客网站无法正常访问</h3><p>这个问题在于浏览器,我一直没有给我的网站配置SSL证书,所以一直用的是http协议,现在edge浏览器和chrome浏览器已经强制将http转换为https,导致我的网站无法正常访问.解决方案有如下两种:</p><h4 id="1-更改HSTS"><a href="#1-更改HSTS" class="headerlink" title="1.更改HSTS"></a>1.更改HSTS</h4><p>在edge浏览器中,输入edge://net-internals/#hsts,在Delete domain sercurity policies中输入项目的域名，并Delete,然后重新访问网站即可.chrome浏览器输入chrome://net-internals/#hsts即可.</p><p><img src="https://pb01.s3.bitiful.net/147.png" alt="avatar"></p><h4 id="2-配置SSL证书"><a href="#2-配置SSL证书" class="headerlink" title="2.配置SSL证书"></a>2.配置SSL证书</h4><p>之前没配置SSL证书的原因是觉得没必要,本身网站访问量不大,能用就行,现在随着浏览器安全策略的升级,也就不得不配置了.</p><ol><li>购买SSL证书<br>由于阿里云现在的免费证书只提供三个月,所以我选择了68元一年的证书</li></ol><p><img src="https://pb01.s3.bitiful.net/148.png" alt="avatar"></p><ol><li><p>配置DNS解析<br>根据SSL证书提供的信息添加一条记录,以便通过验证,当然如果服务器,域名都是阿里云的,它会为你自动添加,但会有点慢.<br><img src="https://pb01.s3.bitiful.net/153.png" alt="avatar"></p></li><li><p>证书下载<br>我是下载Nginx的证书<br><img src="https://pb01.s3.bitiful.net/150.png" alt="avatar"><br>然后将下载下来的key和pem文件上传到服务器上,可以不按我的操作来<br><img src="https://pb01.s3.bitiful.net/149.png" alt="avatar"></p></li></ol><p>我的操作如下:在服务器新建一个SSL文件夹，将两个文件上传。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /home/</span><br><span class="line"><span class="built_in">mkdir</span> SSL</span><br></pre></td></tr></table></figure></p><ol><li>配置nginx<br>这里需要修改nginx.conf文件,添加https协议的配置<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /etc/nginx/</span><br><span class="line">vim nginx.conf</span><br></pre></td></tr></table></figure></li></ol><p>进入后找到server块,监听443端口的那个,80的那个是http协议的配置,可以注释掉,也可以保留(<strong>记得检查443端口是否打开</strong>).<br><img src="https://pb01.s3.bitiful.net/151.png" alt="avatar"></p><p>将其取消注释,将root改为博客根目录,把pem文件和key替换上去,如果下载的不是Nginx的证书,可能需要修改一下,自己注意就好<br><img src="https://pb01.s3.bitiful.net/152.png" alt="avatar"></p><ol><li><p>重启Nginx服务</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart nginx.service</span><br></pre></td></tr></table></figure><p>看Nginx服务是否正常启动</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl status nginx.service</span><br></pre></td></tr></table></figure></li><li><p>查看是否成功<br>使用https协议访问你的网站,如果出现了锁的标识,就代表配置成功.</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> blog </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IELTS优秀小作文分享</title>
      <link href="/2024/02/29/2024-2-29-IELTS%E5%B0%8F%E4%BD%9C%E6%96%87%E5%88%86%E4%BA%AB/"/>
      <url>/2024/02/29/2024-2-29-IELTS%E5%B0%8F%E4%BD%9C%E6%96%87%E5%88%86%E4%BA%AB/</url>
      
        <content type="html"><![CDATA[<h3 id="IELTS优秀小作文分享"><a href="#IELTS优秀小作文分享" class="headerlink" title="IELTS优秀小作文分享"></a>IELTS优秀小作文分享</h3><h4 id="柱状图"><a href="#柱状图" class="headerlink" title="柱状图"></a>柱状图</h4><p>本篇范文个人评分是8分或者8.5分，属于能找到的最优质的范文了</p><p><strong>题目如下</strong>:<br><img src="https://pb01.s3.bitiful.net/122.jpg" alt="avatar"></p><p>The two sets of bar charts illustrate the amount of time that teenagers (boys, girls, and all) in the UK spend chatting online and playing game consoles on a typical school day.</p><p>The first set of data shows the behavioral patterns of chatting on the internet: on average, about 25% of teenager students, including both boys and girls, spend less than one hour, around 30% between one to three, and approximately 6% more than four hours. As for the two gender groups, while a slightly larger proportion of girls tend to spend more daily time chatting online, the data are still comparable to that of the boys.</p><p>In comparison, game consoles is a totally different story as the behavioral pattens are significantly different between the two gender groups. About 30% of the boys and more than a third of the girls spend less than one hour on games, while almost half of the boys and only 12% of girls spend between one to three hours. Last but not least, 10% of the boys and almost no girls spend more than four hours of their daily time on games. It is also worth noticing that the “All” group simply reflects the average of the two genders but does not seem to be an accurate representation of either.</p><p>In conclusion, boys and girls behave slightly differently when chatting online, but significantly differently when it comes to playing game consoles.</p><h4 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h4><p>剑桥雅思7的Test 1里的小作文</p><p><img src="https://pb01.s3.bitiful.net/160.png" alt="avatar"></p><p>这一篇是Simon书里的范文, 我稍微做了点改变, 他说他的范文能得9分, 但我感觉这样的文章放到考试最多7.5, 大概率6.5/7</p><p>The table shows percentages of consumer expenditure for three categories of products and services in five countries in 2002.</p><p>It is clear that the largest proportion of consumer spending in each country went on food, drinks and tobacco.    On the other hand, the leisure/education category has the lowest percentages in the table.</p><p>Among the five countries, consumer spending on food, drinks and tobacco was noticeably the highest in Turkey, at 32.14% and Ireland spent the second highest amount, less than 30%.   The proportion of spending on leisure and education was also highest in Turkey, at 4.35%, while expenditure on clothing and footwear was significantly higher in Italy, at 9%, than in any of the other countries.</p><p>It can be seen that Sweden had the lowest percentage of national consumer expenditure for food/drinks/tobacco and for clothing/footwear, at nearly 16% and just over 5% respectively.    Spain had slightly higher figures for these categories, but the lowest figure for leisure/education, at only 1.98%.</p><p>这篇的思路是从类别来分析,上面那篇从国家来分析,视角不同,这篇大约6/6.5</p><p>The table compares 5 distinctive countries with regard to their citizens’ expenditure on Food/Drinks/Tobacco, Clothing/Footwear and Leisure/ Education in the year of 2002.</p><p>Overall, it can be seen that consumers in the five nations spent more on Food/Drinks/Tobacco than the other categories. It is also noticeable that Leisure/ Education took up the least proportion in 2002.</p><p>In terms of the expenditure on Food/Drinks/Tobacco, Turkish consumers ranked the first with a percentage of 32.14% in 2002, followed by individuals from Ireland (28.91%) and Spain (18.80%). By contrast, citizens in Italy and Sweden spent less money on this category, respectively 16.36% and 15.77%.</p><p>When it comes to Clothing/Footwear, the figure for Italy was 9%, significantly higher than its counterparts, which represented merely around 6%. Moreover, the spending on Leisure/ Education accounted for the least percentage in these categories. The largest amount, namely 4.35% could be found for Turkey, which was more than twice as high as the figure for Spain(1.98%). The rate of Sweden, Italy and Ireland lied separately in 3.22%, 3.20% and 2.21%.</p><h4 id="饼图"><a href="#饼图" class="headerlink" title="饼图"></a>饼图</h4><p>C14 Test 1,个人觉得这篇写得非常标准,所以应该有6.5-7.0的水准吧</p><p><img src="https://pb01.s3.bitiful.net/161.png" alt="avatar"></p><p>The pie charts compare three types of nutrients, namely sodium, saturated fat and added sugar with regard to their average proportions in Americans’ meals.</p><p>Overall, it can be seen that breakfast contains the lowest rate of all the three nutrients. It is also noticeable that dinner occupies the highest rate of both sodium and saturated fat, while snacks contain more added sugar than their counterparts.</p><p>In terms of sodium and saturated fat, dinner makes up the highest percentage (43% and 37% respectively) and by contrast, the figure for breakfast remains the lowest being 14% and 16% separately. Apart from that, snacks also contain the lowest proportion of sodium as breakfast both representing 14% but its percentage of saturated fat reaches 21%.</p><p>When it comes to added sugar, snacks make up the largest proportion of 42%, followed by dinner and lunch (23% and 19% for each). In breakfast, individuals in the USA take in the lowest amount of added sugar, accounting for only 16% among three meals and snacks.</p><h4 id="柱状图-1"><a href="#柱状图-1" class="headerlink" title="柱状图"></a>柱状图</h4><p>分数应该是8分</p><p><img src="https://pb01.s3.bitiful.net/162.png" alt="avatar"></p><p>The bar chat presents the number of research students, divided by gender, who pursed different subjects in 2005. These subjects included linguistics, psychology, natural sciences, engineering, programming and mathematics.</p><p>Overall, there were more male than female research student in the given year. Among all subjects, male students had a higher enrollment than female students except for linguistics. Although both genders took a strong interset in psychology and natural sciences, two of the most popular subjects, men least preferred linguists and women mathematics.</p><p>Female and male students showed a more or less similar interest in linguistics, psychology and natural sciences. In particular, natural sciences was the most popular of all, showing the same enrollment number of 200. Through very popular, psychology was favored more by men (200) than women (around 170). In linguistics, the situation was the reverse, with more women than men.</p><p>However, female and male students showed significant differences in engineering, programming and mathematics. In all three subject, male domiance was obvious, especially in mathematics, which was taken by 200 males students and only 40 female students in engineering and programming, the number of female syudents was roughly half of that of male.</p><h4 id="折线图"><a href="#折线图" class="headerlink" title="折线图"></a>折线图</h4><p>8分左右</p><p><img src="https://pb01.s3.bitiful.net/163.png" alt="avatar"></p><p>The line chart illustrates avrage carbon dioxide (CO2) emissions per capita in the UK, Sweden, Italy and Portugal over 40 years from 1967 to 2007. Units were measured in metric tonnes.</p><p>On the whole, the UK and Sweden showed a general decreasing trend in terms of CO2 emissions while Italy and Portugal both witnessed a stedy rising trend. Throughout this prise, the UK had the highest CO2 emissions, while Portugal remained the lowest.</p><p>In 1967, the highest CO2 emission were in the UK, at around 11, following by Sweden at appromately 9. Italy and Portugal had relatively lower emissions, at around 4 and 1 respectively. Around 1987, CO2 emissions per capita in the UK steadily droped to 10, still being the highest. In Sweden, despite the short initial increse to above 10, CO2 emissions later dropped to around 7, which was the same as those in Italy, whichh had witnessed an increase. At the same time, the average emissions of CO2 climbed to arround 3 in Portugal, remaining the lowest.</p><p>In2007, CO2 emissions continued falling in the UK, now at around 9, albeit still the highest among the four countries. Co2 emissions in Italy had been the second highest. The falling trend of CO2 emissions in Sweden continued, meeting those in Portugal at around 5.</p><h4 id="地图"><a href="#地图" class="headerlink" title="地图"></a>地图</h4><p>C18T3  6.5+的分数</p><p>From the two diagrams provided, we can observe the changes in room layouts at the Central Library over a period of twenty years. In the past 20 years, there have been not only changes in regional functions, but also fundamental adjustments in layout.</p><p>Firstly, the room located in the top-left corner has increased in size. Previously, this room was arranged for CDs, videos and computer games, but nowadays, it is furnished with children’s fiction books. Moreover, there are two sofas, which could provide a comfortable space for holding storytelling activities. The room in the bottom-left corner used to be a space for people to read newspapers and magazines. Nowadays, it is a computer room. Additionally, its door orientation has also been changed. In the middle area, the category of books has changed from adult fiction books to reference books.</p><p>Next, regarding the room in the top-right corner, previously it stored children’s books. However, this function has been replaced by the room on the left and it serves as a lecture room currently. The area in the bottom-right corner was previously an enquiry desk, which provides services related to tickets, book returns and so forth, but now it has been transformed into a Cafe. In the area between those two areas mentioned above, adult fiction books, information desk and self-service machines have replaced adult non-fiction books in the past.</p><p>Finally, in terms of the central area, it previously contained tables and chairs, providing convenience for people to read. However, they have now been removed, making the library appear more spacious.</p><h4 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h4><p>C16T2  7分</p><p>The diagram sheds light on how sugar is manufactured from sugar canes.</p><p>Overall, it can be seen that the whole process consists of 7 steps, from the initial growing stage to the eventual drying and cooling stage.</p><p>The first step begins with growing sugar canes, which lasts for 12 to 18 months and is the longest stage in the whole process. Subsequently, the mature sugar canes are harvested in two means, either by hand or with the help of specialized vehicles and after that, these sugar canes are crushed into juice by certain professional machine.</p><p>The fourth step involves the purification of the juice utilizing limestone filters. Afterwards the purified juice is evaporated thanks to the heat under the machine and converts into syrup. In the next stage, sugar crystals are separated from syrup, after which these crystals are dried and cooled and eventually, sugar is produced from sugar canes.</p>]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IELTS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hutool：一行代码搞定数据脱敏 | 京东云技术团队</title>
      <link href="/2024/02/26/%E6%95%B0%E6%8D%AE%E8%84%B1%E6%95%8F/"/>
      <url>/2024/02/26/%E6%95%B0%E6%8D%AE%E8%84%B1%E6%95%8F/</url>
      
        <content type="html"><![CDATA[<h4 id="声明-本文转载自Hutool：一行代码搞定数据脱敏-京东云技术团队"><a href="#声明-本文转载自Hutool：一行代码搞定数据脱敏-京东云技术团队" class="headerlink" title="声明:本文转载自Hutool：一行代码搞定数据脱敏 | 京东云技术团队"></a>声明:本文转载自<a href="https://segmentfault.com/a/1190000044102356" style="color: #177cb0; text-decoration: underline;text-decoration-style: dotted;">Hutool：一行代码搞定数据脱敏 | 京东云技术团队</a></h4><h1 id="Hutool：一行代码搞定数据脱敏-京东云技术团队"><a href="#Hutool：一行代码搞定数据脱敏-京东云技术团队" class="headerlink" title="Hutool：一行代码搞定数据脱敏 | 京东云技术团队"></a>Hutool：一行代码搞定数据脱敏 | 京东云技术团队</h1><h2 id="1-什么是数据脱敏"><a href="#1-什么是数据脱敏" class="headerlink" title="1. 什么是数据脱敏"></a>1. 什么是数据脱敏</h2><h3 id="1-1-数据脱敏的定义"><a href="#1-1-数据脱敏的定义" class="headerlink" title="1.1 数据脱敏的定义"></a>1.1 数据脱敏的定义</h3><p>数据脱敏百度百科中是这样定义的：</p><p>数据脱敏，指对某些敏感信息通过脱敏规则进行数据的变形，实现敏感隐私数据的可靠保护。这样就可以在开发、测试和其它非生产环境以及外包环境中安全地使用脱敏后的真实数据集。在涉及客户安全数据或者一些商业性敏感数据的情况下，在不违反系统规则条件下，对真实数据进行改造并提供测试使用，如身份证号、手机号、卡号、客户号等个人信息都需要进行数据脱敏。是数据库安全技术之一。</p><p>总的来说，数据脱敏是指对某些敏感信息通过脱敏规则进行数据的变形，实现敏感隐私数据的可靠保护。</p><p>在数据脱敏过程中，通常会采用不同的算法和技术，以根据不同的需求和场景对数据进行处理。例如，对于身份证号码，可以使用掩码算法（masking）将前几位数字保留，其他位用“X”或”*“代替；对于姓名，可以使用伪造（pseudonymization）算法，将真实姓名替换成随机生成的假名。</p><h3 id="1-2-常用脱敏规则"><a href="#1-2-常用脱敏规则" class="headerlink" title="1.2 常用脱敏规则"></a>1.2 常用脱敏规则</h3><p>替换、重排、加密、截断、掩码</p><h2 id="2-Hutool工具介绍"><a href="#2-Hutool工具介绍" class="headerlink" title="2. Hutool工具介绍"></a>2. Hutool工具介绍</h2><h3 id="2-1-引入Maven配置"><a href="#2-1-引入Maven配置" class="headerlink" title="2.1 引入Maven配置"></a>2.1 引入Maven配置</h3><p>在项目的pom.xml的dependencies中加入以下内容，这里以5.8.16版本为例。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cn.hutool<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hutool\-all<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.8.16<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><br>注意：Hutool 5.x支持JDK8+， 如果你的项目使用JDK7，请使用Hutool 4.x版本。本文使用的数据脱敏工具类只有在5.6+版本以上才提供。</p><h3 id="2-2-Hutool包含的组件"><a href="#2-2-Hutool包含的组件" class="headerlink" title="2.2 Hutool包含的组件"></a>2.2 Hutool包含的组件</h3><p>一个Java基础工具类，对文件、流、加密解密、转码、正则、线程、XML等JDK方法进行封装，组成各种Util工具类，同时提供以下组件：</p><div class="table-container"><table><thead><tr><th>模块</th><th>介绍</th></tr></thead><tbody><tr><td>hutool-aop</td><td>JDK动态代理封装，提供非IOC下的切面支持</td></tr><tr><td>hutool-bloomFilter</td><td>布隆过滤，提供一些Hash算法的布隆过滤</td></tr><tr><td>hutool-cache</td><td>简单缓存实现</td></tr><tr><td>hutool-core</td><td>核心，包括Bean操作、日期、各种Util等</td></tr><tr><td>hutool-cron</td><td>定时任务模块，提供类Crontab表达式的定时任务</td></tr><tr><td>hutool-crypto</td><td>加密解密模块，提供对称、非对称和摘要算法封装</td></tr><tr><td>hutool-db</td><td>JDBC封装后的数据操作，基于ActiveRecord思想</td></tr><tr><td>hutool-dfa</td><td>基于DFA模型的多关键字查找</td></tr><tr><td>hutool-extra</td><td>扩展模块，对第三方封装（模板引擎、邮件、Servlet、二维码、Emoji、FTP、分词等）</td></tr><tr><td>hutool-http</td><td>基于HttpUrlConnection的Http客户端封装</td></tr><tr><td>hutool-log</td><td>自动识别日志实现的日志门面</td></tr><tr><td>hutool-script</td><td>脚本执行封装，例如Javascript</td></tr><tr><td>hutool-setting</td><td>功能更强大的Setting配置文件和Properties封装</td></tr><tr><td>hutool-system</td><td>系统参数调用封装（JVM信息等）</td></tr><tr><td>hutool-json</td><td>JSON实现</td></tr><tr><td>hutool-captcha</td><td>图片验证码实现</td></tr><tr><td>hutool-poi</td><td>针对POI中Excel和Word的封装</td></tr><tr><td>hutool-socket</td><td>基于Java的NIO和AIO的Socket封装</td></tr><tr><td>hutool-jwt</td><td>JSON Web Token (JWT)封装实现</td></tr></tbody></table></div><p>可以根据需求对每个模块单独引入，也可以通过引入<code>hutool-all</code>方式引入所有模块，本文所使用的数据脱敏工具就是在hutool.core模块。</p><h3 id="2-3-Hutool支持的脱敏数据类型"><a href="#2-3-Hutool支持的脱敏数据类型" class="headerlink" title="2.3 Hutool支持的脱敏数据类型"></a>2.3 Hutool支持的脱敏数据类型</h3><p>现阶段最新版本的Hutool支持的脱敏数据类型如下，基本覆盖了常见的敏感信息。</p><ol><li>用户id</li><li>中文姓名</li><li>身份证号</li><li>座机号</li><li>手机号</li><li>地址</li><li>电子邮件</li><li>密码</li><li>中国大陆车牌，包含普通车辆、新能源车辆</li><li>银行卡</li></ol><h2 id="3-Hutool数据脱敏实操"><a href="#3-Hutool数据脱敏实操" class="headerlink" title="3. Hutool数据脱敏实操"></a>3. Hutool数据脱敏实操</h2><h3 id="3-1-使用Hutool工具类一行代码实现脱敏"><a href="#3-1-使用Hutool工具类一行代码实现脱敏" class="headerlink" title="3.1 使用Hutool工具类一行代码实现脱敏"></a>3.1 使用Hutool工具类一行代码实现脱敏</h3><p>Hutool提供的脱敏方法如下图所示：</p><p><img src="https://s3.bitiful.net/pb01/193.webp" alt="avatar"></p><p>注意：Hutool 脱敏是通过*来代替敏感信息的，具体实现是在StrUtil.hide方法中，如果我们想要自定义隐藏符号，则可以把Hutool的源码拷出来，重新实现即可。</p><p>这里以手机号、银行卡号、身份证号、密码信息的脱敏为例，下面是对应的测试代码。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cn.hutool.core.util.DesensitizedUtil;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.context.SpringBootTest;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: Hutool实现数据脱敏</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HuToolDesensitizationTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testPhoneDesensitization</span><span class="params">()</span>&#123;</span><br><span class="line">        String phone=<span class="string">&quot;13723231234&quot;</span>;</span><br><span class="line">        System.out.println(DesensitizedUtil.mobilePhone(phone)); <span class="comment">//输出：137****1234</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testBankCardDesensitization</span><span class="params">()</span>&#123;</span><br><span class="line">        String bankCard=<span class="string">&quot;6217000130008255666&quot;</span>;</span><br><span class="line">        System.out.println(DesensitizedUtil.bankCard(bankCard)); <span class="comment">//输出：6217 **** **** *** 5666</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testIdCardNumDesensitization</span><span class="params">()</span>&#123;</span><br><span class="line">        String idCardNum=<span class="string">&quot;411021199901102321&quot;</span>;</span><br><span class="line">        <span class="comment">//只显示前4位和后2位</span></span><br><span class="line">        System.out.println(DesensitizedUtil.idCardNum(idCardNum,<span class="number">4</span>,<span class="number">2</span>)); <span class="comment">//输出：4110************21</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testPasswordDesensitization</span><span class="params">()</span>&#123;</span><br><span class="line">        String password=<span class="string">&quot;www.jd.com_35711&quot;</span>;</span><br><span class="line">        System.out.println(DesensitizedUtil.password(password)); <span class="comment">//输出：****************</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p><p>以上就是使用Hutool封装好的工具类实现数据脱敏。</p><h3 id="3-2-配合JackSon通过注解方式实现脱敏"><a href="#3-2-配合JackSon通过注解方式实现脱敏" class="headerlink" title="3.2 配合JackSon通过注解方式实现脱敏"></a>3.2 配合JackSon通过注解方式实现脱敏</h3><p>现在有了数据脱敏工具类，如果前端需要显示数据数据的地方比较多，我们不可能在每个地方都调用一个工具类，这样就显得代码太冗余了，那我们如何通过注解的方式优雅的完成数据脱敏呢？</p><p>如果项目是基于springboot的web项目，则可以利用springboot自带的jackson自定义序列化实现。它的实现原来其实就是在json进行序列化渲染给前端时，进行脱敏。</p><p><strong>第一步：脱敏策略的枚举。</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>:脱敏策略枚举</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">DesensitizationTypeEnum</span> &#123;</span><br><span class="line">    <span class="comment">//自定义</span></span><br><span class="line">    MY_RULE,</span><br><span class="line">    <span class="comment">//用户id</span></span><br><span class="line">    USER_ID,</span><br><span class="line">    <span class="comment">//中文名</span></span><br><span class="line">    CHINESE_NAME,</span><br><span class="line">    <span class="comment">//身份证号</span></span><br><span class="line">    ID_CARD,</span><br><span class="line">    <span class="comment">//座机号</span></span><br><span class="line">    FIXED_PHONE,</span><br><span class="line">    <span class="comment">//手机号</span></span><br><span class="line">    MOBILE_PHONE,</span><br><span class="line">    <span class="comment">//地址</span></span><br><span class="line">    ADDRESS,</span><br><span class="line">    <span class="comment">//电子邮件</span></span><br><span class="line">    EMAIL,</span><br><span class="line">    <span class="comment">//密码</span></span><br><span class="line">    PASSWORD,</span><br><span class="line">    <span class="comment">//中国大陆车牌，包含普通车辆、新能源车辆</span></span><br><span class="line">    CAR_LICENSE,</span><br><span class="line">    <span class="comment">//银行卡</span></span><br><span class="line">    BANK_CARD</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面表示支持的脱敏类型。</p><p><strong>第二步：定义一个用于脱敏的 Desensitization 注解。</strong></p><ul><li>@Retention(RetentionPolicy.RUNTIME)：运行时生效。</li><li>@Target(ElementType.FIELD)：可用在字段上。</li><li>@JacksonAnnotationsInside：此注解可以点进去看一下是一个元注解，主要是用户打包其他注解一起使用。</li><li>@JsonSerialize：上面说到过，该注解的作用就是可自定义序列化，可以用在注解上，方法上，字段上，类上，运行时生效等等，根据提供的序列化类里面的重写方法实现自定义序列化。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Target(ElementType.FIELD)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@JacksonAnnotationsInside</span></span><br><span class="line"><span class="meta">@JsonSerialize(using = DesensitizationSerialize.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Desensitization &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 脱敏数据类型，在MY_RULE的时候，startInclude和endExclude生效</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    DesensitizationTypeEnum <span class="title function_">type</span><span class="params">()</span> <span class="keyword">default</span> DesensitizationTypeEnum.MY_RULE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 脱敏开始位置（包含）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">startInclude</span><span class="params">()</span> <span class="keyword">default</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 脱敏结束位置（不包含）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">endExclude</span><span class="params">()</span> <span class="keyword">default</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>注：只有使用了自定义的脱敏枚举MY_RULE的时候，开始位置和结束位置才生效。</p><p><strong>第三步：创建自定的序列化类</strong></p><p>这一步是我们实现数据脱敏的关键。自定义序列化类继承 JsonSerializer，实现ContextualSerializer接口，并重写两个方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 自定义序列化类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DesensitizationSerialize</span> <span class="keyword">extends</span> <span class="title class_">JsonSerializer</span>&lt;String&gt; <span class="keyword">implements</span> <span class="title class_">ContextualSerializer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> DesensitizationTypeEnum type;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer startInclude;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer endExclude;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">serialize</span><span class="params">(String str, JsonGenerator jsonGenerator, SerializerProvider serializerProvider)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">            <span class="comment">// 自定义类型脱敏</span></span><br><span class="line">            <span class="keyword">case</span> MY_RULE:</span><br><span class="line">                jsonGenerator.writeString(CharSequenceUtil.hide(str, startInclude, endExclude));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">// userId脱敏</span></span><br><span class="line">            <span class="keyword">case</span> USER_ID:</span><br><span class="line">                jsonGenerator.writeString(String.valueOf(DesensitizedUtil.userId()));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">// 中文姓名脱敏</span></span><br><span class="line">            <span class="keyword">case</span> CHINESE_NAME:</span><br><span class="line">                jsonGenerator.writeString(DesensitizedUtil.chineseName(String.valueOf(str)));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">// 身份证脱敏</span></span><br><span class="line">            <span class="keyword">case</span> ID_CARD:</span><br><span class="line">                jsonGenerator.writeString(DesensitizedUtil.idCardNum(String.valueOf(str), <span class="number">1</span>, <span class="number">2</span>));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">// 固定电话脱敏</span></span><br><span class="line">            <span class="keyword">case</span> FIXED_PHONE:</span><br><span class="line">                jsonGenerator.writeString(DesensitizedUtil.fixedPhone(String.valueOf(str)));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">// 手机号脱敏</span></span><br><span class="line">            <span class="keyword">case</span> MOBILE_PHONE:</span><br><span class="line">                jsonGenerator.writeString(DesensitizedUtil.mobilePhone(String.valueOf(str)));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">// 地址脱敏</span></span><br><span class="line">            <span class="keyword">case</span> ADDRESS:</span><br><span class="line">                jsonGenerator.writeString(DesensitizedUtil.address(String.valueOf(str), <span class="number">8</span>));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">// 邮箱脱敏</span></span><br><span class="line">            <span class="keyword">case</span> EMAIL:</span><br><span class="line">                jsonGenerator.writeString(DesensitizedUtil.email(String.valueOf(str)));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">// 密码脱敏</span></span><br><span class="line">            <span class="keyword">case</span> PASSWORD:</span><br><span class="line">                jsonGenerator.writeString(DesensitizedUtil.password(String.valueOf(str)));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">// 中国车牌脱敏</span></span><br><span class="line">            <span class="keyword">case</span> CAR_LICENSE:</span><br><span class="line">                jsonGenerator.writeString(DesensitizedUtil.carLicense(String.valueOf(str)));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">// 银行卡脱敏</span></span><br><span class="line">            <span class="keyword">case</span> BANK_CARD:</span><br><span class="line">                jsonGenerator.writeString(DesensitizedUtil.bankCard(String.valueOf(str)));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> JsonSerializer&lt;?&gt; createContextual(SerializerProvider serializerProvider, BeanProperty beanProperty) <span class="keyword">throws</span> JsonMappingException &#123;</span><br><span class="line">        <span class="keyword">if</span> (beanProperty != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 判断数据类型是否为String类型</span></span><br><span class="line">            <span class="keyword">if</span> (Objects.equals(beanProperty.getType().getRawClass(), String.class)) &#123;</span><br><span class="line">                <span class="comment">// 获取定义的注解</span></span><br><span class="line">                <span class="type">Desensitization</span> <span class="variable">desensitization</span> <span class="operator">=</span> beanProperty.getAnnotation(Desensitization.class);</span><br><span class="line">                <span class="comment">// 为null</span></span><br><span class="line">                <span class="keyword">if</span> (desensitization == <span class="literal">null</span>) &#123;</span><br><span class="line">                    desensitization = beanProperty.getContextAnnotation(Desensitization.class);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 不为null</span></span><br><span class="line">                <span class="keyword">if</span> (desensitization != <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 创建定义的序列化类的实例并且返回，入参为注解定义的type,开始位置，结束位置。</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DesensitizationSerialize</span>(desensitization.type(), desensitization.startInclude(),</span><br><span class="line">                            desensitization.endExclude());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> serializerProvider.findValueSerializer(beanProperty.getType(), beanProperty);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> serializerProvider.findNullValueSerializer(<span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>经过上述三步，已经完成了通过注解实现数据脱敏了，下面我们来测试一下。</p><p>首先定义一个要测试的pojo，对应的字段加入要脱敏的策略。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestPojo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Desensitization(type = DesensitizationTypeEnum.MOBILE_PHONE)</span></span><br><span class="line">    <span class="keyword">private</span> String phone;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Desensitization(type = DesensitizationTypeEnum.PASSWORD)</span></span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Desensitization(type = DesensitizationTypeEnum.MY_RULE, startInclude = 0, endExclude = 2)</span></span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>接下来写一个测试的controller<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/test&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> TestPojo <span class="title function_">testDesensitization</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">TestPojo</span> <span class="variable">testPojo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TestPojo</span>();</span><br><span class="line">        testPojo.setUserName(<span class="string">&quot;我是用户名&quot;</span>);</span><br><span class="line">        testPojo.setAddress(<span class="string">&quot;地球中国-北京市通州区京东总部2号楼&quot;</span>);</span><br><span class="line">        testPojo.setPhone(<span class="string">&quot;13782946666&quot;</span>);</span><br><span class="line">        testPojo.setPassword(<span class="string">&quot;sunyangwei123123123.&quot;</span>);</span><br><span class="line">        System.out.println(testPojo);</span><br><span class="line">        <span class="keyword">return</span> testPojo;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><img src="https://s3.bitiful.net/pb01/194.webp" alt="avatar"></p><p>可以看到我们成功实现了数据脱敏。</p><h2 id="4-其他常见的数据脱敏工具推荐"><a href="#4-其他常见的数据脱敏工具推荐" class="headerlink" title="4. 其他常见的数据脱敏工具推荐"></a>4. 其他常见的数据脱敏工具推荐</h2><p>除了本文介绍的Hutool工具之外，还有一些其他的数据脱敏工具，常见脱敏方法或工具如下所示：</p><h3 id="4-1-Apache-ShardingSphere"><a href="#4-1-Apache-ShardingSphere" class="headerlink" title="4.1 Apache ShardingSphere"></a>4.1 Apache ShardingSphere</h3><p>Apache ShardingSphere下面存在一个数据脱敏模块，此模块集成的常用的数据脱敏的功能。其基本原理是对用户输入的SQL进行解析拦截，并依靠用户的脱敏配置进行SQL的改写，从而实现对原文字段的加密及加密字段的解密。最终实现对用户无感的加解密存储、查询。</p><p>具体实现方式可参考下面文章： <a href="https://jaskey.github.io/blog/2020/03/18/sharding-sphere-data-desensitization/">https://jaskey.github.io/blog/2020/03/18/sharding-sphere-data-desensitization/</a></p><h3 id="4-2-FastJSON"><a href="#4-2-FastJSON" class="headerlink" title="4.2 FastJSON"></a>4.2 FastJSON</h3><p>平时开发Web项目的时候，除了默认的Spring自带的序列化工具，FastJson也是一个很常用的Spring web Restful接口序列化的工具。</p><p>FastJSON实现数据脱敏的方式主要有两种：</p><ul><li>基于注解@JSONField实现：需要自定义一个用于脱敏的序列化的类，然后在需要脱敏的字段上通过@JSONField中的serializeUsing 指定为我们自定义的序列化类型即可。</li><li>基于序列化过滤器：需要实现ValueFilter接口，重写process方法完成自定义脱敏，然后在JSON转换时使用自定义的转换策略。具体实现可参考这篇文章： <a href="https://juejin.cn/post/7067916686141161479">https://juejin.cn/post/7067916686141161479</a></li></ul><h3 id="4-3-Mybatis-mate"><a href="#4-3-Mybatis-mate" class="headerlink" title="4.3 Mybatis-mate"></a>4.3 Mybatis-mate</h3><p>mybatisplus也提供了数据脱敏模块，mybatis-mate，不过在使用之前需要配置授权码。</p><p>配置内容如下所示：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">\# Mybatis Mate 配置</span><br><span class="line">mybatis-mate:</span><br><span class="line">  cert:</span><br><span class="line">    grant: jxftsdfggggx</span><br><span class="line">    license: GKXP9r4MCJhGID/DTGigcBcLmZjb1YZGjE4GXaAoxbtGsPC20sxpEtiUr2F7Nb1ANTUekvF6Syo6DzraA4M4oacwoLVTglzfvaEfadfsd232485eLJK1QsskrSJmreMnEaNh9lsV7Lpbxy9JeGCeM0HPEbRvq8Y+8dUt5bQYLklsa3ZIBexir+4XykZY15uqn1pYIp4pEK0+aINTa57xjJNoWuBIqm7BdFIb4l1TAcPYMTsMXhF5hfMmKD2h391HxWTshJ6jbt4YqdKD167AgeoM+B+DE1jxlLjcpskY+kFs9piOS7RCcmKBBUOgX2BD/JxhR2gQ==</span><br></pre></td></tr></table></figure><br>具体实现可参考baomidou提供的如下代码： <a href="https://gitee.com/baomidou/mybatis-mate-examples">https://gitee.com/baomidou/mybatis-mate-examples</a></p><h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h2><p>本文主要介绍了数据脱敏的相关内容，首先介绍了数据脱敏的概念，在此基础上介绍了常用的数据脱敏规则；随后介绍了本文的重点Hutool工具及其使用方法，在此基础上进行了实操，分别演示了使用DesensitizedUtil工具类、配合Jackson通过注解的方式完成数据脱敏；最后，介绍了一些常见的数据脱敏方法，并附上了对应的教程链接供大家参考，本文内容如有不当之处，还请大家批评指正。</p><h2 id="6-参考内容"><a href="#6-参考内容" class="headerlink" title="6. 参考内容"></a>6. 参考内容</h2><p>Hutool工具官网： <a href="https://hutool.cn/docs/#/?id=%f0%9f%93%9a%e7%ae%80%e4%bb%8b">https://hutool.cn/docs/#/?id=%f0%9f%93%9a%e7%ae%80%e4%bb%8b</a></p><p>聊聊如何自定义数据脱敏： <a href="https://juejin.cn/post/7046567603971719204">https://juejin.cn/post/7046567603971719204</a></p><p>FastJSON实现数据脱敏： <a href="https://juejin.cn/post/7067916686141161479">https://juejin.cn/post/7067916686141161479</a></p><blockquote><p>作者：京东科技 孙扬威</p><p>来源：京东云开发者社区</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 安全 </tag>
            
            <tag> 转载 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库连接池</title>
      <link href="/2024/02/16/2024-2-16-%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0/"/>
      <url>/2024/02/16/2024-2-16-%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="数据库连接池"><a href="#数据库连接池" class="headerlink" title="数据库连接池"></a>数据库连接池</h2><h3 id="为什么需要连接池"><a href="#为什么需要连接池" class="headerlink" title="为什么需要连接池"></a>为什么需要连接池</h3><p>当一个数据库操作任务到来时，程序需要和数据库建立连接，进行三次握手、数据库用户验证，然后执行SQL语句，最后用户退出、四次挥手关闭连接。每次任务都执行这样的流程，那么整个流程中，真正有效而且变化的只有<code>执行SQL</code>语句这一步骤，而且每次建立连接、用户验证、关闭连接都耗费时间。</p><p>因此，考虑能不能将连接只创建一次，然后复用长连接执行 SQL 语句呢？这需要<strong>池化技术</strong>。</p><p>池化技术可以减少资源对象的创建次数，提高程序的响应性能，特别是对高并发场景下的性能提升非常明显。<br>适合使用池化技术缓存的资源对象具有如下特点：</p><ul><li>对象创建时间长</li><li>对象占用资源多</li><li>对象创建后可以重复使用</li></ul><h3 id="数据库连接池-1"><a href="#数据库连接池-1" class="headerlink" title="数据库连接池"></a>数据库连接池</h3><p>数据库连接池是程序启动时建立一定数量的数据库连接，并将这些连接组成一个连接池，当程序需要用到连接去进行数据库操作的时候,直接从连接池中获取一个连接对象使用，使用完毕后，将连接对象归还给连接池。</p><p><strong>优点</strong>:<br>（1）资源复用。避免了频繁的创建、释放连接引起的性能开销，减少系统消耗，增进系统运行环境的稳定（减少内存碎片和数据库临时线程/进程数量）。<br>（2）更快的系统响应速度。数据库连接池初始化完成后，直接利用现有可用连接，避免了从数据库连接初始化和释放过程的开销，从而缩减了系统整体响应时间。<br>（3）统一的连接管理，避免数据库连接泄漏。数据库连接池实现中，可根据预先的连接占用超时设定，强制收回被占用连接。从而避免了常规数据库连接操作中可能出现的资源泄露。</p><h4 id="关键参数-以HikariCP为例"><a href="#关键参数-以HikariCP为例" class="headerlink" title="关键参数(以HikariCP为例)"></a>关键参数(以HikariCP为例)</h4><ol><li><code>connectionTimeout</code>：客户端等待池中连接的最大事件（毫秒），超时则会抛出 SQLException，最低可接受时间为 250ms，默认值为30000ms</li><li><code>maximumPoolSize</code>：连接池中的最大连接数。默认为 10</li><li><code>minimumIdle</code>：控制 HikariCP 中维护的最小空闲连接数。当空闲连接数小于 minimumIdle 并且池中的总连接数少于 maximumPoolSize 时，HikariCP 将添加其他连接直到 maximumPoolSize。为了获得最佳性能和对峰值需求的响应能力建议不要设置此值。 默认值与 maximumPoolSize 相同</li><li><code>idleTimeout</code>：池中连接保持空闲状态的最长时间，只有在定义的minimumIdle 小于maximumPoolSize时生效，允许的最小时间为 10000ms,默认为 600000ms.当你配置了minimumIdle 且它的值还和maximumPoolSize不同的时候，就相当于告诉HikariCP，你至少得给我创建minimumIdle 多的连接备着。但是当你的系统忙的把minimumIdle 个备着的连接都拿走使用时，此时再问HikariCP索要，它就得给你创建多于minimumIdle 的连接，除非有连接还回来，否则我就得一直给你创建新的，直到达到上限——maximumPoolSize。但是，当你的系统过了忙碌期，闲下来的时候，多创建出来的那些连接，HikariCP就得抽空给干掉，因为它只需要保留minimumIdle 个就好了，多了浪费。此时这个idleTimeout参数就有用了，它就是用来告诉HikariCP，多出来的这些连接，多长时间没再被使用，你就可以干掉了。</li><li><code>connectionTestQuery</code>: 用来测试连接是否可用的 SQL 查询，HikariCP 默认会使用 <code>SELECT 1</code> 语句进行测试，如果设置为null，则不会进行测试。</li><li><code>maxLifetime</code>: <strong>最有可能出现坑的参数</strong>.池中连接的最大生命周期，默认值为1800000ms，即30分钟。如果设置为0，表示存活时间无限大。如果不等于0且小于30秒则会被重置回30分钟。如果设置了maxLifetime，则HikariCP给池中创建的每个连接，都会定时检测，不管这个连接上一次是什么时候使用的，只要在检测时它没在使用中，就会被淘汰。注意，这就是maxLifetime参数难以被理解的原因——哪怕是一个刚用完归还的连接，不幸碰巧赶上检测了，只能说永别——使得这个参数背后的逻辑显得非常不合理。但经过搜索,<code>作者的想法是</code>:一个连接即使一直能用，也不应该一直存在下去，应该定时的关闭（哪怕一天关一次），好让数据库服务器那边清理掉一些浪费的资源。所以这才是maxLifetime最根本存在的原因。</li></ol><h4 id="连接数设置为多少才合适"><a href="#连接数设置为多少才合适" class="headerlink" title="连接数设置为多少才合适"></a>连接数设置为多少才合适</h4><ol><li>经验公式，连接数=（核心数*2）+有效磁盘数。</li></ol><p>假如服务器CPU是i7的8核，那么连接池连接数大小为 8∗2+1=9 。这仅仅是一个经验公式，具体的还要和线程池数量以及具体业务结合在一起。</p><ol><li>IO密集型任务</li></ol><p>如果任务整体上是一个IO密集型的任务。在处理一个请求的过程中（处理一个任务），总共耗时100+5=105ms，而其中只有5ms是用于计算操作的（消耗cpu），另外的100ms等待io响应，CPU利用率为5/(100+5)。</p><p>使用线程池是为了尽量提高CPU的利用率，减少对CPU资源的浪费，假设以100%的CPU利用率来说，要达到100%的CPU利用率，对于一个CPU就要设置其利用率的倒数个数的线程数，也即1/(5/(100+5))=21，4个CPU的话就乘以4，即84，这个时候线程池要设置84个线程数，然后连接池也是设置为84个连接。</p><h4 id="连接池和长连接的区别"><a href="#连接池和长连接的区别" class="headerlink" title="连接池和长连接的区别"></a>连接池和长连接的区别</h4><ul><li><p>长连接是一些驱动、驱动架构、ORM(即Object-Relational Mapping)工具的特性，由驱动来保持连接句柄的打开，以便后续的数据库操作可以重用连接，从而减少数据库的连接开销。</p></li><li><p>连接池是应用服务器的组件，它可以通过参数来配置连接数、连接检查、连接的生命周期等。</p></li><li><p>连接池内的连接，其实就是长连接。</p></li></ul><h3 id="如何简单实现一个连接池"><a href="#如何简单实现一个连接池" class="headerlink" title="如何简单实现一个连接池"></a>如何简单实现一个连接池</h3><p>实现一个连接池，最关键的是<strong>均衡</strong>和<strong>保活</strong>.连接池的“池”通过队列数据结构进行实现，队列先进先出的特性保证了使用连接的均衡性，每一条连接都可以均匀的被使用到.连接池对外提供get()和free()两个API，get()用于从队首“出队”获取一条可用连接，free()用于将使用完的连接从对尾“入队”释放到队列中。</p><p>业务代码在低峰时会降低get()动作，所以连接池中的连接在长时间不用时会导致失效，此时保活线程在监测到get()的使用频率较低时，会模拟业务程序调用get()获取连接后发送心跳包，然后再通过free()将被保活的连接放回队列中，达到连接池中所有连接保活的目的。</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>美赛C题学习</title>
      <link href="/2024/01/24/2024-1-MCM/"/>
      <url>/2024/01/24/2024-1-MCM/</url>
      
        <content type="html"><![CDATA[<h2 id="美赛C题学习"><a href="#美赛C题学习" class="headerlink" title="美赛C题学习"></a>美赛C题学习</h2><p>如果自建模型,可以参考2218931的4.2.1,2218931的论文描述值得学习,最后的信也比较有特色</p><p>跟现实相结合也是很重要的点,最好能有案例支撑,虽然说在C题中不常见,但其实有的地方也可以加上</p><h3 id="时间序列预测"><a href="#时间序列预测" class="headerlink" title="时间序列预测"></a>时间序列预测</h3><p>可以关注一些特殊的时间节点，比如节假日，季节性，节假日和季节性都有可能影响时间序列的预测。</p><ul><li><p>ARIMA:经典时间序列预测模型，使用自回归积分移动平均模型，该模型可以对时间序列数据进行预测，并且可以对时间序列数据进行平滑处理,可以参考下2203120的写法。</p></li><li><p>GRU:时间序列预测,和LSTM类似，但是GRU的更新门和遗忘门合并为更新门，输入门和输出门合并为输出门，所以GRU的参数更少,更便于计算.</p></li><li><p>SIR:SIR模型，用于传染病传播的预测，S表示易感者，I表示感染者，R表示康复者,也适用于某些突然爆火的事件。</p></li><li><p>Prophet:时间序列预测，使用Facebook的Prophet算法，该算法基于时间序列历史数据，拟合出一个趋势和季节性，然后预测未来的时间序列。参考2301192,2200688</p></li><li><p>卡尔曼滤波算法</p></li><li><p>LightGBM:LightGBM是一种基于梯度提升决策树的机器学习算法，它具有高效性、可扩展性和可解释性等特点。在时间序列预测任务中，LightGBM可以有效地处理大量数据，并生成可解释的预测结果。</p></li><li><p>XGBoost:XGBoost是一种基于梯度提升决策树的机器学习算法，它具有高效性、可扩展性和可解释性等特点。           </p></li><li><p>LSTM:长短期记忆网络（Long Short-Term Memory，LSTM）是一种循环神经网络（RNN）的变体，它能够有效地处理时间序列数据。LSTM通过引入记忆单元和门机制，能够有效地捕捉和传递时间序列数据中的长期依赖关系。可与参考下2204883</p></li></ul><ul><li><p>ARIMA-LSTM:这两个模型结合感觉还是不错的,2212336,把LSTM换成GRU也是差不多的效果</p></li><li><p>ARIMA-SVM:来自2100948,可能参考了<code>https://blog.csdn.net/u014356002/article/details/53163684</code>,SVM和LSTM都用来捕捉非线性部分,但在预测上SVM不如LSTM,但SVM可解释性相对更好</p></li></ul><p>多模型堆叠:可以参考一下这里面的<code>https://blog.csdn.net/keypig_zz/article/details/82819558</code>,这个图和流程可以参考</p><h3 id="非时间序列预测"><a href="#非时间序列预测" class="headerlink" title="非时间序列预测"></a>非时间序列预测</h3><ul><li><p>GSRF:网格搜索的随机森林算法</p></li><li><p>维特比算法:主要用于解决隐马尔可夫模型（HMM）中的状态序列预测问题。在语音识别、自然语言处理、生物信息学等领域中，维特比算法被用于根据观测序列预测最有可能的状态序列。</p></li><li><p>MMOE模型:是一种多任务学习架构，旨在提高模型在处理多个相关任务时的性能。该模型由谷歌在2018年的KDD会议上提出，并因其有效的参数共享机制和任务特定处理能力而被业界广泛采用。来源于2307946,其用于预测尝试次数百分比.</p></li><li><p>多元线性回归:用于预测多个自变量对因变量的影响。</p></li></ul><h3 id="聚类算法-分类"><a href="#聚类算法-分类" class="headerlink" title="聚类算法(分类)"></a>聚类算法(分类)</h3><ul><li><p>k-means:k-means聚类算法,人为决定初始聚类中心,较为主观,可改用k-means++,或者使用Gap Statistic方法确定最佳k值</p></li><li><p>k-means++:k-means++聚类算法</p></li><li><p>DBSCAN:DBSCAN聚类算法</p></li><li><p>BIRCH:BIRCH聚类算法</p></li><li><p>GMM:GMM聚类算法,聚类效果比kmeans好,如果后续要降维,可以考虑使用kmeans++</p></li><li><p>谱聚类:谱聚类算法</p></li><li><p>层次聚类:层次聚类算法</p></li><li><p>R-CNN家族: R-CNN , Fast R-CNN , Faster R-CNN , Mask R-CNN,物体检测算法,在2106138中用于分类大黄蜂和胡蜂</p></li></ul><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p><strong>数据处理流程建议参考一下2208834</strong></p><p>模型最好都要有<strong>训练集</strong>和<strong>测试集</strong>，训练集和测试集最好要分开，训练集和测试集最好要随机打乱，这样模型才能有更好的效果。测试集可以从已有数据中随机抽取一部分作为测试集，也可以从训练集中划分一部分作为测试集。训练集和测试集的比例可以根据实际情况进行调整，一般来说，训练集的比例要大于测试集的比例。</p><p><strong>影响因子</strong>最好保留5-8个，如果影响因子太多，模型可能会过拟合，如果影响因子太少，模型可能会欠拟合。最好是从多个影响因子中挑选出来.</p><p>步骤如下:</p><ol><li>数据收集、数据清洗、数据标准化</li><li>相关性分析，分析各因子之间的相关性。高度相关的因子可能代表相似的信息，可以考虑合并或只保留一个。</li><li>使用PCA(主成分分析法)进行降维，选择最重要的5-8个影响因子.</li><li>确定权重:使用层次分析法、熵权法、主成分分析法、变异系数法等方法确定权重.</li></ol><p><strong>白噪声测试</strong>: 白噪声测试是用来检验时间序列数据是否为随机游走的，如果时间序列数据是随机游走的，那么它应该具有均匀的分布。白噪声测试可以使用ADF(Augmented Dickey-Fuller)检验方法来判断时间序列数据是否为随机游走。如果ADF检验结果的p值小于0.05，那么时间序列数据就不是随机游走的。</p><ul><li><p><strong>ADF测试</strong>:是一种统计检验方法，用于确定一个时间序列数据是否平稳。在经济学和金融学中，时间序列数据的平稳性是一个重要的概念，因为它有助于预测未来的经济活动。如果一个时间序列是平稳的，那么它的统计特性（如均值、方差和自协方差）不会随时间变化。如果数据平稳,可以使用原始数据,如果不平稳,则要对数据进行处理.具体方案如下:</p><ol><li><p>差分：如果数据是非平稳的，通过对数据进行一阶或更高阶的差分，可以去除数据中的趋势、季节性或其他时间动态特征，从而使数据变得平稳。差分是一种常见的时间序列平稳化技术。</p></li><li><p>季节性调整：对于具有季节性波动的数据，可以通过季节性调整来去除季节性因素，使数据更加平稳。这可以通过移动平均、季节性分解时间序列预测（STL）等方法来实现。</p></li><li><p>漂白：漂白是一种统计技术，通过它可以从时间序列中去除长期趋势和季节性成分，只保留短期波动。这可以通过自回归模型（如AR模型）来实现。</p></li><li><p>Box-Cox变换：这是一种用于处理非正态分布数据的技术，通过变换可以将数据转换为正态分布，有时这也有助于提高数据的平稳性。</p></li><li><p>处理异常值：检查数据中是否存在异常值或离群值，并考虑是否需要将其删除或进行某种形式的调整。</p></li><li><p>使用更高级的模型：有时，使用更高级的经济计量模型（如向量自回归模型VAR或状态空间模型）可以处理非平稳数据，而不需要直接对数据进行平稳化处理。</p></li></ol></li></ul><ul><li><p>CTGAN:生成对抗网络，可用于拓展数据集(谨慎使用)</p></li><li><p><strong>OpenFE</strong>:是一种功能强大的特征自动生成算法OpenFE，它能有效地生成有用的特征，提高模型学习性能(GBDT相关模型和SOAT神经网络).</p></li><li><p>Bootstrap方法:通过重复抽样和计算统计量来估计总体的分布,可以用来进行假设检验,置信区间构建,稳健性分析等。论文2309397对预测结果使用Bootstrap方法构建置信区间,取置信水平95%时的结果作为预测区间。</p></li></ul><p>图建议15-20张,表建议3-8个,总数20-25最佳</p><p>使用比较高级的模型最好画上原理图,模型进行结合也最好画图表示一下.如果建立的模型比较简单,那就得在分析和图像上下功夫.每一个task的分析至少得有一张图</p><p>可以用伪代码去展示一些不好用图表展示的行业性的算法,例如2200401的交易策略</p><ul><li>NSGS-II:多目标优化算法,参考2218743</li></ul><p>简单的图也可以画得不一样,比如折线图,我们可以将最值标记出来,将异常值标记出等等</p><p><img src="https://pb01.s3.bitiful.net/143.png" alt="avatar"></p><p>词云可视化也可以作为一大亮点</p><p>21年的可以看下2107079</p>]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MCM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>西电数据库openGauss平台练习</title>
      <link href="/2023/12/29/openguass/"/>
      <url>/2023/12/29/openguass/</url>
      
        <content type="html"><![CDATA[<h3 id="西电数据库openGauss平台练习"><a href="#西电数据库openGauss平台练习" class="headerlink" title="西电数据库openGauss平台练习"></a>西电数据库openGauss平台练习</h3><p><strong><em>仅记录平台标注中等难度及以上的题目</em></strong></p><p><strong>试卷编号:41</strong><br><strong>试卷名称:gongsi</strong></p><p><strong>条件</strong>:<br>公司数据库有如下关系模式： 员工employee（员工号eno，员工姓名ename，员工年龄eage，所在部门号dno，工资salary，工作日期work）； 部门depart(部门号dno，部门名称dname，部门经理员工号dman)。</p><h4 id="题目3：查询每个部门的部门号、员工平均工资。"><a href="#题目3：查询每个部门的部门号、员工平均工资。" class="headerlink" title="题目3：查询每个部门的部门号、员工平均工资。"></a>题目3：查询每个部门的部门号、员工平均工资。</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> dno, <span class="built_in">AVG</span>(salary)</span><br><span class="line"><span class="keyword">from</span> employee <span class="keyword">group</span> <span class="keyword">by</span> dno</span><br></pre></td></tr></table></figure><h4 id="题目4：查询员工的中位数工资。"><a href="#题目4：查询员工的中位数工资。" class="headerlink" title="题目4：查询员工的中位数工资。"></a>题目4：查询员工的中位数工资。</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span> salary <span class="keyword">from</span> employee a </span><br><span class="line"><span class="keyword">where</span> (<span class="keyword">select</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> employee b <span class="keyword">where</span> b.salary<span class="operator">&gt;=</span>a.salary) <span class="operator">-</span></span><br><span class="line">(<span class="keyword">select</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> employee b <span class="keyword">where</span> b.salary<span class="operator">&lt;=</span>a.salary)</span><br><span class="line"><span class="keyword">between</span> <span class="number">-1</span> <span class="keyword">and</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><p>这道题比较<strong>容易踩坑</strong>的地方是题目没有说明它对<strong>中位数的定义</strong>,这里是将多个中位数返回回去,而不用求平均,而网上大多数类似的需求都是只能返回一个中位数,所以有多个中位数是都进行了求平均操作,但这里是没有的,所以需要特别注意</p><h4 id="题目5：查询每个部门的部门号，员工中位数工资。"><a href="#题目5：查询每个部门的部门号，员工中位数工资。" class="headerlink" title="题目5：查询每个部门的部门号，员工中位数工资。"></a>题目5：查询每个部门的部门号，员工中位数工资。</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span> dno,salary <span class="keyword">from</span> employee a </span><br><span class="line"><span class="keyword">where</span> (<span class="keyword">select</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> employee b <span class="keyword">where</span> b.dno<span class="operator">=</span>a.dno <span class="keyword">and</span> b.salary<span class="operator">&gt;=</span>a.salary) <span class="operator">-</span></span><br><span class="line">(<span class="keyword">select</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> employee b <span class="keyword">where</span> b.dno<span class="operator">=</span>a.dno <span class="keyword">and</span> b.salary<span class="operator">&lt;=</span>a.salary)</span><br><span class="line"><span class="keyword">between</span> <span class="number">-1</span> <span class="keyword">and</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><h4 id="题目6：员工表设计不符合1NF"><a href="#题目6：员工表设计不符合1NF" class="headerlink" title="题目6：员工表设计不符合1NF"></a>题目6：员工表设计不符合1NF</h4><p>工作日期包含多个日期，中间用逗号,分隔，<strong>前后可能有多个空格</strong>，如2022-11-11,2022-11-12,2018-08-01，查询每个员工的员工号，姓名和工作日期，其中工作日期要求将原有日期拆分为单个日期。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> eno,ename,<span class="built_in">trim</span>(regexp_split_to_table(work,<span class="string">&#x27;,&#x27;</span>)) <span class="keyword">as</span> work <span class="keyword">from</span> employee;</span><br></pre></td></tr></table></figure><p>这道题个人觉得是这套练习里<strong>最难</strong>的一道了,但openGauss的regexp_split_to_table函数已经帮我们实现了<strong>行转列</strong>这个最难的点,然后trim函数去一下空格,就出来了.当然别的方法也可以做,网上一搜都有,但函数用起来就是爽🤪</p><h4 id="题目12：创建函数get-age-count-s-e-，返回年龄在-s-e-范围内的员工的人数。"><a href="#题目12：创建函数get-age-count-s-e-，返回年龄在-s-e-范围内的员工的人数。" class="headerlink" title="题目12：创建函数get_age_count(s,e)，返回年龄在[s,e]范围内的员工的人数。"></a>题目12：创建函数get_age_count(s,e)，返回年龄在[s,e]范围内的员工的人数。</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">OR</span> REPLACE <span class="keyword">FUNCTION</span> get_age_count(s <span class="type">integer</span>, e <span class="type">integer</span>)  </span><br><span class="line"><span class="keyword">RETURNS</span> <span class="type">integer</span> <span class="keyword">AS</span> $total$  </span><br><span class="line"><span class="keyword">declare</span>  </span><br><span class="line">    total <span class="type">integer</span>;  </span><br><span class="line"><span class="keyword">BEGIN</span>  </span><br><span class="line">   <span class="keyword">SELECT</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">INTO</span> total <span class="keyword">FROM</span> employee <span class="keyword">WHERE</span> eage<span class="operator">&gt;=</span>s <span class="keyword">AND</span> eage<span class="operator">&lt;=</span>e;  </span><br><span class="line">   <span class="keyword">RETURN</span> total;  </span><br><span class="line"><span class="keyword">END</span>;  </span><br><span class="line">$total$ <span class="keyword">LANGUAGE</span> plpgsql;</span><br></pre></td></tr></table></figure><p>这道题就要仔细看下openGauss的手册,我一开始按MySQL函数的格式写就错了,后来仔细看了下手册才发现openGauss自定义函数是<strong>PostgreSQL格式</strong>的,这点要注意.</p>]]></content>
      
      
      <categories>
          
          <category> xdu </category>
          
      </categories>
      
      
        <tags>
            
            <tag> openGauss </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL索引一</title>
      <link href="/2023/12/29/MySQL%E7%B4%A2%E5%BC%95/"/>
      <url>/2023/12/29/MySQL%E7%B4%A2%E5%BC%95/</url>
      
        <content type="html"><![CDATA[<h2 id="MySQL索引一"><a href="#MySQL索引一" class="headerlink" title="MySQL索引一"></a>MySQL索引一</h2><h3 id="什么是索引"><a href="#什么是索引" class="headerlink" title="什么是索引"></a>什么是索引</h3><p>索引是一种用于快速查询和检索数据的数据结构，其本质可以看成是一种排序好的<strong>数据结构</strong>。</p><p>索引的作用就相当于书的目录。打个比方: 我们在查字典的时候，如果没有目录，那我们就只能一页一页的去找我们需要查的那个字，速度很慢。如果有目录了，我们只需要先去目录里查找字的位置，然后直接翻到那一页就行了。</p><p>在 MySQL 中，无论是 Innodb 还是 MyIsam，都使用了 <strong>B+树</strong>作为索引结构。</p><h3 id="索引的优缺点"><a href="#索引的优缺点" class="headerlink" title="索引的优缺点"></a>索引的优缺点</h3><p>优点:</p><ul><li>提高数据检索效率，降低数据库IO成本</li><li>降低数据排序成本，降低CPU消耗</li><li>通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。</li></ul><p>缺点:</p><ul><li>索引需要占物理空间</li><li>索引需要定期维护，增删改数据时需要维护索引，降低数据写入效率</li></ul><h3 id="索引底层数据结构选型"><a href="#索引底层数据结构选型" class="headerlink" title="索引底层数据结构选型"></a>索引底层数据结构选型</h3><h4 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h4><p>哈希表是一种以键-值(key-value)存储数据的结构，只要输入待查找值即 key，就可以找到其对应的值即 value。因此哈希表可以快速检索数据（接近 O（1））。</p><p>为何能够通过 key 快速取出 value 呢？ 原因在于 <strong>哈希算法</strong>（也叫散列算法）。通过哈希算法，我们可以快速找到 key 对应的 index，找到了 index 也就找到了对应的 value。</p><p><img src="https://pb01.s3.bitiful.net/141.png" alt="avatar"></p><p>但是, 哈希表有一个很大的缺点: 就是哈希冲突。</p><p>哈希冲突: 两个不同的 key 通过哈希算法得到了相同的结果，这种情况我们称为哈希冲突。</p><p>通常情况下，我们常用的解决办法是 <code>链地址法</code>。链地址法就是将哈希冲突数据存放在链表中。就比如 JDK1.8 之前 HashMap 就是通过链地址法来解决哈希冲突的。不过，JDK1.8 以后HashMap为了减少链表过长的时候搜索时间过长引入了红黑树。</p><p>为了减少 Hash 冲突的发生，一个好的哈希函数应该“均匀地”将数据分布在整个可能的哈希值集合中。</p><p>MySQL 的 InnoDB 存储引擎不直接支持常规的哈希索引，但是，InnoDB 存储引擎中存在一种特殊的<code>“自适应哈希索引”</code>（Adaptive Hash Index），自适应哈希索引并不是传统意义上的纯哈希索引，而是结合了 B+Tree 和哈希索引的特点，以便更好地适应实际应用中的数据访问模式和性能需求。自适应哈希索引的每个哈希桶实际上是一个小型的 B+Tree 结构。这个 B+Tree 结构可以存储多个键值对，而不仅仅是一个键。这有助于减少哈希冲突链的长度，提高了索引的效率。</p><p>既然哈希表这么快，为什么 MySQL 没有使用其作为索引的数据结构呢？ 主要是因为 Hash 索引<strong>不支持顺序和范围查询</strong>。假如我们要对表中的数据进行排序或者进行范围查询，那 Hash 索引可就不行了。并且，<strong>每次 IO 只能取一个</strong>。</p><h4 id="二叉查找树"><a href="#二叉查找树" class="headerlink" title="二叉查找树"></a>二叉查找树</h4><p>二叉查找树（BST）是一种特殊的二叉树，它具有以下几个特点：</p><ul><li>左子树所有节点的值均小于根节点的值。</li><li>右子树所有节点的值均大于根节点的值。</li><li>左子树和右子树都是二叉查找树。</li></ul><p>当二叉查找树是平衡的时候，也就是树的每个节点的左右子树深度相差不超过 1 的时候，查询的时间复杂度为 O(log2(N))，具有比较高的效率。然而，当二叉查找树不平衡时，例如在最坏情况下（有序插入节点），树会退化成线性链表（也被称为斜树），导致查询效率急剧下降，时间复杂退化为 O（N）。</p><p>二叉查找树可以支持顺序和范围查询，但是，二叉查找树有一个很大的缺点: 就是平衡性不好。这就导致其不适合作为 MySQL 底层索引的数据结构。</p><h4 id="平衡二叉树-AVL树"><a href="#平衡二叉树-AVL树" class="headerlink" title="平衡二叉树(AVL树)"></a>平衡二叉树(AVL树)</h4><p>AVL 树的特点是保证任何节点的左右子树高度之差不超过 1，因此也被称为高度平衡二叉树，它的查找、插入和删除在平均和最坏情况下的时间复杂度都是 O(logn)。</p><p>AVL 树采用了旋转操作来保持平衡。主要有四种旋转操作：LL 旋转、RR 旋转、LR 旋转和 RL 旋转。其中 LL 旋转和 RR 旋转分别用于处理左左和右右失衡，而 LR 旋转和 RL 旋转则用于处理左右和右左失衡。</p><p>由于 AVL 树需要频繁地进行旋转操作来保持平衡，因此会有较大的计算开销进而降低了查询性能。并且，在使用 AVL 树时，每个树节点仅存储一个数据，而每次进行磁盘 IO 时只能读取一个节点的数据，如果需要查询的数据分布在多个节点上，那么就需要进行多次磁盘 IO。 磁盘 IO 是一项耗时的操作，在设计数据库索引时，我们需要优先考虑如何最大限度地减少磁盘 IO 操作的次数。</p><p>实际应用中，AVL 树使用的并不多。</p><h4 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h4><p>红黑树是一种自平衡二叉查找树，通过在插入和删除节点时进行颜色变换和旋转操作，使得树始终保持平衡状态，它具有以下特点：</p><ol><li>每个节点非红即黑；</li><li>根节点总是黑色的；</li><li>每个叶子节点都是黑色的空节点（NIL 节点）；</li><li>如果节点是红色的，则它的子节点必须是黑色的（反之不一定）；</li><li>从根节点到叶节点或空子节点的每条路径，必须包含相同数目的黑色节点（即相同的黑色高度）。</li></ol><p><img src="https://pb01.s3.bitiful.net/142.png" alt="avatar"></p><p>和 AVL 树不同的是，红黑树并不追求严格的平衡，而是大致的平衡。正因如此，红黑树的<strong>查询效率稍有下降</strong>，因为红黑树的平衡性相对较弱，可能会导致树的高度较高，这可能会导致一些数据需要进行多次磁盘 IO 操作才能查询到，这也是 MySQL 没有选择红黑树的主要原因。也正因如此，红黑树的<strong>插入和删除操作效率大大提高了</strong>，因为红黑树在插入和删除节点时只需进行 O(1) 次数的旋转和变色操作，即可保持基本平衡状态，而不需要像 AVL 树一样进行 O(logn) 次数的旋转操作。</p><p>红黑树的应用还是比较广泛的，TreeMap、TreeSet 以及 JDK1.8 的 HashMap 底层都用到了红黑树。对于数据在内存中的这种情况来说，红黑树的表现是非常优异的。</p><h4 id="B-树-amp-B-树"><a href="#B-树-amp-B-树" class="headerlink" title="B 树&amp; B+树"></a>B 树&amp; B+树</h4><p>B 树也称 B-树,全称为 多路平衡查找树 ，B+ 树是 B 树的一种变体。目前大部分数据库系统及文件系统都采用 B-Tree 或其变种 B+Tree 作为索引结构。</p><p><strong>B 树&amp; B+树两者有何异同呢？</strong></p><ul><li>B 树的所有节点既存放键(key) 也存放数据(data)，而 B+树只有叶子节点存放 key 和 data，其他内节点只存放 key。</li><li>B 树的叶子节点都是独立的;B+树的叶子节点有一条引用链指向与它相邻的叶子节点。</li><li>B 树的检索的过程相当于对范围内的每个节点的关键字做二分查找，可能还没有到达叶子节点，检索就结束了。而 B+树的检索效率就很稳定了，任何查找都是从根节点到叶子节点的过程，叶子节点的顺序检索很明显。</li><li>在 B 树中进行范围查询时，首先找到要查找的下限，然后对 B 树进行中序遍历，直到找到查找的上限；而 B+树的范围查询，只需要对链表进行遍历即可。</li></ul><p>综上，B+树与 B 树相比，具备更少的 IO 次数、更稳定的查询效率和更适于范围查询这些优势。</p><h3 id="索引类型总结"><a href="#索引类型总结" class="headerlink" title="索引类型总结"></a>索引类型总结</h3><p><strong>分类</strong></p><ul><li>主键索引：加速查询 + 列值唯一（不可以有 NULL）+ 表中只有一个。</li><li>普通索引：仅加速查询。</li><li>唯一索引：加速查询 + 列值唯一（可以有 NULL）。</li><li>覆盖索引：一个索引包含（或者说覆盖）所有需要查询的字段的值。</li><li>联合索引：多列值组成一个索引，专门用于组合搜索，其效率大于索引合并。</li><li>全文索引：对文本的内容进行分词，进行搜索。目前只有 <code>CHAR</code>、<code>VARCHAR</code> ，<code>TEXT</code> 列上可以创建全文索引。一般不会使用，效率较低，通常使用搜索引擎如 <code>ElasticSearch</code> 代替。</li></ul><p>MySQL 8.x 中实现的索引新特性：</p><ul><li>隐藏索引：也称为不可见索引，不会被优化器使用，但是仍然需要维护，通常会软删除和灰度发布的场景中使用。主键不能设置为隐藏（包括显式设置或隐式设置）。</li><li>降序索引：之前的版本就支持通过 desc 来指定索引为降序，但实际上创建的仍然是常规的升序索引。直到 MySQL 8.x 版本才开始真正支持降序索引。另外，在 MySQL 8.x 版本中，不再对 GROUP BY 语句进行隐式排序。</li><li>函数索引：从 MySQL 8.0.13 版本开始支持在索引中使用函数或者表达式的值，也就是在索引中可以包含函数或者表达式。</li></ul><h4 id="主键索引"><a href="#主键索引" class="headerlink" title="主键索引"></a>主键索引</h4><p><code>not null</code> +<code>unique</code></p><p>在 MySQL 的 InnoDB 的表中，当没有显示的指定表的主键时，InnoDB 会自动先检查表中是否有唯一索引且不允许存在 null 值的字段，如果有，则选择该字段为默认的主键，否则 InnoDB 将会自动创建一个 6Byte 的自增主键。</p><h4 id="二级索引"><a href="#二级索引" class="headerlink" title="二级索引"></a>二级索引</h4><p>二级索引的叶子节点存储的是主键值。即通过二级索引可以定位主键.唯一索引，普通索引，前缀索引等索引属于二级索引</p><ul><li>普通索引:仅加速查询。</li><li>唯一索引:列值唯一,但对NULL不生效</li><li>前缀索引:为了节省空间，对字符串类型的字段，可以只索引字段的前几个字符。</li><li>全文索引:基于分词,常用于大文本搜索关键词,match和against关键字</li></ul><h4 id="聚簇索引"><a href="#聚簇索引" class="headerlink" title="聚簇索引"></a>聚簇索引</h4><p>索引结构和数据一起放的索引</p><h4 id="非聚簇索引"><a href="#非聚簇索引" class="headerlink" title="非聚簇索引"></a>非聚簇索引</h4><p>索引结构和数据分开存放的索引,如二级索引</p><h3 id="为什么主键索引最好设置为自增"><a href="#为什么主键索引最好设置为自增" class="headerlink" title="为什么主键索引最好设置为自增?"></a>为什么主键索引最好设置为自增?</h3><p>设置自增后,插入数据时,插入速度更快,因为每次插入数据时,数据库不用移动其他数据,只需要移动指针即可.</p><p>如果我们使用非自增主键，由于每次插入主键的索引值都是随机的，因此每次插入新的数据时，就可能会插入到现有数据页中间的某个位置，这将不得不移动其它数据来满足新数据的插入，甚至需要从一个页面复制数据到另外一个页面，我们通常将这种情况称为<strong>页分裂</strong>。页分裂还有可能会造成大量的内存碎片，导致索引结构不紧凑，从而影响查询效率</p><p><strong>非自增主键</strong>:</p><p><img src="https://pb01.s3.bitiful.net/yefen.webp" alt="avatar"><br><strong>自增主键</strong>:</p><p><img src="https://pb01.s3.bitiful.net/newyefen.webp" alt="avatar"></p><h3 id="问什么索引最好设置为-NOT-NULL"><a href="#问什么索引最好设置为-NOT-NULL" class="headerlink" title="问什么索引最好设置为 NOT NULL"></a>问什么索引最好设置为 NOT NULL</h3><p>Mysql难以优化引用可空列查询，它会使索引、索引统计和值更加复杂。可空列需要更多的存储空间，还需要mysql内部进行特殊处理。可空列被索引后，每条记录都需要一个额外的字节，还能导致MYisam表中固定大小的索引变成可变大小的索引。            ————《高性能MySQL》</p><h3 id="References"><a href="#References" class="headerlink" title="References"></a>References</h3><ul><li>javaguide</li><li>小林coding<br>…</li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL规范</title>
      <link href="/2023/12/24/MySQL%E8%A7%84%E8%8C%83/"/>
      <url>/2023/12/24/MySQL%E8%A7%84%E8%8C%83/</url>
      
        <content type="html"><![CDATA[<h2 id="MySQL规范"><a href="#MySQL规范" class="headerlink" title="MySQL规范"></a>MySQL规范</h2><h3 id="数据库命名规范"><a href="#数据库命名规范" class="headerlink" title="数据库命名规范"></a>数据库命名规范</h3><ul><li>所有数据库对象名称必须使用小写字母并用下划线分割</li><li>所有数据库对象名称禁止使用 MySQL 保留关键字（如果表名中包含关键字查询时，需要将其用单引号括起来）</li><li>数据库对象的命名要能做到见名识意，并且最好不要超过 32 个字符</li><li>临时库表必须以 tmp<em> 为前缀并以日期为后缀，备份表必须以 bak</em> 为前缀并以日期 (时间戳) 为后缀</li><li>所有存储相同数据的列名和列类型必须一致（一般作为关联列，如果查询时关联列类型不一致会自动进行数据类型隐式转换，会造成列上的索引失效，导致查询效率降低）</li></ul><h3 id="数据库基本设计规范"><a href="#数据库基本设计规范" class="headerlink" title="数据库基本设计规范"></a>数据库基本设计规范</h3><h4 id="所有表必须使用-InnoDB-存储引擎"><a href="#所有表必须使用-InnoDB-存储引擎" class="headerlink" title="所有表必须使用 InnoDB 存储引擎"></a>所有表必须使用 InnoDB 存储引擎</h4><p>没有特殊要求（即 InnoDB 无法满足的功能如：列存储，存储空间数据等）的情况下，所有表必须使用 InnoDB 存储引擎</p><h4 id="数据库和表的字符集统一使用-UTF8"><a href="#数据库和表的字符集统一使用-UTF8" class="headerlink" title="数据库和表的字符集统一使用 UTF8"></a>数据库和表的字符集统一使用 UTF8</h4><p>兼容性更好，统一字符集可以避免由于字符集转换产生的乱码，不同的字符集进行比较前需要进行转换会造成索引失效，如果数据库中有存储 emoji 表情的需要，字符集需要采用 utf8mb4 字符集。</p><h4 id="所有表和字段都需要添加注释"><a href="#所有表和字段都需要添加注释" class="headerlink" title="所有表和字段都需要添加注释"></a>所有表和字段都需要添加注释</h4><p>使用 comment 从句添加表和列的备注，从一开始就进行数据字典的维护</p><h4 id="尽量控制单表数据量的大小，建议控制在-500-万以内"><a href="#尽量控制单表数据量的大小，建议控制在-500-万以内" class="headerlink" title="尽量控制单表数据量的大小，建议控制在 500 万以内"></a>尽量控制单表数据量的大小，建议控制在 500 万以内</h4><p>500 万并不是 MySQL 数据库的限制，只是经验值，如果单表超过 500 万后，查询效率会急剧下降.过大会造成修改表结构，备份，恢复都会有很大的问题。</p><p>可以用历史数据归档（应用于日志数据），分库分表（应用于业务数据）等手段来控制数据量大小</p><h4 id="谨慎使用-MySQL-分区表"><a href="#谨慎使用-MySQL-分区表" class="headerlink" title="谨慎使用 MySQL 分区表"></a>谨慎使用 MySQL 分区表</h4><p>分区表在物理上表现为多个文件，在逻辑上表现为一个表；</p><p>谨慎选择分区键，跨分区查询效率可能更低；</p><p>建议采用物理分表的方式管理大数据。</p><h4 id="经常一起使用的列放到一个表中"><a href="#经常一起使用的列放到一个表中" class="headerlink" title="经常一起使用的列放到一个表中"></a>经常一起使用的列放到一个表中</h4><p>避免更多的关联操作。</p><h4 id="禁止在表中建立预留字段"><a href="#禁止在表中建立预留字段" class="headerlink" title="禁止在表中建立预留字段"></a>禁止在表中建立预留字段</h4><ul><li>预留字段的命名很难做到见名识义。</li><li>预留字段无法确认存储的数据类型，所以无法选择合适的类型。</li><li>对预留字段类型的修改，会对表进行锁定。</li></ul><h4 id="禁止在数据库中存储文件这类大的二进制数据"><a href="#禁止在数据库中存储文件这类大的二进制数据" class="headerlink" title="禁止在数据库中存储文件这类大的二进制数据"></a>禁止在数据库中存储文件这类大的二进制数据</h4><p>在数据库中存储文件会严重影响数据库性能，消耗过多存储空间。</p><p>文件这类大的二进制数据通常存储于文件服务器，数据库只存储文件地址信息</p><h4 id="不要被数据库范式所束缚"><a href="#不要被数据库范式所束缚" class="headerlink" title="不要被数据库范式所束缚"></a>不要被数据库范式所束缚</h4><p>一般来说，设计关系数据库时需要满足第三范式，但为了满足第三范式，我们可能会拆分出多张表。而在进行查询时需要对多张表进行关联查询，有时为了提高查询效率，会降低范式的要求，在表中保存一定的冗余信息，也叫做反范式。但要注意反范式一定要适度。</p><h4 id="禁止在线上做数据库压力测试"><a href="#禁止在线上做数据库压力测试" class="headerlink" title="禁止在线上做数据库压力测试"></a>禁止在线上做数据库压力测试</h4><h4 id="禁止从开发环境-测试环境直接连接生产环境数据库"><a href="#禁止从开发环境-测试环境直接连接生产环境数据库" class="headerlink" title="禁止从开发环境,测试环境直接连接生产环境数据库"></a>禁止从开发环境,测试环境直接连接生产环境数据库</h4><h3 id="数据库字段设计规范"><a href="#数据库字段设计规范" class="headerlink" title="数据库字段设计规范"></a>数据库字段设计规范</h3><h4 id="优先选择符合存储需要的最小的数据类型"><a href="#优先选择符合存储需要的最小的数据类型" class="headerlink" title="优先选择符合存储需要的最小的数据类型"></a>优先选择符合存储需要的最小的数据类型</h4><p>存储字节越小，占用也就空间越小，性能也越好。</p><p><strong>a.某些字符串可以转换成数字类型存储</strong>,比如可以将 IP 地址转换成整型数据。数字是连续的，性能更好，占用空间也更小。</p><p>MySQL 提供了两个方法来处理 ip 地址</p><ul><li><strong>INET_ATON()</strong>：把 ip 转为无符号整型 (4-8 位)</li><li><strong>INET_NTOA()</strong> :把整型的 ip 转为地址插入数据前，先用 INET_ATON() 把 ip 地址转为整型，显示数据时，使用 INET_NTOA() 把整型的 ip 地址转为地址显示即可。</li></ul><p><strong>b.对于非负型的数据 (如自增 ID,整型 IP，年龄) 来说,要优先使用无符号整型来存储</strong>。无符号相对于有符号可以多出一倍的存储空间</p><p><strong>c.小数值类型（比如年龄、状态表示如 0/1）优先使用 TINYINT 类型。</strong></p><h4 id="避免使用-TEXT-BLOB-类型"><a href="#避免使用-TEXT-BLOB-类型" class="headerlink" title="避免使用 TEXT,BLOB 类型"></a>避免使用 TEXT,BLOB 类型</h4><p>比如 TEXT 类型的字段，如果查询时没有使用索引，会变成全表扫描，性能极差</p><h4 id="避免使用ENUM类型"><a href="#避免使用ENUM类型" class="headerlink" title="避免使用ENUM类型"></a>避免使用ENUM类型</h4><ul><li>修改 ENUM 值需要使用 ALTER 语句；</li><li>ENUM 类型的 ORDER BY 操作效率低，需要额外操作；</li><li>ENUM 数据类型存在一些限制比如建议不要使用数值作为 ENUM 的枚举值。</li></ul><h4 id="尽可能把所有列定义为-NOT-NULL"><a href="#尽可能把所有列定义为-NOT-NULL" class="headerlink" title="尽可能把所有列定义为 NOT NULL"></a>尽可能把所有列定义为 NOT NULL</h4><ul><li>索引 NULL 列需要额外的空间来保存，所以要占用更多的空间；</li><li>进行比较和计算时要对 NULL 值做特别的处理。</li></ul><h4 id="一定不要用字符串存储日期"><a href="#一定不要用字符串存储日期" class="headerlink" title="一定不要用字符串存储日期"></a>一定不要用字符串存储日期</h4><p>对于日期类型来说， 一定不要用字符串存储日期。可以考虑 DATETIME、TIMESTAMP 和 数值型时间戳。</p><p>这三种种方式都有各自的优势，根据实际场景选择最合适的才是王道。下面再对这三种方式做一个简单的对比，以供大家实际开发中选择正确的存放时间的数据类型：</p><div class="table-container"><table><thead><tr><th style="text-align:center">类型</th><th style="text-align:center">存储空间</th><th style="text-align:center">日期格式</th><th style="text-align:center">日期范围</th><th style="text-align:center">是否带时区信息</th></tr></thead><tbody><tr><td style="text-align:center">DATETIME</td><td style="text-align:center">5~8 字节</td><td style="text-align:center">YYYY-MM-DD hh:mm:ss[.fraction]</td><td style="text-align:center">1000-01-01 00:00:00[.000000] ～ 9999-12-31 23:59:59[.999999]</td><td style="text-align:center">否</td></tr><tr><td style="text-align:center">TIMESTAMP</td><td style="text-align:center">4~7 字节</td><td style="text-align:center">YYYY-MM-DD hh:mm:ss[.fraction]</td><td style="text-align:center">1970-01-01 00:00:01[.000000] ～ 2038-01-19 03:14:07[.999999]</td><td style="text-align:center">是</td></tr></tbody></table></div><p>数值型时间戳|4 字节|全数字如 1578707612|1970-01-01 00:00:01 之后的时间|否|</p><h4 id="同财务相关的金额类数据必须使用-decimal-类型"><a href="#同财务相关的金额类数据必须使用-decimal-类型" class="headerlink" title="同财务相关的金额类数据必须使用 decimal 类型"></a>同财务相关的金额类数据必须使用 decimal 类型</h4><p><strong>非精准浮点：float,double</strong><br><strong>精准浮点：decimal</strong></p><p>decimal 类型为精准浮点数，在<strong>计算时不会丢失精度</strong>。占用空间由定义的宽度决定，每 4 个字节可以存储 9 位数字，并且小数点要占用一个字节。</p><p>并且，decimal 可用于存储比 bigint 更大的整型数据不过， 由于 decimal 需要额外的空间和计算开销，应该尽量只在需要对数据进行精确计算时才使用 decimal 。</p><h4 id="单表不要包含过多字段"><a href="#单表不要包含过多字段" class="headerlink" title="单表不要包含过多字段"></a>单表不要包含过多字段</h4><h3 id="索引设计规范"><a href="#索引设计规范" class="headerlink" title="索引设计规范"></a>索引设计规范</h3><h4 id="限制每张表上的索引数量-建议单张表索引不超过-5-个"><a href="#限制每张表上的索引数量-建议单张表索引不超过-5-个" class="headerlink" title="限制每张表上的索引数量,建议单张表索引不超过 5 个"></a>限制每张表上的索引数量,建议单张表索引不超过 5 个</h4><p>索引并不是越多越好！索引可以提高效率同样可以降低效率。</p><p>索引可以增加查询效率，但同样也会降低插入和更新的效率，甚至有些情况下会降低查询效率。</p><p>因为 MySQL 优化器在选择如何优化查询时，会根据统一信息，对每一个可以用到的索引来进行评估，以生成出一个最好的执行计划，如果同时有很多个索引都可以用于查询，就会增加 MySQL 优化器生成执行计划的时间，同样会降低查询性能。</p><h4 id="禁止使用全文索引"><a href="#禁止使用全文索引" class="headerlink" title="禁止使用全文索引"></a>禁止使用全文索引</h4><p>全文索引不适用于 OLTP(联机事务处理) 场景。</p><h4 id="禁止给表中的每一列都建立单独的索引"><a href="#禁止给表中的每一列都建立单独的索引" class="headerlink" title="禁止给表中的每一列都建立单独的索引"></a>禁止给表中的每一列都建立单独的索引</h4><p>5.6 版本之前，一个 sql 只能使用到一个表中的一个索引，5.6 以后，虽然有了合并索引的优化方式，但是还是远远没有使用一个联合索引的查询方式好。</p><h4 id="每个-InnoDB-表必须有个主键"><a href="#每个-InnoDB-表必须有个主键" class="headerlink" title="每个 InnoDB 表必须有个主键"></a>每个 InnoDB 表必须有个主键</h4><p>InnoDB 是一种索引组织表：数据的存储的逻辑顺序和索引的顺序是相同的。每个表都可以有多个索引，但是表的存储顺序只能有一种。</p><p>InnoDB 是按照主键索引的顺序来组织表的:</p><ul><li>不要使用更新频繁的列作为主键，不使用多列主键（相当于联合索引）</li><li>不要使用 UUID,MD5,HASH,字符串列作为主键（无法保证数据的顺序增长）</li><li>主键建议使用自增 ID 值</li></ul><h4 id="常见索引列建议常见索引列建议"><a href="#常见索引列建议常见索引列建议" class="headerlink" title="常见索引列建议常见索引列建议"></a>常见索引列建议常见索引列建议</h4><ul><li>出现在 SELECT、UPDATE、DELETE 语句的 WHERE 从句中的列</li><li>包含在 ORDER BY、GROUP BY、DISTINCT 中的字段</li><li>并不要将符合 1 和 2 中的字段的列都建立一个索引， 通常将 1、2 中的字段建立联合索引效果更好</li><li>多表 join 的关联列</li></ul><h4 id="如何选择索引列的顺序"><a href="#如何选择索引列的顺序" class="headerlink" title="如何选择索引列的顺序"></a>如何选择索引列的顺序</h4><p>建立索引的目的是：希望通过索引进行数据查找，减少随机 IO，增加查询性能 ，索引能过滤出越少的数据，则从磁盘中读入的数据也就越少。</p><ul><li>区分度最高的放在联合索引的最左侧（区分度=列中不同值的数量/列的总行数）</li><li>尽量把字段长度小的列放在联合索引的最左侧（因为字段长度越小，一页能存储的数据量越大，IO 性能也就越好）</li><li>使用最频繁的列放到联合索引的左侧（这样可以比较少的建立一些索引）</li></ul><h4 id="避免建立冗余索引和重复索引（增加了查询优化器生成执行计划的时间）"><a href="#避免建立冗余索引和重复索引（增加了查询优化器生成执行计划的时间）" class="headerlink" title="避免建立冗余索引和重复索引（增加了查询优化器生成执行计划的时间）"></a>避免建立冗余索引和重复索引（增加了查询优化器生成执行计划的时间）</h4><ul><li>重复索引示例：primary key(id)、index(id)、unique index(id)</li><li>冗余索引示例：index(a,b,c)、index(a,b)、index(a)</li></ul><h4 id="对于频繁的查询优先考虑使用覆盖索引"><a href="#对于频繁的查询优先考虑使用覆盖索引" class="headerlink" title="对于频繁的查询优先考虑使用覆盖索引"></a>对于频繁的查询优先考虑使用覆盖索引</h4><blockquote><p>覆盖索引：就是包含了所有查询字段 (where,select,order by,group by 包含的字段) 的索引</p></blockquote><p>覆盖索引的好处：</p><ul><li><strong>避免 InnoDB 表进行索引的二次查询:</strong> InnoDB 是以聚集索引的顺序来存储的，对于 InnoDB 来说，二级索引在叶子节点中所保存的是行的主键信息，如果是用二级索引查询数据的话，在查找到相应的键值后，还要通过主键进行二次查询才能获取我们真实所需要的数据。而在覆盖索引中，二级索引的键值中可以获取所有的数据，避免了对主键的二次查询 ，减少了 IO 操作，提升了查询效率。</li><li><strong>可以把随机 IO 变成顺序 IO 加快查询效率:</strong> 由于覆盖索引是按键值的顺序存储的，对于 IO 密集型的范围查找来说，对比随机从磁盘读取每一行的数据 IO 要少的多，因此利用覆盖索引在访问时也可以把磁盘的随机读取的 IO 转变成索引查找的顺序 IO。</li></ul><h4 id="索引-SET-规范"><a href="#索引-SET-规范" class="headerlink" title="索引 SET 规范"></a>索引 SET 规范</h4><p>尽量避免使用外键约束</p><ul><li>不建议使用外键约束（foreign key），但一定要在表与表之间的关联键上建立索引</li><li>外键可用于保证数据的参照完整性，但建议在业务端实现</li><li>外键会影响父表和子表的写操作从而降低性能</li></ul><h3 id="数据库-SQL-开发规范"><a href="#数据库-SQL-开发规范" class="headerlink" title="数据库 SQL 开发规范"></a>数据库 SQL 开发规范</h3><h4 id="尽量不在数据库做运算，复杂运算需移到业务应用里完成"><a href="#尽量不在数据库做运算，复杂运算需移到业务应用里完成" class="headerlink" title="尽量不在数据库做运算，复杂运算需移到业务应用里完成"></a>尽量不在数据库做运算，复杂运算需移到业务应用里完成</h4><h4 id="优化对性能影响较大的-SQL-语句"><a href="#优化对性能影响较大的-SQL-语句" class="headerlink" title="优化对性能影响较大的 SQL 语句"></a>优化对性能影响较大的 SQL 语句</h4><h4 id="充分利用表上已经存在的索引"><a href="#充分利用表上已经存在的索引" class="headerlink" title="充分利用表上已经存在的索引"></a>充分利用表上已经存在的索引</h4><p>避免使用双%号的查询条件。如：<code>a like &#39;%123%&#39;</code>，（如果无前置%,只有后置%，是可以用到列上的索引的）</p><p>一个 SQL 只能利用到复合索引中的一列进行范围查询。如：有 a,b,c 列的联合索引，在查询条件中有 a 列的范围查询，则在 b,c 列上的索引将不会被用到。</p><p>在定义联合索引时，如果 a 列要用到范围查找的话，就要把 a 列放到联合索引的右侧，使用 left join 或 not exists 来优化 not in 操作，因为 not in 也通常会使用索引失效。</p><h4 id="禁止使用-SELECT-必须使用-SELECT-lt-字段列表-gt-查询"><a href="#禁止使用-SELECT-必须使用-SELECT-lt-字段列表-gt-查询" class="headerlink" title="禁止使用 SELECT * 必须使用 SELECT &lt;字段列表&gt; 查询"></a>禁止使用 SELECT * 必须使用 SELECT &lt;字段列表&gt; 查询</h4><p><code>SELECT *</code> 会消耗更多的 CPU。<br><code>SELECT *</code> 无用字段增加网络带宽资源消耗，增加数据传输时间，尤其是大字段（如 varchar、blob、text）。<br><code>SELECT *</code> 无法使用 MySQL 优化器覆盖索引的优化（基于 MySQL 优化器的“覆盖索引”策略又是速度极快，效率极高，业界极为推荐的查询优化方式）<br><code>SELECT &lt;字段列表&gt;</code> 可减少表结构变更带来的影响</p><h4 id="禁止使用不含字段列表的-INSERT-语句"><a href="#禁止使用不含字段列表的-INSERT-语句" class="headerlink" title="禁止使用不含字段列表的 INSERT 语句"></a>禁止使用不含字段列表的 INSERT 语句</h4><p>如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span> (<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>);</span><br></pre></td></tr></table></figure><p>应使用：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t(c1,c2,c3) <span class="keyword">values</span> (<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>);</span><br></pre></td></tr></table></figure><h4 id="建议使用预编译语句进行数据库操作"><a href="#建议使用预编译语句进行数据库操作" class="headerlink" title="建议使用预编译语句进行数据库操作"></a>建议使用预编译语句进行数据库操作</h4><ul><li>预编译语句可以重复使用这些计划，减少 SQL 编译所需要的时间，还可以解决动态 SQL 所带来的 SQL 注入的问题。</li><li>只传参数，比传递 SQL 语句更高效。</li><li>相同语句可以一次解析，多次使用，提高处理效率。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">prepare</span> ins <span class="keyword">from</span> <span class="string">&#x27;insert into t select ?,?&#x27;</span>;  #预编译</span><br><span class="line"><span class="keyword">set</span> <span class="variable">@a</span><span class="operator">=</span><span class="number">999</span>,<span class="variable">@b</span><span class="operator">=</span><span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line"><span class="keyword">execute</span> ins <span class="keyword">using</span> <span class="variable">@a</span>,<span class="variable">@b</span>; #传参使用预编译语句</span><br></pre></td></tr></table></figure><h4 id="避免数据类型的隐式转换"><a href="#避免数据类型的隐式转换" class="headerlink" title="避免数据类型的隐式转换"></a>避免数据类型的隐式转换</h4><h4 id="避免使用子查询，可以把子查询优化为-join-操作"><a href="#避免使用子查询，可以把子查询优化为-join-操作" class="headerlink" title="避免使用子查询，可以把子查询优化为 join 操作"></a>避免使用子查询，可以把子查询优化为 join 操作</h4><p>通常子查询在 in 子句中，且子查询中为简单 SQL(不包含 union、group by、order by、limit 从句) 时,才可以把子查询转化为关联查询进行优化。</p><p><strong>子查询性能差的原因：</strong> 子查询的结果集无法使用索引，通常子查询的结果集会被存储到临时表中，不论是内存临时表还是磁盘临时表都不会存在索引，所以查询性能会受到一定的影响。特别是对于返回结果集比较大的子查询，其对查询性能的影响也就越大。由于子查询会产生大量的临时表也没有索引，所以会消耗过多的 CPU 和 IO 资源，产生大量的慢查询。</p><h4 id="避免使用-JOIN-关联太多的表"><a href="#避免使用-JOIN-关联太多的表" class="headerlink" title="避免使用 JOIN 关联太多的表"></a>避免使用 JOIN 关联太多的表</h4><p>会占用大量内存,有可能出现内存溢出</p><h4 id="减少同数据库的交互次数"><a href="#减少同数据库的交互次数" class="headerlink" title="减少同数据库的交互次数"></a>减少同数据库的交互次数</h4><p>数据库更适合处理批量操作，合并多个相同的操作到一起，可以提高处理效率。</p><h4 id="对应同一列进行-or-判断时，使用-in-代替-or"><a href="#对应同一列进行-or-判断时，使用-in-代替-or" class="headerlink" title="对应同一列进行 or 判断时，使用 in 代替 or"></a>对应同一列进行 or 判断时，使用 in 代替 or</h4><p>in 的值不要超过 500 个，in 操作可以更有效的利用索引，or 大多数情况下很少能利用到索引。</p><h4 id="禁止使用-order-by-rand-进行随机排序"><a href="#禁止使用-order-by-rand-进行随机排序" class="headerlink" title="禁止使用 order by rand() 进行随机排序"></a>禁止使用 order by rand() 进行随机排序</h4><p>order by rand() 会把表中所有符合条件的数据装载到内存中，然后在内存中对所有数据根据随机生成的值进行排序，并且可能会对每一行都生成一个随机值，如果满足条件的数据集非常大，就会消耗大量的 CPU 和 IO 及内存资源。推荐在程序中获取一个随机值，然后从数据库中获取数据的方式。</p><h4 id="WHERE-从句中禁止对列进行函数转换和计算"><a href="#WHERE-从句中禁止对列进行函数转换和计算" class="headerlink" title="WHERE 从句中禁止对列进行函数转换和计算"></a>WHERE 从句中禁止对列进行函数转换和计算</h4><p>对列进行函数转换或计算时会导致无法使用索引</p><p><strong>不推荐：</strong><br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">where</span> <span class="type">date</span>(create_time)<span class="operator">=</span><span class="string">&#x27;20190101&#x27;</span></span><br></pre></td></tr></table></figure><br><strong>推荐：</strong><br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">where</span> create_time <span class="operator">&gt;=</span> <span class="string">&#x27;20190101&#x27;</span> <span class="keyword">and</span> create_time <span class="operator">&lt;</span> <span class="string">&#x27;20190102&#x27;</span></span><br></pre></td></tr></table></figure></p><h4 id="在明显不会有重复值时使用-UNION-ALL-而不是-UNION"><a href="#在明显不会有重复值时使用-UNION-ALL-而不是-UNION" class="headerlink" title="在明显不会有重复值时使用 UNION ALL 而不是 UNION"></a>在明显不会有重复值时使用 UNION ALL 而不是 UNION</h4><ul><li>UNION 会把两个结果集的所有数据放到临时表中后再进行去重操作</li><li>UNION ALL 不会再对结果集进行去重操作</li></ul><h4 id="拆分复杂的大-SQL-为多个小-SQL"><a href="#拆分复杂的大-SQL-为多个小-SQL" class="headerlink" title="拆分复杂的大 SQL 为多个小 SQL"></a>拆分复杂的大 SQL 为多个小 SQL</h4><ul><li>大 SQL 逻辑上比较复杂，需要占用大量 CPU 进行计算的 SQL</li><li>MySQL 中，一个 SQL 只能使用一个 CPU 进行计算</li><li>SQL 拆分后可以通过并行执行来提高处理效率</li></ul><h4 id="程序连接不同的数据库使用不同的账号，禁止跨库查询"><a href="#程序连接不同的数据库使用不同的账号，禁止跨库查询" class="headerlink" title="程序连接不同的数据库使用不同的账号，禁止跨库查询"></a>程序连接不同的数据库使用不同的账号，禁止跨库查询</h4><ul><li>为数据库迁移和分库分表留出余地</li><li>降低业务耦合度</li><li>避免权限过大而产生的安全风险</li></ul><h3 id="数据库操作行为规范"><a href="#数据库操作行为规范" class="headerlink" title="数据库操作行为规范"></a>数据库操作行为规范</h3><h4 id="超-100-万行的批量写-UPDATE-DELETE-INSERT-操作-要分批多次进行操作"><a href="#超-100-万行的批量写-UPDATE-DELETE-INSERT-操作-要分批多次进行操作" class="headerlink" title="超 100 万行的批量写 (UPDATE,DELETE,INSERT) 操作,要分批多次进行操作"></a>超 100 万行的批量写 (UPDATE,DELETE,INSERT) 操作,要分批多次进行操作</h4><p><strong>大批量操作可能会造成严重的主从延迟</strong></p><p>主从环境中,大批量操作可能会造成严重的主从延迟，大批量的写操作一般都需要执行一定长的时间，而只有当主库上执行完成后，才会在其他从库上执行，所以会造成主库与从库长时间的延迟情况</p><p><strong>binlog 日志为 row 格式时会产生大量的日志</strong></p><p>大批量写操作会产生大量日志，特别是对于 row 格式二进制数据而言，由于在 row 格式中会记录每一行数据的修改，我们一次修改的数据越多，产生的日志量也就会越多，日志的传输和恢复所需要的时间也就越长，这也是造成主从延迟的一个原因</p><p><strong>避免产生大事务操作</strong></p><p>大批量修改数据，一定是在一个事务中进行的，这就会造成表中大批量数据进行锁定，从而导致大量的阻塞，阻塞会对 MySQL 的性能产生非常大的影响。特别是长时间的阻塞会占满所有数据库的可用连接，这会使生产环境中的其他应用无法连接到数据库，因此一定要注意大批量写操作要进行分批</p><h4 id="对于大表使用-pt-online-schema-change-修改表结构"><a href="#对于大表使用-pt-online-schema-change-修改表结构" class="headerlink" title="对于大表使用 pt-online-schema-change 修改表结构"></a>对于大表使用 pt-online-schema-change 修改表结构</h4><ul><li>避免大表修改产生的主从延迟</li><li>避免在对表字段进行修改时进行锁表</li></ul><p>对大表数据结构的修改一定要谨慎，会造成严重的锁表操作，尤其是生产环境，是不能容忍的。</p><p><code>pt-online-schema-change</code> 它会首先建立一个与原表结构相同的新表，并且在新表上进行表结构的修改，然后再把原表中的数据复制到新表中，并在原表中增加一些触发器。把原表中新增的数据也复制到新表中，在行所有数据复制完成之后，把新表命名成原表，并把原来的表删除掉。把原来一个 DDL 操作，分解成多个小的批次进行。</p><h4 id="禁止为程序使用的账号赋予-super-权限"><a href="#禁止为程序使用的账号赋予-super-权限" class="headerlink" title="禁止为程序使用的账号赋予 super 权限"></a>禁止为程序使用的账号赋予 super 权限</h4><ul><li>当达到最大连接数限制时，还运行 1 个有 super 权限的用户连接</li><li>super 权限只能留给 DBA 处理问题的账号使用</li></ul><h4 id="对于程序连接数据库账号-遵循权限最小原则"><a href="#对于程序连接数据库账号-遵循权限最小原则" class="headerlink" title="对于程序连接数据库账号,遵循权限最小原则"></a>对于程序连接数据库账号,遵循权限最小原则</h4><ul><li>程序使用数据库账号只能在一个 DB 下使用，不准跨库</li><li>程序使用的账号原则上不准有 drop 权限</li></ul><p><strong>Reference:</strong><br> <a href="https://javaguide.cn/database/mysql/mysql-high-performance-optimization-specification-recommendations.html" style="color: #177cb0; text-decoration: underline;text-decoration-style: dotted;">MySQL高性能优化规范建议总结</a></p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL锁</title>
      <link href="/2023/12/21/MySQL%E9%94%81/"/>
      <url>/2023/12/21/MySQL%E9%94%81/</url>
      
        <content type="html"><![CDATA[<h3 id="MySQL锁"><a href="#MySQL锁" class="headerlink" title="MySQL锁"></a>MySQL锁</h3><h4 id="表级锁和行级锁"><a href="#表级锁和行级锁" class="headerlink" title="表级锁和行级锁"></a>表级锁和行级锁</h4><p><strong>MyISAM</strong> (MySQL5.5版本以前默认的存储引擎) 仅仅支持表级锁，一锁就锁整张表，这在并发写的情况下性非常差。</p><p><strong>InnoDB</strong> (MySQL5.5版本后默认的存储引擎) 不光支持表级锁，还支持行级锁，默认为行级锁。行级锁的粒度更小，仅对相关的记录上锁即可（对一行或者多行记录加锁），所以对于并发写入操作来说， InnoDB 的性能更高。</p><p><strong>表级锁和行级锁对比：</strong></p><ul><li><p><strong>表级锁</strong>： MySQL 中锁定粒度最大的一种锁（全局锁除外），是针对非索引字段加的锁，对当前操作的整张表加锁，实现简单，资源消耗也比较少，加锁快，不会出现死锁。不过，触发锁冲突的概率最高，高并发下效率极低。表级锁和存储引擎无关，MyISAM 和 InnoDB 引擎都支持表级锁。</p></li><li><p><strong>行级锁</strong>： MySQL 中锁的粒度最小的一种锁，是 针对索引字段加的锁 ，只针对当前操作的行记录进行加锁。 行级锁能大大减少数据库操作的冲突。<strong>其加锁粒度最小，并发度高，但加锁的开销也最大，加锁慢，会出现死锁</strong>。行级锁和存储引擎有关，是在存储引擎层面实现的。</p></li></ul><p>InnoDB 的行锁是针对索引字段加的锁，表级锁是针对非索引字段加的锁。当我们执行 UPDATE、DELETE 语句时，如果 WHERE条件中字段没有命中唯一索引或者索引失效的话，就会导致扫描全表对表中的所有行记录进行加锁。</p><h4 id="InnoDB-有哪几类行锁？"><a href="#InnoDB-有哪几类行锁？" class="headerlink" title="InnoDB 有哪几类行锁？"></a>InnoDB 有哪几类行锁？</h4><p>MySQL InnoDB 支持三种行锁定方式：</p><ul><li><strong>记录锁</strong>（Record Lock）：属于单个行记录上的锁。</li><li><strong>间隙锁</strong>（Gap Lock）：锁定一个范围，不包括记录本身。</li></ul><p>假设，表中有一个范围 id 为（3，5）间隙锁，那么其他事务就无法插入 id = 4 这条记录了，这样就有效的防止幻读现象的发生。</p><p><img src="https://pb01.s3.bitiful.net/gap.drawio.webp" alt="avatar"></p><p>间隙锁之间是兼容的，即两个事务可以同时持有包含共同间隙范围的间隙锁，并不存在互斥关系，因为间隙锁的目的是防止插入幻影记录而提出的。</p><ul><li><strong>临键锁</strong>（Next-Key Lock）：Record Lock+Gap Lock，锁定一个范围，包含记录本身，主要目的是为了解决幻读问题。记录锁只能锁住已经存在的记录，为了避免插入新记录，需要依赖间隙锁。</li></ul><p>Next-Key Lock 称为临键锁，是 Record Lock + Gap Lock 的组合，锁定一个范围，并且锁定记录本身。</p><p>假设，表中有一个范围 id 为(3，5] 的 next-key lock，那么其他事务即不能插入 id = 4 记录，也不能修改 id = 5 这条记录。</p><p><img src="https://pb01.s3.bitiful.net/nextkey.drawio.webp" alt="avatar"></p><p>next-key lock 是包含间隙锁+记录锁的，如果一个事务获取了 X 型的 next-key lock，那么另外一个事务在获取相同范围的 X 型的 next-key lock 时，是会被阻塞的。</p><p>虽然相同范围的间隙锁是多个事务相互兼容的，但对于记录锁，我们是要考虑 X 型与 S 型关系，X 型的记录锁与 X 型的记录锁是冲突的。</p><p>在 InnoDB 默认的隔离级别 <code>REPEATABLE-READ</code>(可重复读) 下，行锁默认使用的是 <code>Next-Key Lock</code>。但是，如果操作的索引是唯一索引或主键，InnoDB 会对 <code>Next-Key Lock</code> 进行优化，将其降级为 <code>Record Lock</code>，即仅锁住索引本身，而不是范围。</p><h4 id="意向锁"><a href="#意向锁" class="headerlink" title="意向锁"></a>意向锁</h4><p>如果需要用到表锁的话，如何判断表中的记录没有行锁呢(<strong>表锁和行锁是满足读读共享、读写互斥、写写互斥的</strong>)，一行一行遍历肯定是不行，性能太差。我们需要用做意向锁来快速判断是否可以对某个表使用表锁。</p><p>是一种表级锁。</p><p>意向锁是一种表级锁,分为两种：</p><ul><li><strong>意向共享锁</strong>（IS）：事务有意向对表中的某些记录加共享锁（S 锁），加共享锁前必须先取得该表的 IS 锁</li><li><strong>意向排他锁</strong>（IX）：事务有意向对表中的某些记录加排他锁（X 锁），加排他锁之前必须先取得该表的 IX 锁</li></ul><p>意向锁是由数据引擎自己维护的，用户无法手动操作意向锁，在为数据行加共享/排他锁之前，InooDB 会先获取该数据行所在在数据表的对应意向锁。</p><p>意向锁之间是互相兼容的:</p><div class="table-container"><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">IS 锁</th><th style="text-align:center">IX 锁</th></tr></thead><tbody><tr><td style="text-align:center">IS 锁</td><td style="text-align:center">兼容</td><td style="text-align:center">兼容</td></tr><tr><td style="text-align:center">IX 锁</td><td style="text-align:center">兼容</td><td style="text-align:center">兼容</td></tr></tbody></table></div><p>意向锁和共享锁和排它锁互斥（这里指的是表级别的共享锁和排他锁，意向锁不会与行级的共享锁和排他锁互斥）。</p><div class="table-container"><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">IS 锁</th><th style="text-align:center">IX 锁</th></tr></thead><tbody><tr><td style="text-align:center">S 锁</td><td style="text-align:center">兼容</td><td style="text-align:center">互斥</td></tr><tr><td style="text-align:center">X 锁</td><td style="text-align:center">互斥</td><td style="text-align:center">互斥</td></tr></tbody></table></div><h4 id="自增锁"><a href="#自增锁" class="headerlink" title="自增锁"></a>自增锁</h4><p>设置<code>AUTO_INCREMENT</code>的列都会涉及到自增锁. </p><p>AUTO-INC 锁是特殊的表锁机制，锁不是在一个事务提交后才释放，而是在执行完插入语句后就会立即释放。</p><p>在插入数据时，会加一个表级别的 AUTO-INC 锁，然后为被 AUTO_INCREMENT 修饰的字段赋值(递增的值)，等插入语句执行完成后，才会把 AUTO-INC 锁释放掉。</p><p>那么，一个事务在持有 AUTO-INC 锁的过程中，其他事务的如果要向该表插入语句都会被阻塞，从而保证插入数据时，被 AUTO_INCREMENT 修饰的字段的值是连续递增的。</p><p>但是， AUTO-INC 锁再对大量数据进行插入的时候，会影响插入性能，因为另一个事务中的插入会被阻塞。</p><p>因此， 在 MySQL 5.1.22 版本开始，InnoDB 存储引擎提供了一种轻量级的锁来实现自增。</p><p>一样也是在插入数据的时候，会为被 AUTO_INCREMENT 修饰的字段加上轻量级锁，然后给该字段赋值一个自增的值，就把这个轻量级锁释放了，而不需要等待整个插入语句执行完后才释放锁。</p><p>InnoDB 存储引擎提供了个 <code>innodb_autoinc_lock_mode</code> 的系统变量，是用来控制选择用 AUTO-INC 锁，还是轻量级的锁。</p><div class="table-container"><table><thead><tr><th style="text-align:center">innodb_autoinc_lock_mode</th><th style="text-align:center">介绍</th></tr></thead><tbody><tr><td style="text-align:center">0</td><td style="text-align:center">传统模式</td></tr><tr><td style="text-align:center">1</td><td style="text-align:center">连续模式（MySQL 8.0 之前默认）</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">交错模式(MySQL 8.0 之后默认)</td></tr></tbody></table></div><ul><li>当 <strong>innodb_autoinc_lock_mode = 0</strong>，就采用 AUTO-INC 锁，语句执行结束后才释放锁；</li><li>当 <strong>innodb_autoinc_lock_mode = 2</strong>，就采用轻量级锁，申请自增主键后就释放锁，并不需要等语句执行后才释放。</li><li>当 <strong>innodb_autoinc_lock_mode = 1</strong>：<ul><li>普通 insert 语句，自增锁在申请之后就马上释放；</li><li>类似 insert … select 这样的批量插入数据的语句，自增锁还是要等语句结束后才被释放；</li></ul></li></ul><h4 id="References"><a href="#References" class="headerlink" title="References"></a>References</h4><ul><li>javaguide</li><li>小林coding<br>…</li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL事务</title>
      <link href="/2023/12/21/MySQL%E4%BA%8B%E5%8A%A1/"/>
      <url>/2023/12/21/MySQL%E4%BA%8B%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<h3 id="MySQL事务"><a href="#MySQL事务" class="headerlink" title="MySQL事务"></a>MySQL事务</h3><h4 id="什么是事务"><a href="#什么是事务" class="headerlink" title="什么是事务"></a>什么是事务</h4><p><strong>事务是逻辑上的一组操作，要么都执行，要么都不执行</strong>。</p><p>事务最经典也经常被拿出来说例子就是转账了。假如小明要给小红转账 1000 元，这个转账会涉及到两个关键操作，这两个操作必须都成功或者都失败。</p><ol><li>将小明的余额减少 1000 元</li><li>将小红的余额增加 1000 元</li></ol><p>事务会把这两个操作看成逻辑上的一个整体，这个整体包含的操作要么都成功，要么都要失败。这样就不会出现小明余额减少而小红的余额却并没有增加的情况。</p><h4 id="数据库事务"><a href="#数据库事务" class="headerlink" title="数据库事务"></a>数据库事务</h4><p>大多数情况下，我们在谈论事务的时候，如果没有特指分布式事务，往往指的就是数据库事务。</p><p>数据库事务在我们日常开发中接触的最多了。如果你的项目属于单体架构的话，你接触到的往往就是数据库事务了。那数据库事务有什么作用呢？</p><p>简单来说，数据库事务可以保证多个对数据库的操作（也就是 SQL 语句）构成一个逻辑上的整体。构成这个逻辑上的整体的这些数据库操作遵循：<strong>要么全部执行成功,要么全部不执行</strong> 。</p><p><img src="https://pb01.s3.bitiful.net/140.png" alt="avatar"></p><h4 id="事务的-ACID-特性"><a href="#事务的-ACID-特性" class="headerlink" title="事务的 ACID 特性"></a>事务的 ACID 特性</h4><p>ACID，是指关系型数据库事务正确执行的四个基本要素的缩写。包含：</p><ul><li>原子性（Atomicity）</li><li>一致性（Consistency）</li><li>隔离性（Isolation）</li><li>持久性（Durability）</li></ul><h5 id="原子性（Atomicity）"><a href="#原子性（Atomicity）" class="headerlink" title="原子性（Atomicity）"></a>原子性（Atomicity）</h5><p><strong>原子性是指事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生。</strong></p><p>事务的原子性是事务<strong>最核心</strong>的特性。</p><h5 id="一致性（Consistency）"><a href="#一致性（Consistency）" class="headerlink" title="一致性（Consistency）"></a>一致性（Consistency）</h5><p><strong>一致性是指事务执行前后，数据保持一致。</strong></p><p>比如小明给小红转账，转账前后小明和小红的余额的变化大小是相同的。</p><h5 id="隔离性（Isolation）"><a href="#隔离性（Isolation）" class="headerlink" title="隔离性（Isolation）"></a>隔离性（Isolation）</h5><p><strong>隔离性是指多个用户并发访问数据库时，一个用户的事务不能被其他用户的事务所干扰，多个并发事务之间要相互隔离。</strong></p><p>比如，一个用户正在操作数据库 A，其他用户不能操作数据库 A。</p><h5 id="持久性（Durability）"><a href="#持久性（Durability）" class="headerlink" title="持久性（Durability）"></a>持久性（Durability）</h5><p><strong>持久性是指一个事务一旦被提交，它对数据库中数据的改变就是永久性的，接下来即使数据库发生故障也不应该对其影响。</strong></p><p>比如，一个事务对数据库中数据的改变已经写入磁盘，即使数据库发生故障，这个事务对数据库中数据的改变也不应该丢失。</p><p>🌈 这里要额外补充一点：只有保证了事务的持久性、原子性、隔离性之后，一致性才能得到保障。也就是说 <strong>A、I、D 是手段，C 是目的</strong>！</p><h4 id="MySQL事务操作"><a href="#MySQL事务操作" class="headerlink" title="MySQL事务操作"></a>MySQL事务操作</h4><p>mysql中事务<strong>默认是隐式事务</strong>，执行insert、update、delete操作的时候，数据库自动开启事务、提交或回滚事务。</p><p>是否开启隐式事务是由变量autocommit控制的。</p><h4 id="隐式事务"><a href="#隐式事务" class="headerlink" title="隐式事务"></a>隐式事务</h4><p>事务自动开启、提交或回滚，比如insert、update、delete语句，事务的开启、提交或回滚由mysql内部自动控制的。</p><p>查看变量autocommit是否开启了自动提交</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;autocommit&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">---------------+-------+</span></span><br><span class="line"><span class="operator">|</span> Variable_name <span class="operator">|</span> <span class="keyword">Value</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------------+-------+</span></span><br><span class="line"><span class="operator">|</span> autocommit   <span class="operator">|</span> <span class="keyword">ON</span>   <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------------+-------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span>, <span class="number">1</span> warning (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><h4 id="显式事务"><a href="#显式事务" class="headerlink" title="显式事务"></a>显式事务</h4><p>显式事务需要手动开启、提交或回滚，由开发者自己控制。</p><p><strong>方式1</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 设置不自动提交事务</span><br><span class="line"><span class="keyword">set</span> autocommit<span class="operator">=</span><span class="number">0</span>;</span><br><span class="line"># 执行事务操作</span><br><span class="line">SQL1,SQL2...</span><br><span class="line">## 提交或回滚</span><br><span class="line"><span class="keyword">commit</span><span class="operator">|</span><span class="keyword">rollback</span>;</span><br></pre></td></tr></table></figure><p><strong>方式2</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 开启一个事务</span><br><span class="line"><span class="keyword">START</span> TRANSACTION;</span><br><span class="line"># 执行事务操作</span><br><span class="line">SQL1,SQL2...</span><br><span class="line">## 提交或回滚</span><br><span class="line"><span class="keyword">commit</span><span class="operator">|</span><span class="keyword">rollback</span>;</span><br></pre></td></tr></table></figure><h4 id="并发事务带来了哪些问题"><a href="#并发事务带来了哪些问题" class="headerlink" title="并发事务带来了哪些问题?"></a>并发事务带来了哪些问题?</h4><p>在典型的应用程序中，多个事务并发运行，经常会操作相同的数据来完成各自的任务（多个用户对同一数据进行操作）。并发虽然是必须的，但可能会导致很多问题。</p><h5 id="脏读（Dirty-read）"><a href="#脏读（Dirty-read）" class="headerlink" title="脏读（Dirty read）"></a>脏读（Dirty read）</h5><p>一个事务读取数据并且对数据进行了修改，这个修改对其他事务来说是可见的，即使当前事务没有提交。这时另外一个事务读取了这个还未提交的数据，但第一个事务突然回滚，导致数据并没有被提交到数据库，那第二个事务读取到的就是脏数据，这也就是脏读的由来。</p><h5 id="丢失修改（Lost-to-modify）"><a href="#丢失修改（Lost-to-modify）" class="headerlink" title="丢失修改（Lost to modify）"></a>丢失修改（Lost to modify）</h5><p>在一个事务读取一个数据时，另外一个事务也访问了该数据，那么在第一个事务中修改了这个数据后，第二个事务也修改了这个数据。这样第一个事务内的修改结果就被丢失，因此称为丢失修改。</p><h5 id="不可重复读（Unrepeatable-read）"><a href="#不可重复读（Unrepeatable-read）" class="headerlink" title="不可重复读（Unrepeatable read）"></a>不可重复读（Unrepeatable read）</h5><p>指在一个事务内多次读同一数据。在这个事务还没有结束时，另一个事务也访问该数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改导致第一个事务两次读取的数据可能不太一样。这就发生了在一个事务内两次读到的数据是不一样的情况，因此称为不可重复读。</p><h5 id="幻读（Phantom-read）"><a href="#幻读（Phantom-read）" class="headerlink" title="幻读（Phantom read）"></a>幻读（Phantom read）</h5><p>幻读与不可重复读类似。它发生在一个事务（T1）读取了几行数据，接着另一个并发事务（T2）插入了一些数据时。在随后的查询中，第一个事务（T1）就会发现有它本来没有的数据，就好像发生了幻觉一样，所以称为幻读。</p><p><strong>不可重复读和幻读有什么区别？</strong></p><p><code>不可重复读侧重于修改，幻读侧重于新增或删除。</code></p><h4 id="并发事务的控制方式有哪些？"><a href="#并发事务的控制方式有哪些？" class="headerlink" title="并发事务的控制方式有哪些？"></a>并发事务的控制方式有哪些？</h4><p>MySQL 中并发事务的控制方式无非就两种：<strong>锁 和 MVCC</strong>。锁可以看作是悲观控制的模式，多版本并发控制（MVCC）可以看作是乐观控制的模式。</p><p>锁控制方式下会通过锁来显示控制共享资源而不是通过调度手段，MySQL中主要是通过<strong>读写锁</strong>来实现并发控制。</p><ul><li><strong>共享锁（S 锁）</strong>：又称读锁，事务在读取记录的时候获取共享锁，允许多个事务同时获取（锁兼容）。</li><li><strong>排他锁（X 锁）</strong>：又称写锁/独占锁，事务在修改记录的时候获取排他锁，不允许多个事务同时获取。如果一个记录已经被加了排他锁，那其他事务不能再对这条记录加任何类型的锁（锁不兼容）。</li></ul><p>读写锁可以做到读读并行，但是无法做到写读、写写并行。另外，根据根据锁粒度的不同，又被分为表级锁 和 行级锁。InnoDB(MySQL5.5版本后的默认存储引擎) 不光支持表级锁，还支持行级锁，默认为行级锁。</p><p>行级锁的粒度更小，仅对相关的记录上锁即可（对一行或者多行记录加锁），所以对于并发写入操作来说， InnoDB 的性能更高。不论是表级锁还是行级锁，都存在共享锁和排他锁。</p><p>MVCC 是多版本并发控制方法，即对一份数据会存储多个版本，通过事务的可见性来保证事务能看到自己应该看到的版本。通常会有一个全局的版本分配器来为每一行数据设置版本号，版本号是唯一的。</p><p>MVCC 在 MySQL 中实现所依赖的手段主要是: <strong>隐藏字段、read view、undo log</strong>。</p><ul><li>undo log : undo log 用于记录某行数据的多个版本的数据。</li><li>read view 和 隐藏字段 : 用来判断当前版本数据的可见性。</li></ul><h4 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h4><p>SQL 标准定义了四个隔离级别：</p><ul><li>READ-UNCOMMITTED(读取未提交) ：最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读。</li><li>READ-COMMITTED(读取已提交) ：允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生。</li><li>REPEATABLE-READ(可重复读) ：对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。</li><li>SERIALIZABLE(可串行化) ：最高的隔离级别，完全服从 ACID 的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。</li></ul><p>MySQL InnoDB 存储引擎的默认支持的隔离级别是 <strong>REPEATABLE-READ（可重读）</strong>。我们可以通过<code>SELECT @@tx_isolation;</code>命令来查看，MySQL 8.0 该命令改为<code>SELECT @@transaction_isolation;</code></p><p>从上面对 SQL 标准定义了四个隔离级别的介绍可以看出，标准的 SQL 隔离级别定义里，REPEATABLE-READ(可重复读)是不可以防止幻读的。</p><p>但是！InnoDB 实现的 REPEATABLE-READ 隔离级别其实是可以解决幻读问题发生的，主要有下面两种情况：</p><ul><li><strong>快照读</strong>：由 MVCC 机制来保证不出现幻读。</li><li><strong>当前读</strong>：使用 Next-Key Lock 进行加锁来保证不出现幻读，Next-Key Lock 是行锁（Record Lock）和间隙锁（Gap Lock）的结合，行锁只能锁住已经存在的行，为了避免插入新行，需要依赖间隙锁。</li></ul><p>因为隔离级别越低，事务请求的锁越少，所以大部分数据库系统的隔离级别都是 READ-COMMITTED ，但是你要知道的是 InnoDB 存储引擎默认使用 REPEATABLE-READ 并不会有任何性能损失。</p><p>InnoDB 存储引擎在分布式事务的情况下一般会用到 SERIALIZABLE 隔离级别。</p><p>接下来，举个具体的例子来说明这四种隔离级别，有一张账户余额表，里面有一条账户余额为 100 万的记录。然后有两个并发的事务，事务 A 只负责查询余额，事务 B 则会将我的余额改成 200 万，下面是按照时间顺序执行两个事务的行为：</p><p><img src="https://pb01.s3.bitiful.net/45.webp" alt="avatar"></p><p>在不同隔离级别下，事务 A 执行过程中查询到的余额可能会不同：</p><ul><li><p><code>「读未提交」</code>:事务 B 修改余额后，虽然没有提交事务，但是此时的余额已经可以被事务 A 看见了，于是事务 A 中余额 V1 查询的值是 200 万，余额 V2、V3 自然也是 200 万了；</p></li><li><p><code>「读已提交」</code>:事务 B 修改余额后，因为没有提交事务，所以事务 A 中余额 V1 的值还是 100 万，等事务 B 提交完后，最新的余额数据才能被事务 A 看见，因此额 V2、V3 都是 200 万；</p></li><li><code>「可重复读」</code>:事务 A 只能看见启动事务时的数据，所以余额 V1、余额 V2 的值都是 100 万，当事务 A 提交事务后，就能看见最新的余额数据了，所以余额 V3 的值是 200 万；</li><li><code>「串行化」</code>:事务 B 在执行将余额 100 万修改为 200 万时，由于此前事务 A 执行了读操作，这样就发生了读写冲突，于是就会被锁住，直到事务 A 提交后，事务 B 才可以继续执行，所以从 A 的角度看，余额 V1、V2 的值是 100 万，余额 V3 的值是 200万。</li></ul><p>这四种隔离级别具体是如何实现的呢？</p><p>对于<code>「读未提交」</code>隔离级别的事务来说，因为可以读到未提交事务修改的数据，所以直接读取最新的数据就好了；</p><p>对于<code>「串行化」</code>隔离级别的事务来说，通过加读写锁的方式来避免并行访问；</p><p>对于<code>「读已提交」</code>和<code>「可重复读」</code>隔离级别的事务来说，它们是通过 <code>Read View</code> 来实现的，它们的区别<strong>在于创建 Read View 的时机不同，大家可以把 Read View 理解成一个数据快照，就像相机拍照那样，定格某一时刻的风景。「读已提交」隔离级别是在每个语句执行前都会重新生成一个 Read View，而「可重复读」隔离级别是「启动事务时」生成一个 Read View，然后整个事务期间都在用这个 Read View</strong>。</p><p>注意，执行了 begin/start transaction 命令后，并不代表事务启动了。只有在执行这个命令后，执行了第一条 SQL 语句，才是事务真正启动的时机；</p><h4 id="References"><a href="#References" class="headerlink" title="References"></a>References</h4><ul><li>javaguide</li><li>小林coding<br>…</li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>类加载机制</title>
      <link href="/2023/12/21/JVM4/"/>
      <url>/2023/12/21/JVM4/</url>
      
        <content type="html"><![CDATA[<h2 id="类加载机制"><a href="#类加载机制" class="headerlink" title="类加载机制"></a>类加载机制</h2><p>现在，我们已经了解了字节码文件的结构，以及JVM如何对内存进行管理，现在只剩下最后一个谜团等待解开了，也就是我们的类字节码文件到底是如何加载到内存中的，加载之后又会做什么事情。</p><h3 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h3><p>首先，要加载一个类，一定是出于某种目的的，比如我们要运行我们的Java程序，那么就必须要加载主类才能运行主类中的主方法，又或是我们需要加载数据库驱动，那么可以通过反射来将对应的数据库驱动类进行加载。</p><p>所以，一般在这些情况下，如果类没有被加载，那么会被自动加载：</p><ul><li>使用new关键字创建对象时</li><li>使用某个类的静态成员（包括方法和字段）的时候（当然，final类型的静态字段有可能在编译的时候被放到了当前类的常量池中，这种情况下是不会触发自动加载的）</li><li>使用反射对类信息进行获取的时候（之前的数据库驱动就是这样的）</li><li>加载一个类的子类时</li><li>加载接口的实现类，且接口带有<code>default</code>的方法默认实现时</li></ul><p>比如这种情况，那么需要用到另一个类中的成员字段，所以就必须将另一个类加载之后才能访问：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(Test.str);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">        <span class="keyword">static</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;我被初始化了！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;我被调用了!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们就演示一个不太好理解的情况，我们现在将静态成员变量修改为final类型的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(Test.str);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">        <span class="keyword">static</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;我被初始化了！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;我被调用了!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，在主方法中，我们使用了Test类的静态成员变量，并且此静态成员变量是一个final类型的，也就是说不可能再发生改变。那么各位觉得，Test类会像上面一样被初始化吗？</p><p>按照正常逻辑来说，既然要用到其他类中的字段，那么肯定需要加载其他类，但是这里我们结果发现，并没有对Test类进行加载，那么这是为什么呢？</p><p>在编译阶段，整个<code>Test.str</code>直接被替换为了对应的字符串（因为final不可能发生改变的，编译就会进行优化，直接来个字符串比你去加载类在获取快得多不是吗，反正结果都一样），所以说编译之后，实际上跟Test类半毛钱关系都没有了。</p><p>所以说，当你在某些情况下疑惑为什么类加载了或是没有加载时，可以从字节码指令的角度去进行分析，一般情况下，只要遇到<code>new</code>、<code>getstatic</code>、<code>putstatic</code>、<code>invokestatic</code>这些指令时，都会进行类加载</p><p>好了，聊完了类的加载触发条件，我们接着来看一下类的详细加载流程。</p><p><img src="https://pb01.s3.bitiful.net/136.png" alt="avatar"></p><p>首先类的生命周期一共有7个阶段，而首当其冲的就是<strong>加载</strong>。</p><p>加载阶段需要获取此类的二进制数据流，比如我们要从硬盘中读取一个class文件，那么就可以通过<strong>文件输入流</strong>来获取类文件的<code>byte[]（二进制字节流）</code>，也可以是其他各种途径获取，甚至网络传输并加载一个类也不是不可以。然后交给类加载器进行加载（类加载器可以是JDK内置的，也可以是开发者自己撸的）类的所有信息会被加载到方法区中，并且在堆内存中会生成一个代表当前类的Class类对象（那么思考一下，同一个Class文件加载的类，是唯一存在的吗？），我们可以通过此对象以及反射机制来访问这个类的各种信息。</p><p>每个 Java 类都有一个引用指向加载它的 ClassLoader(类加载器)。不过，数组类不是通过 ClassLoader 创建的（即<strong>不会导致类加载</strong>），而是 JVM 在需要的时候自动创建的，数组类通过getClassLoader()方法获取 ClassLoader 的时候和该数组的元素类型的 ClassLoader 是一致的。</p><p>一个非数组类的加载阶段（加载阶段获取类的二进制字节流的动作）是可控性最强的阶段，这一步我们可以去完成还可以自定义类加载器去控制字节流的获取方式（重写一个类加载器的 loadClass() 方法）。</p><p>加载阶段与连接阶段的部分动作(如一部分字节码文件格式验证动作)是交叉进行的，加载阶段尚未结束，连接阶段可能就已经开始了。</p><p>接着我们来看<strong>验证</strong>阶段，验证阶段相当于是对加载的类进行一次规范校验，如果说类的任何地方不符合虚拟机规范，那么这个类是不会验证通过的，如果没有验证机制，那么一旦出现危害虚拟机的操作，整个程序会出现无法预料的后果。</p><p>验证阶段主要由四个检验阶段组成：</p><ol><li>文件格式验证（Class 文件格式检查）</li><li>元数据验证（字节码语义检查）</li><li>字节码验证（程序语义检查）</li><li>符号引用验证（类的正确性检查）</li></ol><p><img src="https://pb01.s3.bitiful.net/137.png" alt="avatar"></p><p>文件格式验证这一阶段是基于该类的二进制字节流进行的，主要目的是保证输入的字节流能正确地解析并存储于方法区之内，格式上符合描述一个 Java 类型信息的要求。除了这一阶段之外，<strong>其余三个验证阶段都是基于方法区的存储结构上进行的，不会再直接读取、操作字节流了</strong>。</p><p>接下来就是<strong>准备</strong>阶段了，这个阶段会为类变量分配内存，并为一些字段设定初始值，注意是系统规定的初始值，不是我们手动指定的初始值。</p><p>再往下就是<strong>解析</strong>阶段，此阶段是将常量池内的符号引用替换为直接引用的过程，也就是说，到这个时候，所有引用变量的指向都是已经切切实实地指向了内存中的对象了。</p><p>到这里，链接过程就结束了，也就是说这个时候类基本上已经完成大部分内容的初始化了。</p><p>最后就是真正的<strong>初始化</strong>阶段了。</p><p>初始化阶段是执行初始化方法 <code>&lt;clinit&gt; ()</code>方法的过程，是类加载的最后一步，这一步 JVM 才开始真正执行类中定义的 Java 程序代码(字节码)。</p><blockquote><p>说明：<code>&lt;clinit&gt; ()</code>方法是编译之后自动生成的。</p></blockquote><hr><h3 id="类加载器-ClassLoader"><a href="#类加载器-ClassLoader" class="headerlink" title="类加载器(ClassLoader)"></a>类加载器(ClassLoader)</h3><p>开始介绍类加载器和双亲委派模型之前，简单回顾一下类加载过程。</p><p>类加载过程：<strong>加载-&gt;链接-&gt;初始化</strong>。<br>链接过程又可分为三步：<strong>验证-&gt;准备-&gt;解析</strong>。</p><p><img src="https://pb01.s3.bitiful.net/138.png" alt="avatar"></p><p>加载是类加载过程的第一步，主要完成下面 3 件事情：</p><ol><li>通过全类名获取定义此类的二进制字节流</li><li>将字节流所代表的静态存储结构转换为方法区的运行时数据结构</li><li>在内存中生成一个代表该类的 <code>Class</code> 对象，作为方法区这些数据的访问入口</li></ol><ul><li>类加载器是一个负责加载类的对象，用于实现类加载过程中的加载这一步。</li><li>每个 Java 类都有一个引用指向加载它的 ClassLoader。</li><li>数组类不是通过 ClassLoader 创建的（数组类没有对应的二进制字节流），是由 JVM 直接生成的。</li></ul><p>简单来说，类加载器的主要作用就<strong>是加载 Java 类的字节码（ .class 文件）到 JVM 中（在内存中生成一个代表该类的 Class 对象）</strong>。 字节码可以是 Java 源程序（.java文件）经过 javac 编译得来，也可以是通过工具动态生成或者通过网络下载得来。</p><p>其实除了加载类之外，类加载器还可以加载 Java 应用所需的资源如文本、图像、配置文件、视频等等文件资源。</p><h4 id="类加载器加载规则"><a href="#类加载器加载规则" class="headerlink" title="类加载器加载规则"></a>类加载器加载规则</h4><p>JVM 启动的时候，并不会一次性加载所有的类，而是根据需要去动态加载。也就是说，大部分类在具体用到的时候才会去加载，这样对内存更加友好。对于已经加载的类会被放在 ClassLoader 中。</p><p>在类加载的时候，系统会首先判断当前类是否被加载过。已经被加载的类会直接返回，否则才会尝试加载。也就是说，<strong>对于一个类加载器来说，相同二进制名称的类只会被加载一次</strong>。</p><h4 id="类加载器总结"><a href="#类加载器总结" class="headerlink" title="类加载器总结"></a>类加载器总结</h4><p>JVM 中内置了三个重要的 ClassLoader：</p><ol><li><strong>BootstrapClassLoader(启动类加载器)</strong>: 最顶层的加载类，由 C++实现，通常表示为 null，并且没有父级，主要用来加载 JDK 内部的核心类库（ <code>%JAVA_HOME%/lib</code>目录下的 <code>rt.jar</code>、<code>resources.jar</code>、<code>charsets.jar</code>等 jar 包和类）以及被 <code>-Xbootclasspath</code>参数指定的路径下的所有类。</li><li><strong>ExtensionClassLoader(扩展类加载器)</strong>: 主要负责加载 <code>%JRE_HOME%/lib/ext</code> 目录下的 jar 包和类以及被 <code>java.ext.dirs</code> 系统变量所指定的路径下的所有类。</li><li><strong>AppClassLoader(应用程序类加载器)</strong>: 面向我们用户的加载器，负责加载当前应用 classpath 下的所有 jar 包和类。</li></ol><p>除了这三种类加载器之外，用户还可以加入自定义的类加载器来进行拓展，以满足自己的特殊需求。就比如说，我们可以对 Java 类的字节码（ .class 文件）进行加密，加载时再利用自定义的类加载器对其解密。</p><p><img src="https://pb01.s3.bitiful.net/139.png" alt="avatar"></p><p>除了启动类加载器是 JVM 自身的一部分之外，其他所有的类加载器都是在 JVM 外部实现的，并且全都继承自 ClassLoader抽象类。</p><p>这样做的好处是用户可以自定义类加载器，以便让应用程序自己决定如何去获取所需的类。每个 ClassLoader 可以通过getParent()获取其父 ClassLoader，如果获取到 ClassLoader 为null的话，那么该类就是是通过 启动类加载器 加载的</p><p><strong>为什么获取到的ClassLoader 为null就是启动类加载器加载的呢？</strong> 这是因为启动类加载器由 C++ 实现，由于这个 C++ 实现的类加载器在 Java 中是没有与之对应的类的，所以拿到的结果是 null。</p><h4 id="自定义类加载器"><a href="#自定义类加载器" class="headerlink" title="自定义类加载器"></a>自定义类加载器</h4><p>我们前面也说说了，除了启动类加载器,其他类加载器均由 Java 实现且全部继承自java.lang.ClassLoader。如果我们要自定义自己的类加载器，很明显需要继承 ClassLoader抽象类。</p><p>ClassLoader 类有两个关键的方法：</p><ul><li><strong>protected Class loadClass(String name, boolean resolve)</strong>：加载指定二进制名称的类，实现了双亲委派机制 。name 为类的二进制名称，resolve 如果为 true，在加载时调用 resolveClass(Class&lt;?&gt; c) 方法解析该类。</li><li><strong>protected Class findClass(String name)</strong>：根据类的二进制名称来查找类，默认实现是空方法。</li></ul><p>官方 API 文档中写到：</p><blockquote><p>建议 ClassLoader的子类重写 findClass(String name)方法而不是loadClass(String name, boolean resolve) 方法。</p></blockquote><p>如果我们不想打破双亲委派模型，就重写 ClassLoader 类中的 findClass() 方法即可，无法被父类加载器加载的类最终会通过这个方法被加载。但是，如果想打破双亲委派模型则需要重写 loadClass() 方法。</p><h3 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h3><h4 id="双亲委派模型介绍"><a href="#双亲委派模型介绍" class="headerlink" title="双亲委派模型介绍"></a>双亲委派模型介绍</h4><p>类加载器有很多种，当我们想要加载一个类的时候，具体是哪个类加载器加载呢？这就需要提到双亲委派模型了。</p><p><code>ClassLoader</code> 类使用委托模型来搜索类和资源。每个 <code>ClassLoader</code> 实例都有一个相关的父类加载器。需要查找类或资源时，<code>ClassLoader</code> 实例会在试图亲自查找类或资源之前，将搜索类或资源的任务委托给其父类加载器。双亲委派模型要求除了顶层的启动类加载器外，其余的类加载器都应有自己的父类加载器。</p><p>下图展示的各种类加载器之间的层次关系被称为类加载器的“<strong>双亲委派模型(Parents Delegation Model)</strong>”。</p><p><img src="https://pb01.s3.bitiful.net/139.png" alt="avatar"></p><p>注意 ⚠️：双亲委派模型并不是一种强制性的约束，只是 JDK 官方推荐的一种方式。如果我们因为某些特殊需求想要打破双亲委派模型，也是可以的.</p><p>其实这个双亲翻译的容易让别人误解，我们一般理解的双亲都是父母，这里的双亲更多地表达的是“父母这一辈”的人而已，并不是说真的有一个 MotherClassLoader 和一个FatherClassLoader 。</p><p>另外，类加载器之间的父子关系一般不是以继承的关系来实现的，而是通常使用组合关系来复用父加载器的代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">ClassLoader</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">// 组合</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> ClassLoader parent;</span><br><span class="line">  <span class="keyword">protected</span> <span class="title function_">ClassLoader</span><span class="params">(ClassLoader parent)</span> &#123;</span><br><span class="line">       <span class="built_in">this</span>(checkCreateClassLoader(), parent);</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在面向对象编程中，有一条非常经典的设计原则：<strong>组合优于继承，多用组合少用继承</strong>。</p><h4 id="双亲委派模型的执行流程"><a href="#双亲委派模型的执行流程" class="headerlink" title="双亲委派模型的执行流程"></a>双亲委派模型的执行流程</h4><ol><li>在类加载的时候，系统会首先判断当前类是否被加载过。已经被加载的类会直接返回，否则才会尝试加载（每个父类加载器都会走一遍这个流程）。</li><li>类加载器在进行类加载的时候，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成（调用父加载器 loadClass()方法来加载类）。这样的话，所有的请求最终都会传送到顶层的启动类加载器 BootstrapClassLoader 中。</li><li>只有当父加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去加载（调用自己的 findClass() 方法来加载类）。</li><li>如果子类加载器也无法加载这个类，那么它会抛出一个 ClassNotFoundException 异常。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="type">boolean</span> resolve)</span><br><span class="line">    <span class="keyword">throws</span> ClassNotFoundException</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line">        <span class="comment">//首先，检查该类是否已经加载过</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> findLoadedClass(name);</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//如果 c 为 null，则说明该类没有被加载过</span></span><br><span class="line">            <span class="type">long</span> <span class="variable">t0</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (parent != <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="comment">//当父类的加载器不为空，则通过父类的loadClass来加载该类</span></span><br><span class="line">                    c = parent.loadClass(name, <span class="literal">false</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//当父类的加载器为空，则调用启动类加载器来加载该类</span></span><br><span class="line">                    c = findBootstrapClassOrNull(name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                <span class="comment">//非空父类的类加载器无法找到相应的类，则抛出异常</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (c == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">//当父类加载器无法加载时，则调用findClass方法来加载该类</span></span><br><span class="line">                <span class="comment">//用户可通过覆写该方法，来自定义类加载器</span></span><br><span class="line">                <span class="type">long</span> <span class="variable">t1</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">                c = findClass(name);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//用于统计类加载器相关的信息</span></span><br><span class="line">                sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class="line">                sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">                sun.misc.PerfCounter.getFindClasses().increment();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">            <span class="comment">//对类进行link操作</span></span><br><span class="line">            resolveClass(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>🌈 拓展一下：<br><strong>JVM 判定两个 Java 类是否相同的具体规则</strong>: JVM 不仅要看类的全名是否相同，还要看加载此类的类加载器是否一样。只有两者都相同的情况，才认为两个类是相同的。即使两个类来源于同一个 Class 文件，被同一个虚拟机加载，只要加载它们的类加载器不同，那这两个类就必定不相同。</p><p>双亲委派模型保证了 Java 程序的稳定运行，<strong>可以避免类的重复加载</strong>（JVM 区分不同类的方式不仅仅根据类名，相同的类文件被不同的类加载器加载产生的是两个不同的类），<strong>也保证了 Java 的核心 API 不被篡改</strong>。</p><p>如果没有使用双亲委派模型，而是每个类加载器加载自己的话就会出现一些问题，比如我们编写一个称为 <code>java.lang.Object</code>类的话，那么程序运行的时候，系统就会出现两个不同的 <code>Object</code> 类。双亲委派模型可以保证加载的是 JRE 里的那个 <code>Object</code> 类，而不是你写的 <code>Object</code> 类。这是因为 <code>AppClassLoader</code> 在加载你的 <code>Object</code> 类时，会委托给 <code>ExtClassLoader</code> 去加载，而 <code>ExtClassLoader</code> 又会委托给 <code>BootstrapClassLoader</code>，<code>BootstrapClassLoader</code> 发现自己已经加载过了 <code>Object</code> 类，会直接返回，不会去加载你写的 <code>Object</code> 类。</p><h4 id="打破双亲委派模型方法"><a href="#打破双亲委派模型方法" class="headerlink" title="打破双亲委派模型方法"></a>打破双亲委派模型方法</h4><p>打破双亲委派模型方法就要<strong>自定义加载器,重写loadClass方法</strong>. 自定义加载器的话，需要继承 <code>ClassLoader</code> 。如果我们不想打破双亲委派模型，就重写 <code>ClassLoader</code> 类中的 findClass() 方法即可，无法被父类加载器加载的类最终会通过这个方法被加载。但是，如果想打破双亲委派模型则需要重写 loadClass() 方法。</p><p>为什么是重写 loadClass() 方法打破双亲委派模型呢？双亲委派模型的执行流程已经解释了：</p><blockquote><p>类加载器在进行类加载的时候，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成（调用父加载器 loadClass()方法来加载类）。</p></blockquote><p>重写 loadClass()方法之后，我们就可以改变传统双亲委派模型的执行流程。例如，子类加载器可以在委派给父类加载器之前，先自己尝试加载这个类，或者在父类加载器返回之后，再尝试从其他地方加载这个类。具体的规则由我们自己实现，根据项目需求定制化。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>类文件结构</title>
      <link href="/2023/12/20/JVM3/"/>
      <url>/2023/12/20/JVM3/</url>
      
        <content type="html"><![CDATA[<h2 id="类文件结构"><a href="#类文件结构" class="headerlink" title="类文件结构"></a>类文件结构</h2><p>在我们学习C语言的时候，我们的编程过程会经历如下几个阶段：写代码、保存、编译、运行。实际上，最关键的一步是编译，因为只有经历了编译之后，我们所编写的代码才能够翻译为机器可以直接运行的二进制代码，并且在不同的操作系统下，我们的代码都需要进行一次编译之后才能运行。</p><blockquote><p>如果全世界所有的计算机指令集只有x86一种，操作系统只有Windows一种，那也许就不会有Java语言的出现。</p></blockquote><p>随着时代的发展，人们迫切希望能够在不同的操作系统、不同的计算机架构中运行同一套编译之后的代码。本地代码不应该是我们编程的唯一选择，所以，越来越多的语言选择了与操作系统和机器指令集无关的中立格式作为编译后的存储格式。</p><p>“一次编写，到处运行”，Java最引以为傲的口号，标志着平台不再是限制编程语言的阻碍。</p><p>实际上，Java正式利用了这样的解决方案，将源代码编译为平台无关的中间格式，并通过对应的Java虚拟机读取和运行这些中间格式的编译文件，这样，我们只需要考虑不同平台的虚拟机如何编写，而Java语言本身很轻松地实现了跨平台。</p><p>现在，越来越多的开发语言都支持将源代码编译为<code>.class</code>字节码文件格式，以便能够直接交给JVM运行，包括Kotlin（安卓开发官方指定语言）、Groovy、Scala等。</p><p><img src="https://pb01.s3.bitiful.net/129.png" alt="avatar"></p><p>那么，让我们来看看，我们的源代码编译之后，是如何保存在字节码文件中的。</p><hr><h3 id="类文件信息"><a href="#类文件信息" class="headerlink" title="类文件信息"></a>类文件信息</h3><p>我们之前都是使用<code>javap</code>命令来对字节码文件进行反编译查看的，那么，它以二进制格式是怎么保存呢？我们可以使用WinHex软件（Mac平台可以使用<a href="https://www.macwk.com/soft/010-editor">010 Editor</a>）来以十六进制查看字节码文件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> i++;</span><br><span class="line">        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> ++i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>找到我们在IDEA中编译出来的class文件，将其拖动进去：</p><p><img src="https://pb01.s3.bitiful.net/130.png" alt="avatar"></p><p>可以看到整个文件中，全是一个字节一个字节分组的样子，从左上角开始，一行一行向下读取。</p><p>实际上Class文件采用了一种类似于C中结构体的伪结构来存储数据:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">ClassFile &#123;</span><br><span class="line">    u4             magic; //Class 文件的标志</span><br><span class="line">    u2             minor_version;//Class 的小版本号</span><br><span class="line">    u2             major_version;//Class 的大版本号</span><br><span class="line">    u2             constant_pool_count;//常量池的数量</span><br><span class="line">    cp_info        constant_pool[constant_pool_count-1];//常量池</span><br><span class="line">    u2             access_flags;//Class 的访问标记</span><br><span class="line">    u2             this_class;//当前类</span><br><span class="line">    u2             super_class;//父类</span><br><span class="line">    u2             interfaces_count;//接口数量</span><br><span class="line">    u2             interfaces[interfaces_count];//一个类可以实现多个接口</span><br><span class="line">    u2             fields_count;//字段数量</span><br><span class="line">    field_info     fields[fields_count];//一个类可以有多个字段</span><br><span class="line">    u2             methods_count;//方法数量</span><br><span class="line">    method_info    methods[methods_count];//一个类可以有个多个方法</span><br><span class="line">    u2             attributes_count;//此类的属性表中的属性数</span><br><span class="line">    attribute_info attributes[attributes_count];//属性表集合</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>而Class文件中，有两种允许存在的数据类型，一个是无符号数，还有一个是表。</p><ul><li>无符号数一般是基本数据类型，用u1、u2、u4、u8来表示，表示1个字节~8个字节的无符号数。可以表示数字、索引引用、数量值或是以UTF-8编码格式的字符串。</li><li>表包含多个无符号数，并且以”_info”结尾。</li></ul><p>我们首先从最简单的开始看起。</p><p><img src="https://pb01.s3.bitiful.net/131.png" alt="avatar"></p><p>首先，我们可以看到，前4个字节（共32位）组成了<strong>魔数</strong>（其实就是表示这个文件是一个JVM可以运行的字节码文件，除了Java以外，其他某些文件中也采用了这种魔数机制来进行区分，这种方式比直接起个文件扩展名更安全）</p><p>字节码文件的魔数为：CAFEBABE（这名字能想出来也是挺难的了，毕竟4个bit位只能表示出A-F这几个字母）</p><p>紧接着魔数的后面4个字节存储的是字节码文件的版本号，注意前两个是次要版本号（现在基本都不用了，都是直接Java8、Java9这样命名了），后面两个是<strong>主要版本号</strong>，这里我们主要看主版本号，比如上面的就是34，注意这是以16进制表示的，我们把它换算为10进制后，得到的结果为：<code>34  -&gt;  3*16 + 4 = 52</code>，其中<code>52</code>代表的是<code>JDK8</code>编译的字节码文件（51是JDK7、50是JDK6、53是JDK9，以此类推）</p><p>JVM会<strong>根据版本号决定是否能够运行</strong>，比如JDK6只能支持版本号为1.1~6的版本，也就是说必须是Java6之前的环境编译出来的字节码文件，否则无法运行。又比如我们现在安装的是JDK8版本，它能够支持的版本号为1.1~8，那么如果这时我们有一个通过Java7编译出来的字节码文件，依然是可以运行的，所以说Java版本是向下兼容的。</p><p>紧接着，就是类的<strong>常量池</strong>了，这里面存放了类中所有的常量信息（注意这里的常量并不是指我们手动创建的final类型常量，而是程序运行一些需要用到的常量数据，比如字面量和符号引用等）由于常量的数量不是确定的，所以在最开始的位置会存放常量池中常量的数量（是从1开始计算的，不是0，比如这里是18，翻译为10进制就是24，所以实际上有23个常量）</p><p>接着再往下，就是常量池里面的数据了，常量池中每一项常量都是一个表，这 14 种表有一个共同的特点：开始的第一位是一个 u1 类型的标志位 -tag 来标识常量的类型，代表当前这个常量属于哪种常量类型,都是以_info结尾</p><div class="table-container"><table><thead><tr><th style="text-align:center">类型</th><th style="text-align:center">标志</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">CONSTANT_Utf8_info</td><td style="text-align:center">1</td><td style="text-align:center">UTF-8编码格式的字符串</td></tr><tr><td style="text-align:center">CONSTANT_Integer_info</td><td style="text-align:center">3</td><td style="text-align:center">整形字面量（第一章我们演示的很大的数字，实际上就是以字面量存储在常量池中的）</td></tr><tr><td style="text-align:center">CONSTANT_Float_info</td><td style="text-align:center">4</td><td style="text-align:center">浮点型字面量</td></tr><tr><td style="text-align:center">CONSTANT_Long_info</td><td style="text-align:center">5</td><td style="text-align:center">长整型字面量</td></tr><tr><td style="text-align:center">CONSTANT_Double_info</td><td style="text-align:center">6</td><td style="text-align:center">双精度浮点型字面量</td></tr><tr><td style="text-align:center">CONSTANT_Class_info</td><td style="text-align:center">7</td><td style="text-align:center">类或接口的符号引用</td></tr><tr><td style="text-align:center">CONSTANT_String_info</td><td style="text-align:center">8</td><td style="text-align:center">字符串类型的字面量</td></tr><tr><td style="text-align:center">CONSTANT_Fieldref_info</td><td style="text-align:center">9</td><td style="text-align:center">字段的符号引用</td></tr><tr><td style="text-align:center">CONSTANT_Methodref_info</td><td style="text-align:center">10</td><td style="text-align:center">方法的符号引用</td></tr><tr><td style="text-align:center">CONSTANT_InterfaceMethodref_info</td><td style="text-align:center">11</td><td style="text-align:center">接口方法的符号引用</td></tr><tr><td style="text-align:center">CONSTANT_NameAndType_info</td><td style="text-align:center">12</td><td style="text-align:center">字段或方法的符号引用</td></tr><tr><td style="text-align:center">CONSTANT_MethodType_info</td><td style="text-align:center">16</td><td style="text-align:center">方法类型</td></tr><tr><td style="text-align:center">CONSTANT_MethodHandle_info</td><td style="text-align:center">15</td><td style="text-align:center">表示方法句柄</td></tr><tr><td style="text-align:center">CONSTANT_InvokeDynamic_info</td><td style="text-align:center">18</td><td style="text-align:center">表示一个动态方法调用点</td></tr></tbody></table></div><p>比如我们来看第一个<code>CONSTANT_Methodref_info</code>表中存放了什么数据，这里我只列出它的结构表（详细的结构表可以查阅《深入理解Java虚拟机 第三版》中222页总表）：</p><div class="table-container"><table><thead><tr><th style="text-align:center">常量</th><th style="text-align:center">项目</th><th style="text-align:center">类型</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">CONSTANT_Methodref_info</td><td style="text-align:center">tag</td><td style="text-align:center">u1</td><td style="text-align:center">值为10</td></tr><tr><td style="text-align:center"></td><td style="text-align:center">index</td><td style="text-align:center">u2</td><td style="text-align:center">指向声明方法的类描述父CONSTANT_Class_info索引项</td></tr><tr><td style="text-align:center"></td><td style="text-align:center">index</td><td style="text-align:center">u2</td><td style="text-align:center">指向名称及类型描述符CONSTANT_NameAndType_info索引项</td></tr></tbody></table></div><p>在常量池结束之后，紧接着的两个字节代表<strong>访问标志</strong>，这个标志用于识别一些类或者接口层次的访问信息，包括：这个 Class 是类还是接口，是否为 public 或者 abstract 类型，如果是类的话是否声明为 final 等等。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">u2             access_flags;//Class 的访问标记</span><br></pre></td></tr></table></figure><p>可以看到它只占了2个字节，那么它是如何表示访问标志呢?</p><p><img src="https://pb01.s3.bitiful.net/132.png" alt="avatar"></p><p>比如我们这里的Main类，它是一个普通的class类型，并且访问权限为public，那么它的访问标志值是这样计算的：</p><p><code>ACC_PUBLIC | ACC_SUPER = 0x0001 | 0x0020 = 0x0021</code>（这里进行的是按位或运算），可以看到和我们上面的结果是一致的。</p><p>再往下就是类索引、父类索引、接口索引：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">u2             this_class;//当前类</span><br><span class="line">u2             super_class;//父类</span><br><span class="line">u2             interfaces_count;//接口数量</span><br><span class="line">u2             interfaces[interfaces_count];//一个类可以实现多个接口</span><br></pre></td></tr></table></figure><p><img src="https://pb01.s3.bitiful.net/133.png" alt="avatar"></p><p>可以看到它们的值也是指向<strong>常量池中的值</strong>，其中2号常量正是存储的当前类信息，3号常量存储的是父类信息，这里就不再倒推回去了，由于没有接口，所以这里接口数量为0，如果不为0还会有一个索引表来引用接口。</p><p>Java 类的继承关系由类索引、父类索引和接口索引集合三项确定。类索引、父类索引和接口索引集合按照顺序排在访问标志之后，<strong>类索引</strong>用于确定这个类的全限定名，<strong>父类索引</strong>用于确定这个类的父类的全限定名，由于 Java 语言的单继承，所以父类索引只有一个，除了 java.lang.Object 之外，所有的 Java 类都有父类，因此除了 java.lang.Object 外，所有 Java 类的父类索引都不为 0。<strong>接口索引集合</strong>用来描述这个类实现了那些接口，这些被实现的接口将按 implements (如果这个类本身是接口的话则是extends) 后的接口顺序从左到右排列在接口索引集合中。</p><p>接着就是<strong>字段表</strong>了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">u2             fields_count;//字段数量</span><br><span class="line">field_info     fields[fields_count];//一个类会可以有个字段</span><br></pre></td></tr></table></figure><p>由于我们这里没有声明任何字段，所以我们先给Main类添加一个字段再重新加载一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> i++;</span><br><span class="line">        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> ++i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://pb01.s3.bitiful.net/134.png" alt="avatar"></p><ul><li><strong>access_flags:</strong> 字段的作用域（public ,private,protected修饰符），是实例变量还是类变量（static修饰符）,可否被序列化（transient 修饰符）,可变性（final）,可见性（volatile 修饰符，是否强制从主内存读写）。</li><li><strong>name_index:</strong> 对常量池的引用，表示的字段的名称；</li><li><strong>descriptor_index:</strong> 对常量池的引用，表示字段和方法的描述符；</li><li><strong>attributes_count:</strong> 一个字段还会拥有一些额外的属性，attributes_count 存放属性的个数；</li><li><strong>attributes[attributes_count]:</strong> 存放具体属性具体内容。</li></ul><p>上述这些信息中，各个修饰符都是布尔值，要么有某个修饰符，要么没有，很适合使用标志位来表示。而字段叫什么名字、字段被定义为什么数据类型这些都是无法固定的，只能引用常量池中常量来描述。</p><p>接着就是我们的<strong>方法表</strong>了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">u2             methods_count;//方法数量</span><br><span class="line">method_info    methods[methods_count];//一个类可以有个多个方法</span><br></pre></td></tr></table></figure><p>methods_count 表示方法的数量，而 method_info 表示方法表。</p><p>Class 文件存储格式中对方法的描述与对字段的描述几乎采用了完全一致的方式。方法表的结构如同字段表一样，依次包括了访问标志、名称索引、描述符索引、属性表集合几项。</p><p><strong>method_info(方法表的) 结构:</strong></p><p><img src="https://pb01.s3.bitiful.net/135.png" alt="avatar"></p><p>最后，就是<strong>属性表</strong>了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">u2             attributes_count;//此类的属性表中的属性数</span><br><span class="line">attribute_info attributes[attributes_count];//属性表集合</span><br></pre></td></tr></table></figure><p>在 Class 文件，字段表，方法表中都可以携带自己的属性表集合，以用于描述某些场景专有的信息。与 Class 文件中其它的数据项目要求的顺序、长度和内容不同，属性表集合的限制稍微宽松一些，不再要求各个属性表具有严格的顺序，并且只要不与已有的属性名重复，任何人实现的编译器都可以向属性表中写入自己定义的属性信息，Java 虚拟机运行时会忽略掉它不认识的属性。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM垃圾回收机制</title>
      <link href="/2023/12/19/JVM2/"/>
      <url>/2023/12/19/JVM2/</url>
      
        <content type="html"><![CDATA[<h2 id="垃圾回收机制"><a href="#垃圾回收机制" class="headerlink" title="垃圾回收机制"></a>垃圾回收机制</h2><p>我们前面提到，Java会自动管理和释放内存，它不像C/C++那样要求我们手动管理内存，JVM提供了一套全自动的内存管理机制，当一个Java对象不再用到时，JVM会自动将其进行回收并释放内存，那么对象所占内存在什么时候被回收，如何判定对象可以被回收，以及如何去进行回收工作也是JVM需要关注的问题。</p><h3 id="对象存活判定算法"><a href="#对象存活判定算法" class="headerlink" title="对象存活判定算法"></a>对象存活判定算法</h3><p>首先我们来套讨论第一个问题，也就是：对象在什么情况下可以被判定为不再使用已经可以回收了？这里就需要提到以下几种垃圾回收算法了。</p><p><img src="https://pb01.s3.bitiful.net/108.png" alt="avatar"></p><h4 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h4><p>我们知道，如果我们要经常操作一个对象，那么首先一定会创建一个引用变量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//str就是一个引用类型的变量，它持有对后面字符串对象的引用，可以代表后面这个字符串对象本身</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;lbwnb&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//str.xxxxx...</span></span><br></pre></td></tr></table></figure><p>实际上，我们会发现，只要一个对象还有使用价值，我们就会通过它的引用变量来进行操作，那么可否这样判断一个对象是否还需要被使用：</p><ul><li>每个对象都包含一个 <strong>引用计数器</strong>，用于存放引用计数（其实就是存放被引用的次数）</li><li>每当有一个地方引用此对象时，引用计数<code>+1</code></li><li>当引用失效（ 比如离开了局部变量的作用域或是引用被设定为<code>null</code>）时，引用计数<code>-1</code></li><li>当引用计数为<code>0</code>时，表示此对象不可能再被使用，因为这时我们已经没有任何方法可以得到此对象的引用了</li></ul><p>但是这样存在一个问题，如果两个对象相互引用呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Test</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test</span>();</span><br><span class="line">        <span class="type">Test</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test</span>();</span><br><span class="line"></span><br><span class="line">        a.another = b;</span><br><span class="line">        b.another = a;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//这里直接把a和b赋值为null，这样前面的两个对象我们不可能再得到了</span></span><br><span class="line">        a = b = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">        Test another;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>按照引用计数算法，那么当出现以上情况时，虽然我们无法在得到此对象的引用了，并且此对象我们也无需再使用，但是由于这两个对象直接存在相互引用的情况，那么引用计数器的值将会永远是<code>1</code>，但是实际上此对象已经没有任何用途了。所以引用计数法并不是最好的解决方案。</p><h4 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h4><p>目前比较主流的编程语言（包括Java），一般都会使用可达性分析算法来判断对象是否存活，它采用了类似于树结构的搜索机制。</p><p>首先每个对象的引用都有机会成为树的根节点（GC Roots），可以被选定作为根节点条件如下：</p><ul><li>位于虚拟机栈的栈帧中的本地变量表中所引用到的对象（其实就是我们方法中的局部变量）同样也包括本地方法栈中JNI引用的对象。</li><li>类的静态成员变量引用的对象。</li><li>方法区中，常量池里面引用的对象，比如我们之前提到的<code>String</code>类型对象。</li><li>被添加了锁的对象（比如synchronized关键字）</li><li>虚拟机内部需要用到的对象。</li></ul><p><img src="https://pb01.s3.bitiful.net/109.png" alt="avatar"></p><p>一旦已经存在的根节点不满足存在的条件时，那么根节点与对象之间的连接将被断开。此时虽然对象1仍存在对其他对象的引用，但是由于其没有任何根节点引用，所以此对象即可被判定为不再使用。比如某个方法中的局部变量引用，在方法执行完成返回之后：</p><p><img src="https://pb01.s3.bitiful.net/110.png" alt="avatar"></p><p>这样就能很好地解决我们刚刚提到的循环引用问题，我们再来重现一下出现循环引用的情况：</p><p><img src="https://pb01.s3.bitiful.net/111.png" alt="avatar"></p><p>可以看到，对象1和对象2依然是存在循环引用的，但是只有他们各自的GC Roots断开，那么就会变成下面这样：</p><p><img src="https://pb01.s3.bitiful.net/112.png" alt="avatar"></p><p>所以，我们最后进行一下总结：如果某个对象无法到达任何GC Roots，则证明此对象是不可能再被使用的。</p><h4 id="最终判定"><a href="#最终判定" class="headerlink" title="最终判定"></a>最终判定</h4><p>虽然在经历了可达性分析算法之后基本可能判定哪些对象能够被回收，但是并不代表此对象一定会被回收，我们依然可以在最终判定阶段对其进行挽留。</p><p>还记得<code>Object</code>类中的<code>finalize()</code>方法吗？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Called by the garbage collector on an object when garbage collection</span></span><br><span class="line"><span class="comment"> * determines that there are no more references to the object.</span></span><br><span class="line"><span class="comment"> * A subclass overrides the &#123;<span class="doctag">@code</span> finalize&#125; method to dispose of</span></span><br><span class="line"><span class="comment"> * system resources or to perform other cleanup.</span></span><br><span class="line"><span class="comment"> * ...</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable &#123; &#125;</span><br></pre></td></tr></table></figure><p>此方法正是最终判定方法，如果子类重写了此方法，那么子类对象在被判定为可回收时，会进行二次确认，也就是执行<code>finalize()</code>方法，而在此方法中，当前对象是完全有可能重新建立GC Roots的！所以，如果在二次确认后对象不满足可回收的条件，那么此对象不会被回收，巧妙地逃过了垃圾回收的命运。比如下面这个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Test a;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        a = <span class="keyword">new</span> <span class="title class_">Test</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//这里直接把a赋值为null，这样前面的对象我们不可能再得到了</span></span><br><span class="line">        a  = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//手动申请执行垃圾回收操作（注意只是申请，并不一定会执行，但是一般情况下都会执行）</span></span><br><span class="line">        System.gc();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//等待垃圾</span></span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//我们来看看a有没有被回收</span></span><br><span class="line">        System.out.println(a);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">            System.out.println(<span class="built_in">this</span>+<span class="string">&quot; 开始了它的救赎之路！&quot;</span>);</span><br><span class="line">            a = <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意<code>finalize()</code>方法并不是在主线程调用的，而是虚拟机自动建立的一个低优先级的<code>Finalizer</code>线程（正是因为优先级比较低，所以前面才需要等待1秒钟）进行处理，我们可以稍微修改一下看看：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        System.out.println(Thread.currentThread());</span><br><span class="line">        a = <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果是:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Thread[Finalizer,8,system]</span><br><span class="line">com.test.Main$Test@232204a1</span><br></pre></td></tr></table></figure></p><p>同时，同一个对象的<code>finalize()</code>方法只会有一次调用机会，也就是说，如果我们连续两次这样操作，那么第二次，对象必定被回收：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    a = <span class="keyword">new</span> <span class="title class_">Test</span>();</span><br><span class="line">    <span class="comment">//这里直接把a赋值为null，这样前面的对象我们不可能再得到了</span></span><br><span class="line">    a  = <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">//手动申请执行垃圾回收操作（注意只是申请，并不一定会执行，但是一般情况下都会执行）</span></span><br><span class="line">    System.gc();</span><br><span class="line">    <span class="comment">//等垃圾回收一下</span></span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    </span><br><span class="line">    System.out.println(a);</span><br><span class="line">    <span class="comment">//这里直接把a赋值为null，这样前面的对象我们不可能再得到了</span></span><br><span class="line">    a  = <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">//手动申请执行垃圾回收操作（注意只是申请，并不一定会执行，但是一般情况下都会执行）</span></span><br><span class="line">    System.gc();</span><br><span class="line">    <span class="comment">//等垃圾回收一下</span></span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    </span><br><span class="line">    System.out.println(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，<code>finalize()</code>方法也并不是专门防止对象被回收的，我们可以使用它来释放一些程序使用中的资源等。</p><p>最后，总结成一张图：</p><p><img src="https://pb01.s3.bitiful.net/113.png" alt="avatar"></p><p>当然，除了堆中的对象以外，方法区中的数据也是可以被垃圾回收的，但是回收条件比较严格，这里就暂时不谈了。</p><hr><h3 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h3><p>前面我们介绍了对象存活判定算法，现在我们已经可以准确地知道堆中的哪些对象可以被回收了，那么，接下来就该考虑如何对对象进行回收了，垃圾收集器会不定期地检查堆中的对象，查看它们是否满足被回收的条件。我们该如何对这些对象进行回收，是一个一个判断是否需要回收吗？</p><h4 id="分代收集机制"><a href="#分代收集机制" class="headerlink" title="分代收集机制"></a>分代收集机制</h4><p>实际上，如果我们对堆中的每一个对象都依次判断是否需要回收，这样的效率其实是很低的，那么有没有更好地回收机制呢？第一步，我们可以对堆中的对象进行分代管理。</p><p>比如某些对象，在多次垃圾回收时，都未被判定为可回收对象，我们完全可以将这一部分对象放在一起，并让垃圾收集器减少回收此区域对象的频率，这样就能很好地提高垃圾回收的效率了。</p><p>因此，Java虚拟机将堆内存划分为<strong>新生代</strong>、<strong>老年代</strong>和<strong>永久代</strong>（其中永久代是HotSpot虚拟机特有的概念，在JDK8之前方法区实际上就是采用的永久代作为实现，而在JDK8之后，方法区由元空间实现，并且使用的是本地内存，容量大小取决于物理机实际大小，之后会详细介绍）这里我们主要讨论的是<strong>新生代</strong>和<strong>老年代</strong>。</p><p>不同的分代内存回收机制也存在一些不同之处，在HotSpot虚拟机中，新生代被划分为三块，一块较大的Eden空间和两块较小的Survivor空间，默认比例为8：1：1，老年代的GC评率相对较低，永久代一般存放类信息等（其实就是方法区的实现）如图所示：</p><p><img src="https://pb01.s3.bitiful.net/114.png" alt="avatar"></p><p>那么它是如何运作的呢？</p><p>首先，所有新创建的对象，在一开始都会进入到新生代的Eden区（如果是大对象会被直接丢进老年代），在进行新生代区域的垃圾回收时，首先会对所有新生代区域的对象进行扫描，并回收那些不再使用对象：</p><p><img src="https://pb01.s3.bitiful.net/115.png" alt="avatar"></p><p>接着，在一次垃圾回收之后，Eden区域没有被回收的对象，会进入到Survivor区。在一开始From和To都是空的，而GC之后，所有Eden区域存活的对象都会直接被放入到From区，最后From和To会发生一次交换，也就是说目前存放我们对象的From区，变为To区，而To区变为From区：</p><p><img src="https://pb01.s3.bitiful.net/116.png" alt="avatar"></p><p>接着就是下一次垃圾回收了，操作与上面是一样的，不过这时由于我们From区域中已经存在对象了，所以，在Eden区的存活对象复制到From区之后，所有To区域中的对象会进行年龄判定（每经历一轮GC年龄<code>+1</code>，当年龄大小超过了 survivor 区的一半时，取这个年龄和 MaxTenuringThreshold 中更小的一个值，作为新的晋升到老年代的年龄阈值，大于这个阈值的话,会直接进入到老年代，否则移动到From区）</p><p><img src="https://pb01.s3.bitiful.net/117.png" alt="avatar"></p><p>最后像上面一样交换To区和From区，之后不断重复以上步骤。</p><h4 id="空间分配担保"><a href="#空间分配担保" class="headerlink" title="空间分配担保"></a>空间分配担保</h4><p>我们可以思考一下，有没有这样一种极端情况（正常情况下新生代的回收率是很高的，所以说不用太担心会经常出现这种问题），在一次GC后，新生代Eden区仍然存在大量的对象（因为GC之后存活对象会进入到一个Survivor区，但是很明显这时已经超出Survivor区的容量了，肯定是装不下的）那么现在该怎么办？</p><p>这时就需要用到空间分配担保机制了，可以把Survivor区无法容纳的对象直接送到老年代，让老年代进行分配担保（当然老年代也得装得下才行）。当新生代无法容纳更多的的对象时，可以把新生代中的对象移动到老年代中，这样新生代就腾出了空间来容纳更多的对象。</p><p>好，那既然新生代装不下就丢给老年代，那么要是老年代也装不下新生代的数据呢？这时，老年代肯定担保人是当不成了，那么这样的话，首先会判断一下之前的每次垃圾回收进入老年代的平均大小是否小于当前老年代的剩余空间，如果小于，那么说明也许可以放得下（不过也仅仅是也许，依然有可能放不下，因为判断的实际上只是平均值，万一这一次突然非常大呢），否则，会先来一次Full GC，进行一次大规模垃圾回收，来尝试腾出空间，再次判断老年代是否有空间存放，要是还是装不下，直接抛出OOM错误，摆烂。</p><p>最后，我们来总结一下一次Minor GC的整个过程：</p><p><img src="https://pb01.s3.bitiful.net/118.png" alt="avatar"></p><hr><h4 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h4><p>前面我们已经了解了整个堆内存实际上是以分代收集机制为主，但是依然没有讲到具体的收集过程，那么，具体的回收过程又是什么样的呢？首先我们来了解一下最古老的<code>标记-清除</code>算法。</p><p>首先标记出所有需要回收的对象，然后再依次回收掉被标记的对象，或是标记出所有不需要回收的对象，只回收未标记的对象。</p><p>如果按照前者的理解，整个标记-清除过程大致是这样的：</p><ol><li>当一个对象被创建时，给一个标记位，假设为 0 (false)；</li><li>在标记阶段，我们将所有可达对象（或用户可以引用的对象）的标记位设置为 1 (true)；</li><li>扫描阶段清除的就是标记位为 0 (false)的对象。</li></ol><p><img src="https://pb01.s3.bitiful.net/119.png" alt="avatar"></p><p>虽然此方法非常简单，但是缺点也是非常明显的 ，首先如果内存中存在大量的对象，那么可能就会存在大量的标记，并且大规模进行清除。并且一次标记清除之后，连续的内存空间可能会出现许许多多的空隙，碎片化会导致连续内存空间利用率降低。</p><h4 id="标记-复制算法"><a href="#标记-复制算法" class="headerlink" title="标记-复制算法"></a>标记-复制算法</h4><p>既然标记清除算法在面对大量对象时效率低，那么我们可以采用标记-复制算法。它将容量分为同样大小的两块区域，</p><p>标记复制算法，实际上就是将内存区域划分为大小相同的两块区域，每次只使用其中的一块区域，每次垃圾回收结束后，将所有存活的对象全部复制到另一块区域中，并一次性清空当前区域。虽然浪费了一些时间进行复制操作，但是这样能够很好地解决对象大面积回收后空间碎片化严重的问题。</p><p><img src="https://pb01.s3.bitiful.net/120.png" alt="avatar"></p><p>这种算法就非常适用于新生代（因为新生代的回收效率极高，一般不会留下太多的对象）的垃圾回收，而我们之前所说的新生代Survivor区其实就是这个思路，包括8:1:1的比例也正是为了对标记复制算法进行优化而采取的。</p><h4 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记-整理算法"></a>标记-整理算法</h4><p>虽然标记-复制算法能够很好地应对新生代高回收率的场景，但是放到老年代，它就显得很鸡肋了。我们知道，一般长期都回收不到的对象，才有机会进入到老年代，所以老年代一般都是些钉子户，可能一次GC后，仍然存留很多对象。而标记复制算法会在GC后完整复制整个区域内容，并且会折损50%的区域，显然这并不适用于老年代。</p><p>那么我们能否这样，在标记所有待回收对象之后，不急着去进行回收操作，而是将所有待回收的对象整齐排列在一段内存空间中，而需要回收的对象全部往后丢，这样，前半部分的所有对象都是无需进行回收的，而后半部分直接一次性清除即可。</p><p><img src="https://pb01.s3.bitiful.net/121.png" alt="avatar"></p><p>虽然这样能保证内存空间充分使用，并且也没有标记复制算法那么繁杂，但是缺点也是显而易见的，它的效率比前两者都低。甚至，由于需要修改对象在内存中的位置，此时程序必须要暂停才可以，在极端情况下，可能会导致整个程序发生停顿（被称为“Stop The World”）。</p><p>所以，我们可以将标记清除算法和标记整理算法混合使用，在内存空间还不是很凌乱的时候，采用标记清除算法其实是没有多大问题的，当内存空间凌乱到一定程度后，我们可以进行一次标记整理算法。</p><hr><h3 id="垃圾收集器实现"><a href="#垃圾收集器实现" class="headerlink" title="垃圾收集器实现"></a>垃圾收集器实现</h3><p>聊完了对象存活判定和垃圾回收算法，接着我们就要看看具体有哪些垃圾回收器的实现了。我们可以自由地为新生代和老年代选择更适合它们的收集器。</p><h4 id="Serial收集器"><a href="#Serial收集器" class="headerlink" title="Serial收集器"></a>Serial收集器</h4><p>这款垃圾收集器也是元老级别的收集器了，在JDK1.3.1之前，是虚拟机新生代区域收集器的唯一选择。这是一款单线程的垃圾收集器，也就是说，当开始进行垃圾回收时，需要暂停所有的线程，直到垃圾收集工作结束。它的新生代收集算法采用的是标记复制算法，老年代采用的是标记整理算法。</p><p><img src="https://pb01.s3.bitiful.net/122.png" alt="avatar"></p><p>可以看到，当进入到垃圾回收阶段时，所有的用户线程必须等待GC线程完成工作，就相当于你打一把LOL 40分钟，中途每隔1分钟网络就卡5秒钟，可能这时你正在打团，结果你被物理控制直接在那里站了5秒钟，这确实让人难以接受。</p><p>虽然缺点很明显，但是优势也是显而易见的：</p><ol><li>设计简单而高效。</li><li>在用户的桌面应用场景中，内存一般不大，可以在较短时间内完成垃圾收集，只要不频繁发生，使用串行回收器是可以接受的。</li></ol><p>所以，在客户端模式（一般用于一些桌面级图形化界面应用程序）下的新生代中，默认垃圾收集器至今依然是Serial收集器。</p><h4 id="Serial-Old收集器"><a href="#Serial-Old收集器" class="headerlink" title="Serial Old收集器"></a>Serial Old收集器</h4><p><strong>Serial 收集器的老年代版本</strong>，它同样是一个单线程收集器。它主要有两大用途：一种用途是在 JDK1.5 以及以前的版本中与 Parallel Scavenge 收集器搭配使用，另一种用途是作为 CMS 收集器的后备方案。</p><h4 id="ParNew收集器"><a href="#ParNew收集器" class="headerlink" title="ParNew收集器"></a>ParNew收集器</h4><p>这款垃圾收集器相当于是Serial收集器的多线程版本，它能够支持多线程垃圾收集：</p><p><img src="https://pb01.s3.bitiful.net/123.png" alt="avatar"></p><p>除了多线程支持以外，其他内容基本与Serial收集器一致，是许多运行在 Server 模式下的虚拟机的首要选择，新生代采用标记-复制算法，老年代采用标记-整理算法。</p><h4 id="Parallel-Scavenge-Parallel-Old收集器"><a href="#Parallel-Scavenge-Parallel-Old收集器" class="headerlink" title="Parallel Scavenge/Parallel Old收集器"></a>Parallel Scavenge/Parallel Old收集器</h4><p>Parallel Scavenge同样是一款面向新生代的垃圾收集器，同样采用标记复制算法实现，在JDK6时也推出了其老年代收集器Parallel Old，采用标记整理算法实现：</p><p><img src="https://pb01.s3.bitiful.net/124.png" alt="avatar"></p><p>与ParNew收集器不同的是，它会自动衡量一个吞吐量，并根据吞吐量来决定每次垃圾回收的时间，这种自适应机制，能够很好地权衡当前机器的性能，根据性能选择最优方案。</p><p>目前JDK8采用的就是这种 Parallel Scavenge + Parallel Old 的垃圾回收方案。</p><h4 id="CMS收集器"><a href="#CMS收集器" class="headerlink" title="CMS收集器"></a>CMS收集器</h4><p>在JDK1.5，HotSpot推出了一款在强交互应用中几乎可认为有划时代意义的垃圾收集器：CMS（Concurrent-Mark-Sweep,即并行扫描标记）收集器，这款收集器是HotSpot虚拟机中第一款真正意义上的并发（注意这里的并发和之前的并行是有区别的，并发可以理解为同时运行用户线程和GC线程，而并行可以理解为多条GC线程同时工作）收集器，<strong>它第一次实现了让垃圾收集线程与用户线程同时工作</strong>。</p><p>它主要采用标记清除算法：</p><p><img src="https://pb01.s3.bitiful.net/125.png" alt="avatar"></p><p>它的垃圾回收分为4个阶段：</p><ul><li><strong>初始标记：</strong> 暂停所有的其他线程，并记录下直接与 root 相连的对象，速度很快 ；</li><li><strong>并发标记：</strong> 同时开启 GC 和用户线程，用一个闭包结构去记录可达对象。但在这个阶段结束，这个闭包结构并不能保证包含当前所有的可达对象。因为用户线程可能会不断的更新引用域，所以 GC 线程无法保证可达性分析的实时性。所以这个算法里会跟踪记录这些发生引用更新的地方。</li><li><strong>重新标记：</strong> 重新标记阶段就是为了修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段的时间稍长，远远比并发标记阶段时间短</li><li><strong>并发清除：</strong> 开启用户线程，同时 GC 线程开始对未标记的区域做清扫。</li></ul><p>虽然它的优点非常之大，但是缺点也是显而易见的，我们之前说过，标记清除算法会产生大量的内存碎片，导致可用连续空间逐渐变少，长期这样下来，会有更高的概率触发Full GC，并且在与用户线程并发执行的情况下，也会占用一部分的系统资源，导致用户线程的运行速度一定程度上减慢。</p><p>不过，如果你希望的是最低的GC停顿时间，这款垃圾收集器无疑是最佳选择，不过自从G1收集器问世之后，CMS收集器不再推荐使用了。</p><h4 id="Garbage-First-G1-收集器"><a href="#Garbage-First-G1-收集器" class="headerlink" title="Garbage First (G1) 收集器"></a>Garbage First (G1) 收集器</h4><p>此垃圾收集器也是一款划时代的垃圾收集器，在JDK7的时候正式走上历史舞台，它是一款主要面向于服务端的垃圾收集器，并且在JDK9时，取代了JDK8默认的 Parallel Scavenge + Parallel Old 的回收方案。</p><p>我们知道，我们的垃圾回收分为<code>Minor GC</code>、<code>Major GC</code>和<code>Full GC</code>，它们分别对应的是新生代，老年代和整个堆内存的垃圾回收，而G1收集器巧妙地绕过了这些约定，它将整个Java堆划分成<code>2048</code>个大小相同的独立<code>Region</code>块，每个<code>Region块</code>的大小根据堆空间的实际大小而定，整体被控制在1MB到32MB之间，且都为2的N次幂。所有的<code>Region</code>大小相同，且在JVM的整个生命周期内不会发生改变。</p><p>那么分出这些<code>Region</code>有什么意义呢？每一个<code>Region</code>都可以根据需要，自由决定扮演哪个角色（Eden、Survivor和老年代），收集器会根据对应的角色采用不同的回收策略。此外，G1收集器还存在一个Humongous区域，它专门用于存放大对象（一般认为大小超过了Region容量一半的对象为大对象）这样，新生代、老年代在物理上，不再是一个连续的内存区域，而是到处分布的。</p><p><img src="https://pb01.s3.bitiful.net/126.png" alt="avatar"></p><p>它的回收过程与CMS大体类似：</p><p><img src="https://pb01.s3.bitiful.net/127.png" alt="avatar"></p><p>分为以下四个步骤：</p><ul><li><p><strong>初始标记（暂停用户线程）：</strong>仅仅只是标记一下GC Roots能直接关联到的对象，并且修改TAMS指针的值，让下一阶段用户线程并发运行时，能正确地在可用的Region中分配新对象。这个阶段需要停顿线程，但耗时很短，而且是借用进行Minor GC的时候同步完成的，所以G1收集器在这个阶段实际并没有额外的停顿。</p></li><li><p><strong>并发标记：</strong>从GC Root开始对堆中对象进行可达性分析，递归扫描整个堆里的对象图，找出要回收的对象，这阶段耗时较长，但可与用户程序并发执行。</p></li><li><p><strong>最终标记（暂停用户线程）：</strong>对用户线程做一个短暂的暂停，用于处理并发标记阶段漏标的那部分对象。</p></li><li><p><strong>筛选回收：</strong>负责更新Region的统计数据，对各个Region的回收价值和成本进行排序，根据用户所期望的停顿时间来制定回收计划，可以自由选择任意多个Region构成回收集，然后把决定回收的那一部分Region的存活对象复制到空的Region中，再清理掉整个旧Region的全部空间。这里的操作涉及存活对象的移动，是必须暂停用户线程，由多个收集器线程并行完成的。</p></li></ul><p>它具备以下特点：</p><ul><li><strong>并行与并发：</strong>G1 能充分利用 CPU、多核环境下的硬件优势，使用多个 CPU（CPU 或者 CPU 核心）来缩短 Stop-The-World 停顿时间。部分其他收集器原本需要停顿 Java 线程执行的 GC 动作，G1 收集器仍然可以通过并发的方式让 java 程序继续执行。</li><li><strong>分代收集：</strong>虽然 G1 可以不需要其他收集器配合就能独立管理整个 GC 堆，但是还是保留了分代的概念。</li><li><strong>空间整合：</strong>与 CMS 的“标记-清除”算法不同，G1 从整体来看是基于“标记-整理”算法实现的收集器；从局部上来看是基于“标记-复制”算法实现的。</li><li><strong>可预测的停顿：</strong>这是 G1 相对于 CMS 的另一个大优势，降低停顿时间是 G1 和 CMS 共同的关注点，但 G1 除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为 M 毫秒的时间片段内，消耗在垃圾收集上的时间不得超过 N 毫秒。</li></ul><hr><h3 id="元空间"><a href="#元空间" class="headerlink" title="元空间"></a>元空间</h3><p>JDK8之前，Hotspot虚拟机的方法区实际上是永久代实现的。在JDK8之后，Hotspot虚拟机不再使用永久代，而是采用了全新的元空间。类的元信息被存储在元空间中。元空间没有使用堆内存，而是与堆不相连的本地内存区域。所以，理论上系统可以使用的内存有多大，元空间就有多大，所以不会出现永久代存在时的内存溢出问题。这项改造也是有必要的，永久代的调优是很困难的，虽然可以设置永久代的大小，但是很难确定一个合适的大小，因为其中的影响因素很多，比如类数量的多少、常量数量的多少等。</p><p>因此在JDK8时直接将本地内存作为元空间（<strong>Metaspace</strong>）的区域，物理内存有多大，元空间内存就可以有多大，这样永久代的空间分配问题就讲解了，所以最终它变成了这样：</p><p><img src="https://pb01.s3.bitiful.net/128.png" alt="avatar"></p><hr><h3 id="其他引用类型"><a href="#其他引用类型" class="headerlink" title="其他引用类型"></a>其他引用类型</h3><p><strong>1．强引用（StrongReference）</strong></p><p>以前我们使用的大部分引用实际上都是强引用，这是使用最普遍的引用。如果一个对象具有强引用，那就类似于必不可少的生活用品，<strong>垃圾回收器绝不会回收它</strong>。当内存空间不足，Java 虚拟机宁愿抛出 OutOfMemoryError 错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足问题。</p><p><strong>2．软引用（SoftReference）</strong><br>如果一个对象只具有软引用，那就类似于可有可无的生活用品。<strong>如果内存空间足够，垃圾回收器就不会回收它，如果内存空间不足了，就会回收这些对象的内存</strong>。只要垃圾回收器没有回收它，该对象就可以被程序使用。软引用可用来实现内存敏感的高速缓存。软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收，JAVA 虚拟机就会把这个软引用加入到与之关联的引用队列中。</p><p><strong>3．弱引用（WeakReference）</strong><br>如果一个对象只具有弱引用，那就类似于可有可无的生活用品。弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。<strong>在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存</strong>。不过，由于垃圾回收器是一个优先级很低的线程， 因此不一定会很快发现那些只具有弱引用的对象。弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java 虚拟机就会把这个弱引用加入到与之关联的引用队列中。</p><p><strong>4．虚引用（PhantomReference）</strong><br>“虚引用”顾名思义，就是形同虚设，与其他几种引用都不同，虚引用并不会决定对象的生命周期。<strong>如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收</strong>。</p><p><strong>虚引用主要用来跟踪对象被垃圾回收的活动</strong>。</p><p>虚引用与软引用和弱引用的一个区别在于： 虚引用必须和引用队列（ReferenceQueue）联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。程序如果发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动。</p><p>特别注意，在程序设计中一般<strong>很少使用弱引用与虚引用</strong>，使用软引用的情况较多，这是因为软引用可以加速 JVM 对垃圾内存的回收速度，可以维护系统的运行安全，防止内存溢出（OutOfMemory）等问题的产生。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM内存区域</title>
      <link href="/2023/12/18/JVM1/"/>
      <url>/2023/12/18/JVM1/</url>
      
        <content type="html"><![CDATA[<h1 id="JVM内存区域"><a href="#JVM内存区域" class="headerlink" title="JVM内存区域"></a>JVM内存区域</h1><p>在传统的C/C++开发中，我们经常通过使用申请内存的方式来创建对象或是存放某些数据，但是这样也带来了一些额外的问题，我们要在何时释放这些内存，怎么才能使得内存的使用最高效，因此，内存管理是一个非常严肃的问题。</p><p>比如我们就可以通过C语言<strong>malloc函数</strong>动态申请内存，并用于存放数据，而在Java中，这种操作实际上是不允许的，Java只支持直接使用基本数据类型和对象类型，至于内存到底如何分配，并不是由我们来处理，而是JVM帮助我们进行控制，这样就帮助我们节省很多内存上的工作，虽然带来了很大的便利，但是，一旦出现内存问题，我们就无法像C/C++那样对所管理的内存进行合理地处理，因为所有的内存操作都是由JVM在进行，只有了解了JVM的内存管理机制，我们才能够在出现内存相关问题时找到解决方案。</p><h2 id="内存区域划分"><a href="#内存区域划分" class="headerlink" title="内存区域划分"></a>内存区域划分</h2><p>既然要管理内存，那么肯定不会是杂乱无章的，JVM对内存的管理采用的是分区治理，不同的内存区域有着各自的职责所在，在虚拟机运行时，内存区域如下划分：</p><p><img src="https://pb01.s3.bitiful.net/92.png" alt="avatar"><br><img src="https://pb01.s3.bitiful.net/93.png" alt="avatar"></p><p>我们可以看到，内存区域一共分为5个区域，其中方法区,堆和直接内存是所有线程共享的区域，随着虚拟机的创建而创建，虚拟机的结束而销毁，而虚拟机栈、本地方法栈、程序计数器都是线程之间相互隔离的，每个线程都有一个自己的区域，并且线程启动时会自动创建，结束之后会自动销毁。内存划分完成之后，我们的JVM执行引擎和本地库接口，也就是Java程序开始运行之后就会根据分区合理地使用对应区域的内存了。</p><h3 id="大致划分"><a href="#大致划分" class="headerlink" title="大致划分"></a>大致划分</h3><h4 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h4><p>首先我们来介绍一下程序计数器，它和我们的传统8086 CPU中PC寄存器的工作差不多，因为JVM虚拟机目的就是实现物理机那样的程序执行。在8086 CPU中，PC作为程序计数器，负责储存内存地址，该地址指向下一条即将执行的指令，每解释执行完一条指令，PC寄存器的值就会自动被更新为下一条指令的地址，进入下一个指令周期时，就会根据当前地址所指向的指令，进行执行。</p><p>而JVM中的程序计数器可以看做是当前线程所执行字节码的行号指示器，而行号正好就指的是某一条指令，字节码解释器在工作时也会改变这个值，来指定下一条即将执行的指令，分支、循环、跳转、异常处理、线程恢复等功能都需要依赖这个计数器来完成。</p><p>因为Java的多线程也是依靠时间片轮转算法进行的，因此一个CPU同一时间也只会处理一个线程，当某个线程的时间片消耗完成后，会自动切换到下一个线程继续执行，而当前线程的执行位置会被保存到当前线程的程序计数器中，当下次轮转到此线程时，又继续根据之前的执行位置继续向下执行。</p><p>为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各线程之间计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。</p><p>程序计数器因为只需要记录很少的信息，所以只占用很少一部分内存。</p><p>⚠️ 注意：程序计数器是唯一一个不会出现<strong>OutOfMemoryError</strong>的内存区域，它的生命周期随着线程的创建而创建，随着线程的结束而死亡。</p><h4 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h4><p>虚拟机栈就是一个非常关键的部分，看名字就知道它是一个栈结构，每个方法被执行的时候，Java虚拟机都会同步创建一个栈帧（其实就是栈里面的一个元素），栈帧中包括了当前方法的一些信息，比如局部变量表、操作数栈、动态链接、方法出口等。</p><p><img src="https://pb01.s3.bitiful.net/95.png" alt="avatar"></p><p>其中局部变量表主要存放了编译器可知的各种数据类型（boolean、byte、char、short、int、float、long、double）、对象引用（reference 类型，它不同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置），在class文件中就已经定义好了</p><p><strong>操作数栈</strong>主要作为方法调用的中转站使用，用于存放方法执行过程中产生的<strong>中间计算结果</strong>。另外，计算过程中产生的<strong>临时变量</strong>也会放在操作数栈中</p><p>每个栈帧还保存了一个<strong>可以指向当前方法所在类</strong>的<strong>运行时常量池</strong>，目的是：当前方法中如果需要调用其他方法的时候，能够从运行时常量池中找到对应的符号引用，然后将符号引用转换为直接引用，然后就能直接调用对应方法，这就是动态链接</p><p><img src="https://pb01.s3.bitiful.net/94.png" alt="avatar"></p><p>最后是<strong>方法出口</strong>，也就是方法该如何结束，是抛出异常还是正常返回，不管哪种返回方式，都会导致栈帧被弹出。也就是说， 栈帧随着方法调用而创建，随着方法结束而销毁。无论方法正常完成还是异常完成都算作方法结束。</p><p>程序运行中栈可能会出现两种错误：</p><ul><li><strong>StackOverFlowError</strong>： 若栈的内存大小不允许动态扩展，那么当线程请求栈的深度超过当前 Java 虚拟机栈的最大深度的时候，就抛出 StackOverFlowError 错误。</li><li><strong>OutOfMemoryError</strong>： 如果栈的内存大小可以动态扩展， 如果虚拟机在动态扩展栈时无法申请到足够的内存空间，则抛出OutOfMemoryError异常。</li></ul><p>这里我们来模拟一下整个虚拟机栈的运作流程，我们先编写一个测试类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> a();</span><br><span class="line">        System.out.println(res);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">a</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> b();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">b</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> c();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">c</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们的主方法执行后，会依次执行三个方法<code>a() -&gt; b() -&gt; c() -&gt; 返回</code>，我们首先来观察一下反编译之后的结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span> com.test.Main();   #这个是构造方法</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">1</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: aload_0</span><br><span class="line">         <span class="number">1</span>: invokespecial #<span class="number">1</span>                  <span class="comment">// Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">         <span class="number">4</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">3</span>: <span class="number">0</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>       <span class="number">5</span>     <span class="number">0</span>  <span class="built_in">this</span>   Lcom/test/Main;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(java.lang.String[])</span>;    #主方法</span><br><span class="line">    descriptor: ([Ljava/lang/String;)V</span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">2</span>, locals=<span class="number">2</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: invokestatic  #<span class="number">2</span>                  <span class="comment">// Method a:()I</span></span><br><span class="line">         <span class="number">3</span>: istore_1</span><br><span class="line">         <span class="number">4</span>: getstatic     #<span class="number">3</span>                  <span class="comment">// Field java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class="line">         <span class="number">7</span>: iload_1</span><br><span class="line">         <span class="number">8</span>: invokevirtual #<span class="number">4</span>                  <span class="comment">// Method java/io/PrintStream.println:(I)V</span></span><br><span class="line">        <span class="number">11</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">5</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">6</span>: <span class="number">4</span></span><br><span class="line">        line <span class="number">7</span>: <span class="number">11</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>      <span class="number">12</span>     <span class="number">0</span>  args   [Ljava/lang/String;</span><br><span class="line">            <span class="number">4</span>       <span class="number">8</span>     <span class="number">1</span>   res   I</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">a</span><span class="params">()</span>;</span><br><span class="line">    descriptor: ()I</span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">1</span>, locals=<span class="number">0</span>, args_size=<span class="number">0</span></span><br><span class="line">         <span class="number">0</span>: invokestatic  #<span class="number">5</span>                  <span class="comment">// Method b:()I</span></span><br><span class="line">         <span class="number">3</span>: ireturn</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">10</span>: <span class="number">0</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">b</span><span class="params">()</span>;</span><br><span class="line">    descriptor: ()I</span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">1</span>, locals=<span class="number">0</span>, args_size=<span class="number">0</span></span><br><span class="line">         <span class="number">0</span>: invokestatic  #<span class="number">6</span>                  <span class="comment">// Method c:()I</span></span><br><span class="line">         <span class="number">3</span>: ireturn</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">14</span>: <span class="number">0</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">c</span><span class="params">()</span>;</span><br><span class="line">    descriptor: ()I</span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">2</span>, locals=<span class="number">2</span>, args_size=<span class="number">0</span></span><br><span class="line">         <span class="number">0</span>: bipush        <span class="number">10</span></span><br><span class="line">         <span class="number">2</span>: istore_0</span><br><span class="line">         <span class="number">3</span>: bipush        <span class="number">20</span></span><br><span class="line">         <span class="number">5</span>: istore_1</span><br><span class="line">         <span class="number">6</span>: iload_0</span><br><span class="line">         <span class="number">7</span>: iload_1</span><br><span class="line">         <span class="number">8</span>: iadd</span><br><span class="line">         <span class="number">9</span>: ireturn</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">18</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">19</span>: <span class="number">3</span></span><br><span class="line">        line <span class="number">20</span>: <span class="number">6</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">3</span>       <span class="number">7</span>     <span class="number">0</span>     a   I</span><br><span class="line">            <span class="number">6</span>       <span class="number">4</span>     <span class="number">1</span>     b   I</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以看到在编译之后，我们整个方法的最大操作数栈深度、局部变量表都是已经确定好的，当我们程序开始执行时，会根据这些信息封装为对应的栈帧，我们从<code>main</code>方法开始看起：</p><p><img src="https://pb01.s3.bitiful.net/96.png" alt="avatar"></p><p>接着我们继续往下，到了<code>0: invokestatic  #2                  // Method a:()I</code>时，需要调用方法<code>a()</code>，这时当前方法就不会继续向下运行了，而是去执行方法<code>a()</code>，那么同样的，将此方法也入栈，注意是放入到栈顶位置，<code>main</code>方法的栈帧会被压下去：</p><p><img src="https://pb01.s3.bitiful.net/97.png" alt="avatar"></p><p>这时，进入方法a之后，又继而进入到方法b，最后在进入c，因此，到达方法c的时候，我们的虚拟机栈变成了：</p><p><img src="https://pb01.s3.bitiful.net/98.png" alt="avatar"></p><p>现在我们依次执行方法c中的指令，最后返回a+b的结果，在方法c返回之后，也就代表方法c已经执行结束了，栈帧4会自动出栈，这时栈帧3就得到了上一栈帧返回的结果，并继续执行，但是由于紧接着马上就返回，所以继续重复栈帧4的操作，此时栈帧3也出栈并继续将结果交给下一个栈帧2，最后栈帧2再将结果返回给栈帧1，然后栈帧1就可以继续向下运行了，最后输出结果。</p><p><img src="https://pb01.s3.bitiful.net/99.png" alt="avatar"></p><h4 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h4><p>和虚拟机栈所发挥的作用非常相似，区别是：<strong>虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务</strong>。 </p><p>本地方法栈在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。本地方法被执行的时候，在本地方法栈也会创建一个栈帧，用于存放该本地方法的局部变量表、操作数栈、动态链接、出口信息。方法执行完毕后相应的栈帧也会出栈并释放内存空间，也会出现 StackOverFlowError 和 OutOfMemoryError 两种错误。</p><h4 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h4><p>堆是整个Java应用程序共享的区域，也是整个虚拟机最大的一块内存空间，而此区域的职责就是存放和管理对象和数组。</p><p>Java 世界中“<strong>几乎</strong>”所有的对象都在堆中分配，但是，随着 JIT 编译器的发展与逃逸分析技术逐渐成熟，栈上分配、标量替换优化技术将会导致一些微妙的变化，所有的对象都分配到堆上也渐渐变得不那么“绝对”了。从 JDK 1.7 开始已经默认开启逃逸分析，<strong>如果某些方法中的对象引用没有被返回或者未被外面使用（也就是未逃逸出去），那么对象可以直接在栈上分配内存</strong>。</p><p>Java 堆是垃圾收集器管理的主要区域，因此也被称作 GC 堆（Garbage Collected Heap）。从垃圾回收的角度，由于现在收集器基本都采用分代垃圾收集算法，所以 Java 堆还可以细分为：新生代和老年代；再细致一点有：Eden、Survivor、Old 等空间。进一步划分的目的是更好地回收内存，或者更快地分配内存。在 JDK 7 版本及 JDK 7 版本之前，堆内存被通常分为下面三部分：</p><ol><li>新生代内存(Young Generation)</li><li>老生代(Old Generation)</li><li>永久代(Permanent Generation)</li></ol><p>下图所示的 Eden 区、两个 Survivor 区 S0 和 S1 都属于新生代，中间一层属于老年代，最下面一层属于永久代。</p><p><img src="https://pb01.s3.bitiful.net/100.png" alt="avatar"></p><p><strong>JDK 8 版本之后 PermGen(永久代) 已被 Metaspace(元空间) 取代，元空间使用的是本地内存</strong>。</p><p>大多数情况下，对象在新生代中 Eden 区分配。当 Eden 区没有足够空间进行分配时，虚拟机将发起一次 Minor GC(新生代垃圾回收)。在一次新生代垃圾回收后，如果对象还存活，则会进入 S0 或者 S1，并且对象的年龄还会变为1(Eden 区-&gt;Survivor 区后对象的初始年龄变为 1,每经历一次Minor GC且存活下来,年龄+1)。当年龄大小超过了 survivor 区的一半时，取这个年龄和 MaxTenuringThreshold 中更小的一个值，作为新的晋升到老年代的年龄阈值(<strong>长期存活的对象进入老年代</strong>)。</p><p><strong>大对象直接进入老年代:</strong></p><p>对于一个大对象，我们会首先在Eden 尝试创建，如果创建不了，就会触发Minor GC。随后继续尝试在Eden区存放，发现仍然放不下，尝试直接进入老年代，老年代也放不下，触发 Full GC 清理空间,再次放入老年代，如果放不下就报OutOfMemory错误。</p><p>大对象直接进入老年代的行为是由虚拟机动态决定的，它与具体使用的垃圾回收器和相关参数有关。<strong>大对象直接进入老年代是一种优化策略，旨在避免将大对象放入新生代，从而减少新生代的垃圾回收频率和成本</strong>。</p><p>针对 HotSpot VM 的实现，它里面的 GC 其实准确分类只有两大种：<br><strong>1. 部分收集 (Partial GC)</strong>：</p><ul><li>新生代收集（Minor GC / Young GC）：只对新生代进行垃圾收集；</li><li>老年代收集（Major GC / Old GC）：只对老年代进行垃圾收集。需要注意的是 Major GC 在有的语境中也用于指代整堆收集；</li><li>混合收集（Mixed GC）：对整个新生代和部分老年代进行垃圾收集。</li></ul><p><strong>2. 整堆收集 (Full GC)</strong>：收集整个 Java 堆和方法区。</p><ul><li>触发条件1：每次晋升到老年代的对象平均大小大于老年代剩余空间</li><li>触发条件2：Minor GC后存活的对象超过了老年代剩余空间</li><li>触发条件3：永久代内存不足（JDK8之前）</li><li>触发条件4：手动调用<code>System.gc()</code>方法</li></ul><p>堆这里最容易出现的就是 OutOfMemoryError 错误，并且出现这种错误之后的表现形式还会有几种，比如：</p><ul><li><strong>java.lang.OutOfMemoryError: GC Overhead Limit Exceeded</strong>：当 JVM 花太多时间执行垃圾回收并且只能回收很少的堆空间时，就会发生此错误。</li><li><strong>java.lang.OutOfMemoryError: Java heap space</strong> :假如在创建新的对象时, 堆内存中的空间不足以存放新创建的对象, 就会引发此错误。(和配置的最大堆内存有关，且受制于物理内存大小。最大堆内存可通过-Xmx参数配置，若没有特别配置，将会使用默认值)</li></ul><h4 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h4><p>方法区也是整个Java应用程序共享的区域，它用于存储所有的类信息、常量、静态变量、动态编译缓存等数据，可以大致分为两个部分，一个是类信息表，一个是运行时常量池。</p><p>方法区和永久代以及元空间是什么关系呢？永久代以及元空间是 HotSpot 虚拟机对虚拟机规范中方法区的两种实现方式。并且，永久代是 JDK 1.8 之前的方法区实现，JDK 1.8 及以后方法区的实现变成了元空间。</p><p><img src="https://pb01.s3.bitiful.net/101.png" alt="avatar"></p><p>首先类信息表中存放的是当前应用程序加载的所有类信息，包括类的版本、字段、方法、接口等信息，同时会将编译时生成的常量池数据全部存放到运行时常量池中。当然，常量也并不是只能从类信息中获取，在程序运行时，也有可能会有新的常量进入到常量池。</p><p><strong>运行时常量池</strong></p><p>Class 文件中除了有类的版本、字段、方法、接口等描述信息外，还有用于存放编译期生成的各种字面量和符号引用的 常量池表。</p><p>常量池表会在类加载后存放到方法区的运行时常量池中。运行时常量池的功能类似于传统编程语言的符号表，尽管它包含了比典型符号表更广泛的数据。</p><p><strong>字符串常量池</strong><br>字符串常量池 是 JVM 为了提升性能和减少内存消耗针对字符串（String 类）专门开辟的一块区域，主要目的是为了避免字符串的重复创建。</p><p>JDK1.7 之前，字符串常量池存放在永久代。JDK1.7 字符串常量池和静态变量从永久代移动了 Java 堆中。</p><p><strong>JDK 1.7 为什么要将字符串常量池移动到堆中？</strong><br>主要是因为永久代（方法区实现）的 GC 回收效率太低，只有在整堆收集 (Full GC)的时候才会被执行 GC。Java 程序中通常会有大量的被创建的字符串等待回收，将字符串常量池放到堆中，能够更高效及时地回收字符串内存。</p><p>我们编写一个测试用例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line"></span><br><span class="line">    System.out.println(str1 == str2);</span><br><span class="line">    System.out.println(str1.equals(str2));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>得到的结果也是显而易见的，由于<code>str1</code>和<code>str2</code>是单独创建的两个对象，那么这两个对象实际上会在堆中存放，保存在不同的地址：</p><p><img src="https://pb01.s3.bitiful.net/102.png" alt="avatar"></p><p>所以当我们使用<code>==</code>判断时，得到的结果<code>false</code>，而使用<code>equals</code>时因为比较的是值，所以得到<code>true</code>。现在我们来稍微修改一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"></span><br><span class="line">    System.out.println(str1 == str2);</span><br><span class="line">    System.out.println(str1.equals(str2));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在我们没有使用new的形式，而是直接使用双引号创建，那么这时得到的结果就变成了两个<code>true</code>，这是为什么呢？这其实是因为我们直接使用双引号赋值，会先在常量池中查找是否存在相同的字符串，若存在，则将引用直接指向该字符串；若不存在，则在常量池中生成一个字符串，再将引用指向该字符串：</p><p><img src="https://pb01.s3.bitiful.net/103.png" alt="avatar"></p><p>实际上两次调用String类的<code>intern()</code>方法，和上面的效果差不多，也是第一次调用会将堆中字符串复制并放入常量池中，第二次通过此方法获取字符串时，会查看常量池中是否包含，如果包含那么会直接返回常量池中字符串的地址：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">//不能直接写&quot;abc&quot;，双引号的形式，写了就直接在常量池里面吧abc创好了</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;ab&quot;</span>)+<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;c&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;ab&quot;</span>)+<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;c&quot;</span>);</span><br><span class="line"></span><br><span class="line">    System.out.println(str1.intern() == str2.intern());</span><br><span class="line">    System.out.println(str1.equals(str2));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://pb01.s3.bitiful.net/104.png" alt="avatar"></p><p>所以上述结果中得到的依然是两个<code>true</code>。在JDK1.7之后，稍微有一些区别，在调用<code>intern()</code>方法时，当常量池中没有对应的字符串时，不会再进行复制操作，而是将其直接修改为指向当前字符串堆中的的引用：</p><p><img src="https://pb01.s3.bitiful.net/105.png" alt="avatar"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">  <span class="comment">//不能直接写&quot;abc&quot;，双引号的形式，写了就直接在常量池里面吧abc创好了</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;ab&quot;</span>)+<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;c&quot;</span>);</span><br><span class="line">    System.out.println(str1.intern() == str1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以最后我们会发现，<code>str1.intern()</code>和<code>str1</code>都是同一个对象，结果为<code>true</code>。</p><p>最后我们再来进行一个总结，各个内存区域的用途：</p><ul><li>（线程独有）程序计数器：保存当前程序的执行位置。</li><li>（线程独有）虚拟机栈：通过栈帧来维持方法调用顺序，帮助控制程序有序运行。</li><li>（线程独有）本地方法栈：同上，作用与本地方法。</li><li>堆：几乎所有的对象和数组都在这里保存,字符串常量池。</li><li>方法区：类信息、即时编译器的代码缓存、运行时常量池。</li></ul><h3 id="爆内存和爆栈"><a href="#爆内存和爆栈" class="headerlink" title="爆内存和爆栈"></a>爆内存和爆栈</h3><p>实际上，在Java程序运行时，内存容量不可能是无限制的，当我们的对象创建过多或是数组容量过大时，就会导致我们的堆内存不足以存放更多新的对象或是数组，这时就会出现错误，比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] a = <span class="keyword">new</span> <span class="title class_">int</span>[Integer.MAX_VALUE];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们申请了一个容量为21亿多的int型数组，显然，如此之大的数组不可能放在我们的堆内存中，所以程序运行时就会这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> java.lang.OutOfMemoryError: Requested array size exceeds VM limit</span><br><span class="line">at com.test.Main.main(Main.java:<span class="number">5</span>)</span><br></pre></td></tr></table></figure><p>这里得到了一个<code>OutOfMemoryError</code>错误，也就是我们常说的内存溢出错误。我们可以通过参数来控制堆内存的最大值和最小值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Xms最小值 -Xmx最大值</span><br></pre></td></tr></table></figure><p>比如我们现在限制堆内存为固定值1M大小，并且在抛出内存溢出异常时保存当前的内存堆转储快照：</p><p><img src="https://pb01.s3.bitiful.net/106.png" alt="avatar"></p><p>注意堆内存不要设置太小，不然连虚拟机都不足以启动，接着我们编写一个一定会导致内存溢出的程序：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;Test&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">            list.add(<span class="keyword">new</span> <span class="title class_">Test</span>());    <span class="comment">//无限创建Test对象并丢进List中</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在程序运行之后：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">java.lang.OutOfMemoryError: Java heap space</span><br><span class="line">Dumping heap to java_pid35172.hprof ...</span><br><span class="line">Heap dump file created [12895344 bytes in 0.028 secs]</span><br><span class="line">Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: Java heap space</span><br><span class="line">at java.util.Arrays.copyOf(Arrays.java:3210)</span><br><span class="line">at java.util.Arrays.copyOf(Arrays.java:3181)</span><br><span class="line">at java.util.ArrayList.grow(ArrayList.java:267)</span><br><span class="line">at java.util.ArrayList.ensureExplicitCapacity(ArrayList.java:241)</span><br><span class="line">at java.util.ArrayList.ensureCapacityInternal(ArrayList.java:233)</span><br><span class="line">at java.util.ArrayList.add(ArrayList.java:464)</span><br><span class="line">at com.test.Main.main(Main.java:10)</span><br></pre></td></tr></table></figure><p>可以看到错误出现原因正是<code>Java heap space</code>，也就是堆内存满了，并且根据我们设定的VM参数，堆内存保存了快照信息。我们可以在IDEA内置的Profiler中进行查看：</p><p><img src="https://pb01.s3.bitiful.net/107.png" alt="avatar"></p><p>可以很明显地看到，在创建了360146个Test对象之后，堆内存不够了，于是就抛出了内存溢出错误。</p><p>我们接着来看栈溢出，我们知道，虚拟机栈会在方法调用时插入栈帧，那么，设想如果出现无限递归的情况呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        test();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">        test();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这很明显是一个永无休止的程序，并且会不断继续向下调用test方法本身，那么按照我们之前的逻辑推导，无限地插入栈帧那么一定会将虚拟机栈塞满，所以，当栈的深度已经不足以继续插入栈帧时，就会这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; java.lang.StackOverflowError</span><br><span class="line">at com.test.Main.test(Main.java:12)</span><br><span class="line">at com.test.Main.test(Main.java:12)</span><br><span class="line">at com.test.Main.test(Main.java:12)</span><br><span class="line">at com.test.Main.test(Main.java:12)</span><br><span class="line">at com.test.Main.test(Main.java:12)</span><br><span class="line">at com.test.Main.test(Main.java:12)</span><br><span class="line">....以下省略很多行</span><br></pre></td></tr></table></figure><p>这也是我们常说的栈溢出，它和堆溢出比较类似，也是由于容纳不下才导致的，我们可以使用<code>-Xss</code>来设定栈容量。</p><h3 id="申请堆外内存"><a href="#申请堆外内存" class="headerlink" title="申请堆外内存"></a>申请堆外内存</h3><p>除了堆内存可以存放对象数据以外，我们也可以申请堆外内存（直接内存），也就是不受JVM管控的内存区域，这部分区域的内存需要我们自行去申请和释放，实际上本质就是JVM通过C/C++调用<code>malloc</code>函数申请的内存，当然得我们自己去释放了。不过虽然是直接内存，不会受到堆内存容量限制，但是依然会受到本机最大内存的限制，所以还是有可能抛出<code>OutOfMemoryError</code>异常。</p><p>这里我们需要提到一个堆外内存操作类：<code>Unsafe</code>，就像它的名字一样，虽然Java提供堆外内存的操作类，但是实际上它是不安全的，只有你完全了解底层原理并且能够合理控制堆外内存，才能安全地使用堆外内存。</p><p>注意这个类不让我们new，也没有直接获取方式（压根就没想让我们用）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Unsafe</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">registerNatives</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        registerNatives();</span><br><span class="line">        sun.reflect.Reflection.registerMethodsToFilter(Unsafe.class, <span class="string">&quot;getUnsafe&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Unsafe</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Unsafe</span> <span class="variable">theUnsafe</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Unsafe</span>();</span><br><span class="line">  </span><br><span class="line">    <span class="meta">@CallerSensitive</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Unsafe <span class="title function_">getUnsafe</span><span class="params">()</span> &#123;</span><br><span class="line">        Class&lt;?&gt; caller = Reflection.getCallerClass();</span><br><span class="line">        <span class="keyword">if</span> (!VM.isSystemDomainLoader(caller.getClassLoader()))</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">SecurityException</span>(<span class="string">&quot;Unsafe&quot;</span>);   <span class="comment">//不是JDK的类，不让用。</span></span><br><span class="line">        <span class="keyword">return</span> theUnsafe;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>所以我们这里就通过反射给他搞出来：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IllegalAccessException &#123;</span><br><span class="line">    <span class="type">Field</span> <span class="variable">unsafeField</span> <span class="operator">=</span> Unsafe.class.getDeclaredFields()[<span class="number">0</span>];</span><br><span class="line">    unsafeField.setAccessible(<span class="literal">true</span>);</span><br><span class="line">    <span class="type">Unsafe</span> <span class="variable">unsafe</span> <span class="operator">=</span> (Unsafe) unsafeField.get(<span class="literal">null</span>);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>成功拿到Unsafe类之后，我们就可以开始申请堆外内存了，比如我们现在想要申请一个int大小的内存空间，并在此空间中存放一个int类型的数据：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IllegalAccessException &#123;</span><br><span class="line">    <span class="type">Field</span> <span class="variable">unsafeField</span> <span class="operator">=</span> Unsafe.class.getDeclaredFields()[<span class="number">0</span>];</span><br><span class="line">    unsafeField.setAccessible(<span class="literal">true</span>);</span><br><span class="line">    <span class="type">Unsafe</span> <span class="variable">unsafe</span> <span class="operator">=</span> (Unsafe) unsafeField.get(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//申请4字节大小的内存空间，并得到对应位置的地址</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">address</span> <span class="operator">=</span> unsafe.allocateMemory(<span class="number">4</span>);</span><br><span class="line">    <span class="comment">//在对应的地址上设定int的值</span></span><br><span class="line">    unsafe.putInt(address, <span class="number">6666666</span>);</span><br><span class="line">    <span class="comment">//获取对应地址上的Int型数值</span></span><br><span class="line">    System.out.println(unsafe.getInt(address));</span><br><span class="line">    <span class="comment">//释放申请到的内容</span></span><br><span class="line">    unsafe.freeMemory(address);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//由于内存已经释放，这时数据就没了</span></span><br><span class="line">    System.out.println(unsafe.getInt(address));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以来看一下<code>allocateMemory</code>底层是如何调用的，这是一个native方法，我们来看C++源码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UNSAFE_ENTRY</span>(jlong, <span class="built_in">Unsafe_AllocateMemory0</span>(JNIEnv *env, jobject unsafe, jlong size)) &#123;</span><br><span class="line">  <span class="type">size_t</span> sz = (<span class="type">size_t</span>)size;</span><br><span class="line"></span><br><span class="line">  sz = <span class="built_in">align_up</span>(sz, HeapWordSize);</span><br><span class="line">  <span class="type">void</span>* x = os::<span class="built_in">malloc</span>(sz, mtOther);   <span class="comment">//这里调用了os::malloc方法</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">addr_to_java</span>(x);</span><br><span class="line">&#125; UNSAFE_END</span><br></pre></td></tr></table></figure><p>接着来看：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span>* <span class="title">os::malloc</span><span class="params">(<span class="type">size_t</span> size, MEMFLAGS flags)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> os::<span class="built_in">malloc</span>(size, flags, CALLER_PC);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">os::malloc</span><span class="params">(<span class="type">size_t</span> size, MEMFLAGS memflags, <span class="type">const</span> NativeCallStack&amp; stack)</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line">  u_char* ptr;</span><br><span class="line">  ptr = (u_char*)::<span class="built_in">malloc</span>(alloc_size);   <span class="comment">//调用C++标准库函数 malloc(size)</span></span><br><span class="line">....</span><br><span class="line">  <span class="comment">// we do not track guard memory</span></span><br><span class="line">  <span class="keyword">return</span> MemTracker::<span class="built_in">record_malloc</span>((address)ptr, size, memflags, stack, level);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以，我们上面的Java代码转换为C代码，差不多就是这个意思：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> * a = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    *a = <span class="number">6666666</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, *a);</span><br><span class="line">    <span class="built_in">free</span>(a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, *a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以说，直接内存实际上就是JVM申请的一块额外的内存空间，但是它并不在受管控的几种内存空间中，当然这些内存依然属于是JVM的，由于JVM提供的堆内存会进行垃圾回收等工作，效率不如直接申请和操作内存来得快，一些比较追求极致性能的框架会用到堆外内存来提升运行速度，如nio框架。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM启动流程(JDK8)</title>
      <link href="/2023/12/17/JVM%E5%90%AF%E5%8A%A8/"/>
      <url>/2023/12/17/JVM%E5%90%AF%E5%8A%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="JVM启动流程-JDK8"><a href="#JVM启动流程-JDK8" class="headerlink" title="JVM启动流程(JDK8)"></a>JVM启动流程(JDK8)</h2><p>JVM的启动入口是位于jdk/src/share/bin/java.c的JLI_Launch函数,其定义如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">JLI_Launch</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> ** argv,              <span class="comment">/* main argc, argc */</span></span></span><br><span class="line"><span class="params">        <span class="type">int</span> jargc, <span class="type">const</span> <span class="type">char</span>** jargv,          <span class="comment">/* java args */</span></span></span><br><span class="line"><span class="params">        <span class="type">int</span> appclassc, <span class="type">const</span> <span class="type">char</span>** appclassv,  <span class="comment">/* app classpath */</span></span></span><br><span class="line"><span class="params">        <span class="type">const</span> <span class="type">char</span>* fullversion,                <span class="comment">/* full version defined */</span></span></span><br><span class="line"><span class="params">        <span class="type">const</span> <span class="type">char</span>* dotversion,                 <span class="comment">/* dot version defined */</span></span></span><br><span class="line"><span class="params">        <span class="type">const</span> <span class="type">char</span>* pname,                      <span class="comment">/* program name */</span></span></span><br><span class="line"><span class="params">        <span class="type">const</span> <span class="type">char</span>* lname,                      <span class="comment">/* launcher name */</span></span></span><br><span class="line"><span class="params">        jboolean javaargs,                      <span class="comment">/* JAVA_ARGS */</span></span></span><br><span class="line"><span class="params">        jboolean cpwildcard,                    <span class="comment">/* classpath wildcard */</span></span></span><br><span class="line"><span class="params">        jboolean javaw,                         <span class="comment">/* windows-only javaw */</span></span></span><br><span class="line"><span class="params">        jint     ergo_class                     <span class="comment">/* ergnomics policy */</span></span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure><h4 id="1-初始化"><a href="#1-初始化" class="headerlink" title="1.初始化"></a>1.初始化</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">InitLauncher(javaw);  <span class="comment">//初始化启动器</span></span><br><span class="line">DumpState();  <span class="comment">//打印当前状态</span></span><br><span class="line"><span class="comment">//确保开启启动器跟踪状态</span></span><br><span class="line"><span class="keyword">if</span> (JLI_IsTraceLauncher()) &#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Command line args:\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; argc ; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;argv[%d] = %s\n&quot;</span>, i, argv[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    AddOption(<span class="string">&quot;-Dsun.java.launcher.diag=true&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-选择jre版本"><a href="#2-选择jre版本" class="headerlink" title="2.选择jre版本"></a>2.选择jre版本</h4><p>解析参数，读取manifest文件，jre版本校验，加载jre以便确认是否存在，最后将相关环境变量放置好。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SelectVersion(argc, argv, &amp;main_class);</span><br></pre></td></tr></table></figure><h4 id="3-创建JVM执行环境"><a href="#3-创建JVM执行环境" class="headerlink" title="3.创建JVM执行环境"></a>3.创建JVM执行环境</h4><p>确定数据模型，是32位还是64位，以及jvm本身的一些配置在jvm.cfg文件中读取和解析<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CreateExecutionEnvironment(&amp;argc, &amp;argv,</span><br><span class="line">                               jrepath, <span class="keyword">sizeof</span>(jrepath), <span class="comment">//jre路径</span></span><br><span class="line">                               jvmpath, <span class="keyword">sizeof</span>(jvmpath), <span class="comment">//jvm路径</span></span><br><span class="line">                               jvmcfg,  <span class="keyword">sizeof</span>(jvmcfg)); <span class="comment">//jvm配置文件</span></span><br></pre></td></tr></table></figure></p><h4 id="4-加载jvm-so库"><a href="#4-加载jvm-so库" class="headerlink" title="4.加载jvm.so库"></a>4.加载jvm.so库</h4><p>动态加载jvm.so这个共享库，并把jvm.so中的相关函数导出并且初始化</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!IsJavaArgs()) &#123;</span><br><span class="line">        <span class="comment">// 设置一些特殊的环境变量</span></span><br><span class="line">        SetJvmEnvironment(argc,argv);</span><br><span class="line">    &#125;</span><br><span class="line">    ifn.CreateJavaVM = <span class="number">0</span>;</span><br><span class="line">    ifn.GetDefaultJavaVMInitArgs = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (JLI_IsTraceLauncher()) &#123;</span><br><span class="line">        start = CounterGet();     <span class="comment">// 记录启动时间</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 加载VM, 重中之重</span></span><br><span class="line">    <span class="keyword">if</span> (!LoadJavaVM(jvmpath, &amp;ifn)) &#123;</span><br><span class="line">        <span class="keyword">return</span>(<span class="number">6</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (JLI_IsTraceLauncher()) &#123;</span><br><span class="line">        end   = CounterGet();</span><br><span class="line">    &#125;</span><br><span class="line">    JLI_TraceLauncher(<span class="string">&quot;%ld micro seconds to LoadJavaVM\n&quot;</span>,</span><br><span class="line">             (<span class="type">long</span>)(jint)Counter2Micros(end-start));</span><br><span class="line">    ++argv;</span><br><span class="line">    --argc;</span><br><span class="line">    <span class="comment">// 解析更多参数信息</span></span><br><span class="line">    <span class="keyword">if</span> (IsJavaArgs()) &#123;</span><br><span class="line">        <span class="comment">/* Preprocess wrapper arguments */</span></span><br><span class="line">        TranslateApplicationArgs(jargc, jargv, &amp;argc, &amp;argv);</span><br><span class="line">        <span class="keyword">if</span> (!AddApplicationOptions(appclassc, appclassv)) &#123;</span><br><span class="line">            <span class="keyword">return</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* Set default CLASSPATH */</span></span><br><span class="line">        cpath = getenv(<span class="string">&quot;CLASSPATH&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (cpath == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            cpath = <span class="string">&quot;.&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        SetClassPath(cpath);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Parse command line options; if the return value of</span></span><br><span class="line"><span class="comment">     * ParseArguments is false, the program should exit.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// 解析参数</span></span><br><span class="line">    <span class="keyword">if</span> (!ParseArguments(&amp;argc, &amp;argv, &amp;mode, &amp;what, &amp;ret, jrepath))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>(ret);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Override class path if -jar flag was specified */</span></span><br><span class="line">    <span class="keyword">if</span> (mode == LM_JAR) &#123;</span><br><span class="line">        SetClassPath(what);     <span class="comment">/* Override class path */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* set the -Dsun.java.command pseudo property */</span></span><br><span class="line">    SetJavaCommandLineProp(what, argc, argv);</span><br><span class="line">    <span class="comment">/* Set the -Dsun.java.launcher pseudo property */</span></span><br><span class="line">    SetJavaLauncherProp();</span><br><span class="line">    <span class="comment">/* set the -Dsun.java.launcher.* platform properties */</span></span><br><span class="line">    SetJavaLauncherPlatformProps();</span><br></pre></td></tr></table></figure><h4 id="5-初始化jvm"><a href="#5-初始化jvm" class="headerlink" title="5.初始化jvm"></a>5.初始化jvm</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> JVMInit(&amp;ifn, threadStackSize, argc, argv, mode, what, ret);</span><br></pre></td></tr></table></figure><p>JVMInit函数最后一句是<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> ContinueInNewThread(ifn, threadStackSize, argc, argv, mode, what, ret);</span><br></pre></td></tr></table></figure></p><p>继续看ContinueInNewThread函数,会进入ContinueInNewThread0函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ContinueInNewThread0(JavaMain, threadStackSize, (<span class="type">void</span>*)&amp;args);</span><br></pre></td></tr></table></figure><p>实现在新的线程中执行JavaMain函数</p><ol><li>初始化虚拟机，如果报错直接退出。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Initialize the virtual machine */</span></span><br><span class="line">start = CounterGet();</span><br><span class="line"><span class="keyword">if</span> (!InitializeJVM(&amp;vm, &amp;env, &amp;ifn)) &#123;</span><br><span class="line">    JLI_ReportErrorMessage(JVM_ERROR1);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>加载主类</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mainClass = LoadMainClass(env, mode, what);</span><br></pre></td></tr></table></figure><ol><li>获取Application Main Class</li></ol><p>某些没有主方法的Java程序比如JavaFX应用，会获取Application Main Class</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * In some cases when launching an application that needs a helper, e.g., a</span></span><br><span class="line"><span class="comment"> * JavaFX application with no main method, the mainClass will not be the</span></span><br><span class="line"><span class="comment"> * applications own main class but rather a helper class. To keep things</span></span><br><span class="line"><span class="comment"> * consistent in the UI we need to track and report the application main class.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">appClass = GetApplicationClass(env);</span><br></pre></td></tr></table></figure><ol><li>初始化完成</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PostJVMInit(env, appClass, vm);</span><br></pre></td></tr></table></figure><ol><li>获取主类中的主方法</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mainID = (*env)-&gt;GetStaticMethodID(env, mainClass, <span class="string">&quot;main&quot;</span>,<span class="string">&quot;([Ljava/lang/String;)V&quot;</span>);</span><br></pre></td></tr></table></figure><p>在字节码中void main(String[] args)表示为([Ljava/lang/String;)V</p><ol><li>调用主方法</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Invoke main method. */</span></span><br><span class="line">(*env)-&gt;CallStaticVoidMethod(env, mainClass, mainID, mainArgs);</span><br></pre></td></tr></table></figure><ol><li>LEAVE函数结束线程,销毁JVM</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The launcher&#x27;s exit code (in the absence of calls to</span></span><br><span class="line"><span class="comment"> * System.exit) will be non-zero if main threw an exception.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">ret = (*env)-&gt;ExceptionOccurred(env) == <span class="literal">NULL</span> ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">LEAVE();</span><br></pre></td></tr></table></figure><p>流程图如下:<br><img src="https://pb01.s3.bitiful.net/91.png" alt="avatar"></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>西电计科微机原理实验四</title>
      <link href="/2023/12/16/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86%E5%AE%9E%E9%AA%8C4/"/>
      <url>/2023/12/16/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86%E5%AE%9E%E9%AA%8C4/</url>
      
        <content type="html"><![CDATA[<h3 id="西电计科微机原理实验四"><a href="#西电计科微机原理实验四" class="headerlink" title="西电计科微机原理实验四"></a>西电计科微机原理实验四</h3><h4 id="实验要求"><a href="#实验要求" class="headerlink" title="实验要求"></a>实验要求</h4><ol><li>流水灯实验：利用8255的A口、B口、C口循环点亮发光二极管。</li><li>根据输入控制灯的亮灭</li><li>在完成(1)基础上，增加通过读取开关控制流水灯的循环方向和循环方式。</li></ol><p>跟上一次实验基本相同,换了个芯片,然后控制的范围从八颗发光二极管变为了十六颗发光二极管</p><h4 id="基础版"><a href="#基础版" class="headerlink" title="基础版"></a>基础版</h4><p>简单实现了功能1和2,全1左移,全0右移</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line">COM_ADD EQU 0273H </span><br><span class="line">PA_ADD EQU 0270H </span><br><span class="line">PB_ADD EQU 0271H </span><br><span class="line">PC_ADD EQU 0272H </span><br><span class="line">_STACK SEGMENT STACK </span><br><span class="line"> DW 100 DUP(?) </span><br><span class="line">_STACK ENDS </span><br><span class="line">_DATA SEGMENT WORD PUBLIC &#x27;DATA&#x27; </span><br><span class="line">_DATA ENDS </span><br><span class="line">CODE SEGMENT </span><br><span class="line">START PROC NEAR </span><br><span class="line">ASSUME CS:CODE, DS:_DATA, SS:_STACK </span><br><span class="line">MOV AX,_DATA  ; 将数据段地址加载到AX寄存器</span><br><span class="line">MOV DS,AX ; 将数据段地址传送给数据段寄存器DS</span><br><span class="line">NOP </span><br><span class="line">MOV DX,COM_ADD ; 将串口地址传送给DX寄存器</span><br><span class="line">MOV AL,82H ; 设置AL寄存器的值为82H</span><br><span class="line">OUT DX,AL </span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">INPUT:</span><br><span class="line"> ; 清零操作</span><br><span class="line">MOV     AX, 0FFFFH </span><br><span class="line">MOVDX, PA_ADD</span><br><span class="line">OUT     DX, AX</span><br><span class="line">MOVDX, PC_ADD</span><br><span class="line">OUT     DX, AX</span><br><span class="line">; 输入操作</span><br><span class="line">MOVDX, PB_ADD</span><br><span class="line">INal, DX</span><br><span class="line">mov    ah, 0</span><br><span class="line"></span><br><span class="line">; 判断</span><br><span class="line">CMPal, 0FFH ;全1</span><br><span class="line">JZ low1</span><br><span class="line">CMPal, 0 ;全0</span><br><span class="line">JZ high1</span><br><span class="line">MOVDX, PA_ADD</span><br><span class="line">OUTDX, al</span><br><span class="line">JMPINPUT</span><br><span class="line">; 处理输入值为0-7的情况</span><br><span class="line">low1:</span><br><span class="line">MOVal, 7FH ; 设置AL寄存器的值为7FH</span><br><span class="line">MOVDX, PA_ADD ; 将并口PA地址传送给DX寄存器</span><br><span class="line">low2:</span><br><span class="line">ROLal, 1 ; 将AL寄存器的值左循环移位1位</span><br><span class="line">OUTDX, al</span><br><span class="line">CALL    Delay</span><br><span class="line">CMPal, 7FH</span><br><span class="line">JNElow2</span><br><span class="line">MOV    AX, 0FFFFH ; 将AX寄存器的值设为0xFFFF</span><br><span class="line">OUT     DX, AX</span><br><span class="line">; 处理输入值为8-15的情况</span><br><span class="line">low3:</span><br><span class="line">MOVal, 7FH</span><br><span class="line">MOVDX, PC_ADD</span><br><span class="line">low4:</span><br><span class="line">ROLal, 1</span><br><span class="line">OUTDX, al</span><br><span class="line">CALL    Delay</span><br><span class="line">CMPal, 7FH</span><br><span class="line">JNElow4</span><br><span class="line">JMPINPUT</span><br><span class="line"></span><br><span class="line">; 处理输入值为15-8的情况</span><br><span class="line">high1:</span><br><span class="line">MOVal, 0FEH</span><br><span class="line">MOVDX, PC_ADD</span><br><span class="line">high2:</span><br><span class="line">RORal, 1</span><br><span class="line">OUTDX, al</span><br><span class="line">CALL    Delay</span><br><span class="line">CMPal, 0FEH</span><br><span class="line">JNEhigh2</span><br><span class="line">MOV    AX, 0FFFFH</span><br><span class="line">OUT     DX, AX</span><br><span class="line">; 处理输入值为7-0的情况</span><br><span class="line">high3:</span><br><span class="line">MOVal, 0FEH</span><br><span class="line">MOVDX, PA_ADD</span><br><span class="line">high4:</span><br><span class="line">RORal, 1</span><br><span class="line">OUTDX, al</span><br><span class="line">CALL    Delay</span><br><span class="line">CMPal, 0FEH</span><br><span class="line">JNEhigh4</span><br><span class="line">JMPINPUT</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Delay PROC NEAR</span><br><span class="line">Delay1:</span><br><span class="line">XORCX,CX</span><br><span class="line">LOOP$</span><br><span class="line">RET</span><br><span class="line">DelayENDP</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">START ENDP </span><br><span class="line">CODE ENDS </span><br><span class="line">END START</span><br></pre></td></tr></table></figure><h4 id="完整版"><a href="#完整版" class="headerlink" title="完整版"></a>完整版</h4><p>增加了一些功能:</p><ul><li>输入为11010000时,流水灯展示00001101</li><li>输入为00001111时,前8颗发光二极管左移,后8颗发光二极管右移</li><li>输入为11110000时,前8颗发光二极管右移,后8颗发光二极管左移</li></ul><p>这个版本的代码还没有在试验箱上跑过,本来我是想验证完基础版后加上的,但当时我的试验箱出了一些问题,浪费了我好多时间,所以实验的时候只跑了基础版,应该是没有问题的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br></pre></td><td class="code"><pre><span class="line">COM_ADD EQU 0273H </span><br><span class="line">PA_ADD EQU 0270H </span><br><span class="line">PB_ADD EQU 0271H </span><br><span class="line">PC_ADD EQU 0272H </span><br><span class="line">_STACK SEGMENT STACK </span><br><span class="line"> DW 100 DUP(?) </span><br><span class="line">_STACK ENDS </span><br><span class="line">_DATA SEGMENT WORD PUBLIC &#x27;DATA&#x27; </span><br><span class="line">_DATA ENDS </span><br><span class="line">CODE SEGMENT </span><br><span class="line">START PROC NEAR </span><br><span class="line">ASSUME CS:CODE, DS:_DATA, SS:_STACK </span><br><span class="line">MOV AX,_DATA  ; 将数据段地址加载到AX寄存器</span><br><span class="line">MOV DS,AX ; 将数据段地址传送给数据段寄存器DS</span><br><span class="line">NOP </span><br><span class="line">MOV DX,COM_ADD ; 将串口地址传送给DX寄存器</span><br><span class="line">MOV AL,82H ; 设置AL寄存器的值为82H</span><br><span class="line">OUT DX,AL </span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">INPUT:</span><br><span class="line"> ; 清零操作</span><br><span class="line">MOV     AX, 0FFFFH </span><br><span class="line">MOVDX, PA_ADD</span><br><span class="line">OUT     DX, AX</span><br><span class="line">MOVDX, PC_ADD</span><br><span class="line">OUT     DX, AX</span><br><span class="line">; 输入操作</span><br><span class="line">MOVDX, PB_ADD</span><br><span class="line">INal, DX</span><br><span class="line">mov    ah, 0</span><br><span class="line">; 判断</span><br><span class="line">        CMPal, 0D0H </span><br><span class="line">JZ mid</span><br><span class="line">        cmp al, 0FH </span><br><span class="line">        JZ lar1 </span><br><span class="line">        cmp al, 0F0H </span><br><span class="line">        JZ ral1</span><br><span class="line">CMPal, 0FFH ;全1,</span><br><span class="line">JZ low1</span><br><span class="line">CMPal, 0 ;全0</span><br><span class="line">JZ high1</span><br><span class="line">MOVDX, PA_ADD</span><br><span class="line">OUTDX, al</span><br><span class="line">JMPINPUT</span><br><span class="line">; 处理输入值为0-7的情况</span><br><span class="line">mid:</span><br><span class="line">shl al,4</span><br><span class="line">        shr al,4</span><br><span class="line">        shr ah,4</span><br><span class="line">        add al,ah</span><br><span class="line">        mov ah,0</span><br><span class="line">        mov dx, PA_ADD ;00001101</span><br><span class="line">        out dx,ax</span><br><span class="line">        jmp INPUT</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">; 处理输入值为0-7的情况</span><br><span class="line">ral1:</span><br><span class="line">MOVal, 7FH ; 设置AL寄存器的值为7FH</span><br><span class="line">MOVDX, PA_ADD ; 将并口PA地址传送给DX寄存器</span><br><span class="line">ral2:</span><br><span class="line">RORal, 1 ; 将AL寄存器的值左循环移位1位</span><br><span class="line">OUTDX, al</span><br><span class="line">CALL    Delay</span><br><span class="line">CMPal, 7FH</span><br><span class="line">JNElow2</span><br><span class="line">MOV    AX, 0FFFFH ; 将AX寄存器的值设为0xFFFF</span><br><span class="line">OUT     DX, AX</span><br><span class="line">; 处理输入值为8-15的情况</span><br><span class="line">ral3:</span><br><span class="line">MOVal, 7FH</span><br><span class="line">MOVDX, PC_ADD</span><br><span class="line">ral4:</span><br><span class="line">ROLal, 1</span><br><span class="line">OUTDX, al</span><br><span class="line">CALL    Delay</span><br><span class="line">CMPal, 7FH</span><br><span class="line">JNElow4</span><br><span class="line">JMPINPUT</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">; 处理输入值为0-7的情况</span><br><span class="line">lar1:</span><br><span class="line">MOVal, 7FH ; 设置AL寄存器的值为7FH</span><br><span class="line">MOVDX, PA_ADD ; 将并口PA地址传送给DX寄存器</span><br><span class="line">lar2:</span><br><span class="line">ROLal, 1 ; 将AL寄存器的值左循环移位1位</span><br><span class="line">OUTDX, al</span><br><span class="line">CALL    Delay</span><br><span class="line">CMPal, 7FH</span><br><span class="line">JNElow2</span><br><span class="line">MOV    AX, 0FFFFH ; 将AX寄存器的值设为0xFFFF</span><br><span class="line">OUT     DX, AX</span><br><span class="line">; 处理输入值为8-15的情况</span><br><span class="line">lar3:</span><br><span class="line">MOVal, 7FH</span><br><span class="line">MOVDX, PC_ADD</span><br><span class="line">lar4:</span><br><span class="line">RORal, 1</span><br><span class="line">OUTDX, al</span><br><span class="line">CALL    Delay</span><br><span class="line">CMPal, 7FH</span><br><span class="line">JNElow4</span><br><span class="line">JMPINPUT</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">; 处理输入值为0-7的情况</span><br><span class="line">low1:</span><br><span class="line">MOVal, 7FH ; 设置AL寄存器的值为7FH</span><br><span class="line">MOVDX, PA_ADD ; 将并口PA地址传送给DX寄存器</span><br><span class="line">low2:</span><br><span class="line">ROLal, 1 ; 将AL寄存器的值左循环移位1位</span><br><span class="line">OUTDX, al</span><br><span class="line">CALL    Delay</span><br><span class="line">CMPal, 7FH</span><br><span class="line">JNElow2</span><br><span class="line">MOV    AX, 0FFFFH ; 将AX寄存器的值设为0xFFFF</span><br><span class="line">OUT     DX, AX</span><br><span class="line">; 处理输入值为8-15的情况</span><br><span class="line">low3:</span><br><span class="line">MOVal, 7FH</span><br><span class="line">MOVDX, PC_ADD</span><br><span class="line">low4:</span><br><span class="line">ROLal, 1</span><br><span class="line">OUTDX, al</span><br><span class="line">CALL    Delay</span><br><span class="line">CMPal, 7FH</span><br><span class="line">JNElow4</span><br><span class="line">JMPINPUT</span><br><span class="line"></span><br><span class="line">; 处理输入值为15-8的情况</span><br><span class="line">high1:</span><br><span class="line">MOVal, 0FEH</span><br><span class="line">MOVDX, PC_ADD</span><br><span class="line">high2:</span><br><span class="line">RORal, 1</span><br><span class="line">OUTDX, al</span><br><span class="line">CALL    Delay</span><br><span class="line">CMPal, 0FEH</span><br><span class="line">JNEhigh2</span><br><span class="line">MOV    AX, 0FFFFH</span><br><span class="line">OUT     DX, AX</span><br><span class="line">; 处理输入值为7-0的情况</span><br><span class="line">high3:</span><br><span class="line">MOVal, 0FEH</span><br><span class="line">MOVDX, PA_ADD</span><br><span class="line">high4:</span><br><span class="line">RORal, 1</span><br><span class="line">OUTDX, al</span><br><span class="line">CALL    Delay</span><br><span class="line">CMPal, 0FEH</span><br><span class="line">JNEhigh4</span><br><span class="line">JMPINPUT</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Delay PROC NEAR</span><br><span class="line">Delay1:</span><br><span class="line">XORCX,CX</span><br><span class="line">LOOP$</span><br><span class="line">RET</span><br><span class="line">DelayENDP</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">START ENDP </span><br><span class="line">CODE ENDS </span><br><span class="line">END START</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> xdu </category>
          
      </categories>
      
      
        <tags>
            
            <tag> lab </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OpenSSL实现单向认证</title>
      <link href="/2023/12/14/Openssl/"/>
      <url>/2023/12/14/Openssl/</url>
      
        <content type="html"><![CDATA[<h2 id="OpenSSL实现单向认证"><a href="#OpenSSL实现单向认证" class="headerlink" title="OpenSSL实现单向认证"></a>OpenSSL实现单向认证</h2><h3 id="OpenSSL的安装"><a href="#OpenSSL的安装" class="headerlink" title="OpenSSL的安装"></a>OpenSSL的安装</h3><p>OpenSSL采用C语言作为开发语言，这使得它具有优秀的跨平台性能，OpenSSL支持：</p><ul><li>Linux</li><li>Windows</li><li>Mac<br>等常见操作系统<br><a href="https://github.com/openssl/openssl" style="color: #177cb0; text-decoration: underline;text-decoration-style: dotted;">OpenSSL github地址</a></li></ul><p>win和mac需要单独去下OpenSSL客户端,网上也有很多教程,可以自己去找找看</p><p>Linux系统自带OpenSSL库,一般不需要下载安装,我会使用<strong>KALI Linux</strong>进行本次实验</p><p>查看下openssl的版本:<br><img src="https://pb01.s3.bitiful.net/81.png" alt="avatar"></p><h3 id="简单通信过程"><a href="#简单通信过程" class="headerlink" title="简单通信过程"></a>简单通信过程</h3><p>下面以最常见的单向认证为例，简述一下通信过程：</p><ol><li><p>客户端向服务器发送请求</p></li><li><p>服务器将包含公钥的证书通过明文发送给客户端</p></li><li><p>客户端通过根证书验证服务器证书是否有效</p></li><li><p>如果有效，客户端生成一个随机密钥，也叫对称加密密钥，使用服务器的公钥进行加密传输</p></li><li><p>服务器通过私钥解密客户端传输的对称加密密钥</p></li><li><p>这时只有服务器和客户端知道这个对称加密密钥，双方可以进行对称加密传输</p></li></ol><p><img src="https://pb01.s3.bitiful.net/82.png" alt="avatar"></p><h3 id="颁发证书"><a href="#颁发证书" class="headerlink" title="颁发证书"></a>颁发证书</h3><p>通过vim /usr/lib/ssl/openssl.cnf修改配置文件，这里修改了默认文件夹、私钥名、证书名。<br><img src="https://pb01.s3.bitiful.net/83.png" alt="avatar"><br><img src="https://pb01.s3.bitiful.net/84.png" alt="avatar"></p><p><strong>在默认文件夹创建所需的目录和文件</strong><br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mkdir -pv ssl</span><br><span class="line">cd ssl</span><br><span class="line">mkdir -pv &#123;certs,csr,newcerts,private&#125;</span><br><span class="line">touch &#123;serial,index.txt,index.txt.attr&#125;</span><br></pre></td></tr></table></figure><br><img src="https://pb01.s3.bitiful.net/85.png" alt="avatar"></p><p><strong>指明证书开始的编号</strong><br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo 01 &gt;&gt; serial</span><br></pre></td></tr></table></figure></p><p><strong>生成根证书私钥</strong><br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl genrsa -out private/ca.key 2048</span><br></pre></td></tr></table></figure></p><ul><li><p>genrsa: 产生rsa密钥命令</p></li><li><p>-out: 输出路径</p></li></ul><p>这里的参数2048，指的是密钥的长度位数，默认长度为512位，密钥越长，安全性越高，但是生成速度也越慢。</p><p><strong>生成自签名证书</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl req -new -x509 -key private/ca.key -out ca.crt -days 365</span><br></pre></td></tr></table></figure><ul><li><p>-new：表示生成一个新证书签署请求</p></li><li><p>-x509：专用于CA生成自签证书，如果不是自签证书则不需要此项</p></li><li><p>-key：用到的私钥文件</p></li><li><p>-out：证书的保存路径</p></li><li><p>-days：证书的有效期限，单位是day（天），默认是openssl.cnf的default_days</p></li></ul><p><img src="https://pb01.s3.bitiful.net/86.png" alt="avatar"></p><p><strong>生成服务器密钥</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl genrsa -out private/server.key 2048</span><br></pre></td></tr></table></figure><p>生成请求文件,图中划线的这几项需和根证书一致，后几项最好也保持一致。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl req -new -key private/server.key -out csr/server.csr</span><br></pre></td></tr></table></figure></p><p><img src="https://pb01.s3.bitiful.net/87.png" alt="avatar"></p><p><strong>颁发证书</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl ca -in csr/server.csr -out certs/server.crt</span><br></pre></td></tr></table></figure><p><img src="https://pb01.s3.bitiful.net/88.png" alt="avatar"></p><h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><p>下面通过一个例程来模拟单向SSL认证，服务器需要准备好刚刚签发的服务器证书，和一定要好好保管的密钥，客户端只需准备好根证书就行，用来验证服务器的证书。</p><p><strong>服务端代码</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> ssl</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">server_ssl</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">build_listen</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># 生成SSL上下文</span></span><br><span class="line">        context = ssl.SSLContext(ssl.PROTOCOL_TLS_SERVER)</span><br><span class="line">        <span class="comment"># 加载服务器所用证书和私钥</span></span><br><span class="line">        context.load_cert_chain(<span class="string">&#x27;server.crt&#x27;</span>, <span class="string">&#x27;server.key&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 监听端口</span></span><br><span class="line">        <span class="keyword">with</span> socket.socket(socket.AF_INET, socket.SOCK_STREAM, <span class="number">0</span>) <span class="keyword">as</span> sock:</span><br><span class="line">            sock.bind((<span class="string">&#x27;0.0.0.0&#x27;</span>, <span class="number">8888</span>))</span><br><span class="line">            sock.listen(<span class="number">5</span>)</span><br><span class="line">            <span class="comment"># 将socket打包成SSL socket</span></span><br><span class="line">            <span class="keyword">with</span> context.wrap_socket(sock, server_side=<span class="literal">True</span>) <span class="keyword">as</span> ssock:</span><br><span class="line">                <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">                    <span class="comment"># 接收客户端连接</span></span><br><span class="line">                    client_socket, addr = ssock.accept()</span><br><span class="line">                    <span class="comment"># 接收客户端信息</span></span><br><span class="line">                    msg = client_socket.recv(<span class="number">1024</span>).decode(<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line">                    <span class="built_in">print</span>(<span class="string">&quot;receive msg from client &#123;&#125;：&#123;&#125;&quot;</span>.<span class="built_in">format</span>(addr, msg))</span><br><span class="line">                    <span class="comment"># 向客户端发送信息</span></span><br><span class="line">                    msg = <span class="string">&quot;yes , you have client_socketect with server.\r\n&quot;</span>.encode(<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line">                    client_socket.send(msg)</span><br><span class="line">                    client_socket.close()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    server = server_ssl()</span><br><span class="line">    server.build_listen()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>客户端代码</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> ssl</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">client_ssl</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">send_hello</span>(<span class="params">self,</span>):</span><br><span class="line">        <span class="comment"># 生成SSL上下文</span></span><br><span class="line">        context = ssl.SSLContext(ssl.PROTOCOL_TLS_CLIENT)</span><br><span class="line">        <span class="comment"># 加载信任根证书</span></span><br><span class="line">        context.load_verify_locations(<span class="string">&#x27;ca.crt&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 与服务端建立socket连接</span></span><br><span class="line">        <span class="keyword">with</span> socket.create_connection((<span class="string">&#x27;0.0.0.0&#x27;</span>, <span class="number">8888</span>)) <span class="keyword">as</span> sock:</span><br><span class="line">            <span class="comment"># 将socket打包成SSL socket</span></span><br><span class="line">            <span class="comment"># 一定要注意的是这里的server_hostname不是指服务端IP，而是指服务端证书中的CN。</span></span><br><span class="line">            <span class="keyword">with</span> context.wrap_socket(sock, server_hostname=<span class="string">&#x27;USER1&#x27;</span>) <span class="keyword">as</span> ssock:</span><br><span class="line">                <span class="comment"># 向服务端发送信息</span></span><br><span class="line">                msg = <span class="string">&quot;do i connect with server ?&quot;</span>.encode(<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line">                ssock.send(msg)</span><br><span class="line">                <span class="comment"># 接收服务端返回的信息</span></span><br><span class="line">                msg = ssock.recv(<span class="number">1024</span>).decode(<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;receive msg from server : &#123;&#125;&quot;</span>.<span class="built_in">format</span>(msg))</span><br><span class="line">                ssock.close()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    client = client_ssl()</span><br><span class="line">    client.send_hello()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>结果</strong></p><p>服务端<br><img src="https://pb01.s3.bitiful.net/89.png" alt="avatar"></p><p>客户端<br><img src="https://pb01.s3.bitiful.net/90.png" alt="avatar"></p>]]></content>
      
      
      <categories>
          
          <category> xdu </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 安全 </tag>
            
            <tag> lab </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>对自己的博客网站进行DOS攻击</title>
      <link href="/2023/12/13/DOS%E6%94%BB%E5%87%BB/"/>
      <url>/2023/12/13/DOS%E6%94%BB%E5%87%BB/</url>
      
        <content type="html"><![CDATA[<h3 id="对自己的博客网站进行DOS攻击"><a href="#对自己的博客网站进行DOS攻击" class="headerlink" title="对自己的博客网站进行DOS攻击"></a>对自己的博客网站进行DOS攻击</h3><p>先说明一点,别对别人的网站进行ddos/dos攻击(dos攻击一般短时间攻击不下来),这是违法的,很多都有自动报警机制,<strong>本篇博客仅用于学习,请勿用于非法用途</strong></p><h4 id="安装kaili-Linux"><a href="#安装kaili-Linux" class="headerlink" title="安装kaili Linux"></a>安装kaili Linux</h4><p>进入<a href="https://www.kali.org/get-kali/#kali-platforms" style="color: #177cb0; text-decoration: underline;text-decoration-style: dotted;">KALI官网</a>,下载iso镜像文件</p><p><img src="https://pb01.s3.bitiful.net/57.png" alt="avatar"></p><p>vmware新建虚拟机,选择自定义<br><img src="https://pb01.s3.bitiful.net/58.png" alt="avatar"></p><p>点击下一步</p><p><img src="https://pb01.s3.bitiful.net/59.png" alt="avatar"></p><p>点击下一步<br><img src="https://pb01.s3.bitiful.net/60.png" alt="avatar"><br>选择稍后安装操作系统,点击下一步<br><img src="https://pb01.s3.bitiful.net/61.png" alt="avatar"><br>选择Debian系统,版本根据自己的kali版本来,我这里就选最新的Debian12,点击下一步<br><img src="https://pb01.s3.bitiful.net/62.png" alt="avatar"><br>虚拟机名称和存储位置根据自己情况来,点击下一步<br><img src="https://pb01.s3.bitiful.net/63.png" alt="avatar"><br>处理器配置根据自己电脑的配置来,点击下一步<br><img src="https://pb01.s3.bitiful.net/64.png" alt="avatar"><br>内存也是根据自己的使用情况来,点击下一步<br><img src="https://pb01.s3.bitiful.net/65.png" alt="avatar"><br>点击下一步<br><img src="https://pb01.s3.bitiful.net/66.png" alt="avatar"><br>点击下一步<br><img src="https://pb01.s3.bitiful.net/67.png" alt="avatar"><br>点击下一步<br><img src="https://pb01.s3.bitiful.net/68.png" alt="avatar"><br>点击下一步<br><img src="https://pb01.s3.bitiful.net/69.png" alt="avatar"><br>点击下一步<br><img src="https://pb01.s3.bitiful.net/70.png" alt="avatar"><br>点击下一步<br><img src="https://pb01.s3.bitiful.net/71.png" alt="avatar"><br>点击自定义硬件<br><img src="https://pb01.s3.bitiful.net/72.png" alt="avatar"><br>导入下载好的ISO文件,关闭后点击完成即可</p><p>剩下启动后的配置就比较简单了,根据自己情况来即可</p><p>安装完成后打开是这样的:<br><img src="https://pb01.s3.bitiful.net/73.png" alt="avatar"></p><h4 id="换源-更新"><a href="#换源-更新" class="headerlink" title="换源+更新"></a>换源+更新</h4><p><img src="https://pb01.s3.bitiful.net/74.png" alt="avatar"></p><p>进入root权限<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo su</span><br></pre></td></tr></table></figure></p><p>输入密码后,换源<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/apt/sources.list</span><br></pre></td></tr></table></figure></p><p>部分国内源:<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">官方源</span><br><span class="line">deb http://http.kali.org/kali kali-rolling main non-free contrib</span><br><span class="line">deb-src http://http.kali.org/kali kali-rolling main non-free contrib</span><br><span class="line">中科大</span><br><span class="line">deb http://mirrors.ustc.edu.cn/kali kali-rolling main non-free contrib</span><br><span class="line">deb-src http://mirrors.ustc.edu.cn/kali kali-rolling main non-free contrib</span><br><span class="line">阿里云</span><br><span class="line">deb http://mirrors.aliyun.com/kali kali-rolling main non-free contrib</span><br><span class="line">deb-src http://mirrors.aliyun.com/kali kali-rolling main non-free contrib</span><br><span class="line">清华大学</span><br><span class="line">deb http://mirrors.tuna.tsinghua.edu.cn/kali kali-rolling main contrib non-free</span><br><span class="line">deb-src https://mirrors.tuna.tsinghua.edu.cn/kali kali-rolling main contrib non-free</span><br><span class="line">浙大</span><br><span class="line">deb http://mirrors.zju.edu.cn/kali kali-rolling main contrib non-free</span><br><span class="line">deb-src http://mirrors.zju.edu.cn/kali kali-rolling main contrib non-free</span><br><span class="line">东软大学</span><br><span class="line">deb http://mirrors.neusoft.edu.cn/kali kali-rolling/main non-free contrib</span><br><span class="line">deb-src http://mirrors.neusoft.edu.cn/kali kali-rolling/main non-free contrib</span><br><span class="line">重庆大学</span><br><span class="line">deb http://http.kali.org/kali kali-rolling main non-free contrib</span><br><span class="line">deb-src http://http.kali.org/kali kali-rolling main non-free contrib</span><br></pre></td></tr></table></figure></p><p>自己选一个换上就行,然后进行更新:<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br></pre></td></tr></table></figure></p><h4 id="DOS攻击"><a href="#DOS攻击" class="headerlink" title="DOS攻击"></a>DOS攻击</h4><p>未被攻击前访问我的网站是这样的:</p><p><img src="https://pb01.s3.bitiful.net/75.webp" alt="avatar"></p><p><img src="https://pb01.s3.bitiful.net/76.webp" alt="avatar"></p><p>下载Dos脚本<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/Andysun06/ddos</span><br></pre></td></tr></table></figure></p><p><img src="https://pb01.s3.bitiful.net/77.png" alt="avatar"></p><p>进入ddos文件夹<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd ddos</span><br></pre></td></tr></table></figure></p><p>执行python脚本<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python ddos-p3.py</span><br></pre></td></tr></table></figure></p><p>结果如下,下面这两张用的是别人的图,不想打码了(雾<br><img src="https://pb01.s3.bitiful.net/78.png" alt="avatar"></p><p><img src="https://pb01.s3.bitiful.net/80.png" alt="avatar"></p><p>反正我攻击了大概8分钟,网站还是可以正常访问的,由于阿里云服务器有一定量的免费的cdn防护,我个人进行DOS攻击至少需要一小时才能耗完.这次只是实验一下,所以就不继续了.</p><p><img src="https://pb01.s3.bitiful.net/79.png" alt="avatar"><br>我们可以看到受到攻击后服务器的带宽是有被大量消耗的,说明我们的攻击是有效的.</p><h4 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h4><p>去作者的github上把代码拉下来,看看是怎么写的:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">os.system(<span class="string">&quot;clear&quot;</span>)</span><br><span class="line">os.system(<span class="string">&quot;figlet DDos Attack&quot;</span>)</span><br><span class="line">ip = <span class="built_in">input</span>(<span class="string">&quot;请输入 IP     : &quot;</span>)</span><br><span class="line">port = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;攻击端口      : &quot;</span>))</span><br><span class="line">sd = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;攻击速度(1~1000) : &quot;</span>))</span><br><span class="line"></span><br><span class="line">os.system(<span class="string">&quot;clear&quot;</span>)</span><br><span class="line"></span><br><span class="line">sent = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">     sock.sendto(<span class="built_in">bytes</span>, (ip,port))</span><br><span class="line">     sent = sent + <span class="number">1</span></span><br><span class="line">     <span class="built_in">print</span> (<span class="string">&quot;已发送 %s 个数据包到 %s 端口 %d&quot;</span>%(sent,ip,port))</span><br><span class="line">     time.sleep((<span class="number">1000</span>-sd)/<span class="number">2000</span>)</span><br></pre></td></tr></table></figure><p>核心代码就这么几行,其实就是不断向指定IP的端口发送数据包,然后打印发送数据包的个数.</p>]]></content>
      
      
      <categories>
          
          <category> xdu </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 安全 </tag>
            
            <tag> lab </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>西电计科微机原理实验三</title>
      <link href="/2023/12/11/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86%E5%AE%9E%E9%AA%8C3/"/>
      <url>/2023/12/11/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86%E5%AE%9E%E9%AA%8C3/</url>
      
        <content type="html"><![CDATA[<h3 id="西电计科微机原理实验三"><a href="#西电计科微机原理实验三" class="headerlink" title="西电计科微机原理实验三"></a>西电计科微机原理实验三</h3><h4 id="实验要求"><a href="#实验要求" class="headerlink" title="实验要求"></a>实验要求</h4><ol><li>开关Yi为低电平时对应的发光二极管亮，Yi为高电平时对应的发光二极管灭。</li><li>当开关Yi全为高电平时，发光二极管Qi从左至右轮流点亮。</li><li>当开关Yi全为低电平时，发光二极管Qi从右至左轮流点亮。</li><li>自主设计控制及显示模式，完成编程调试，演示实验结果。</li></ol><p>我没做要求1,当开关Yi不是全为低电平和高电平时,发光二极管Qi按1423的顺序点亮,这里可以按照自己的需求改,可以把剩下的四个也加上去,顺序也可以改,如果你要做要求1,开关Yi为某特定值时跳转Light更好(在实验四中实现类似功能)</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line">IO244equ230h;244</span><br><span class="line">IO273equ230h;273</span><br><span class="line"></span><br><span class="line">_stack segmentstack</span><br><span class="line">       dw 100 DUP(?)</span><br><span class="line">_stackends</span><br><span class="line"></span><br><span class="line">_data segmentword public &#x27;DATA&#x27;</span><br><span class="line">_dataends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">main proc</span><br><span class="line">        assume cs:code,ds:_data,ss:_stack</span><br><span class="line">; 初始化寄存器</span><br><span class="line">        mov    ax,_data</span><br><span class="line">        mov    ds,ax</span><br><span class="line">        mov    bx,0fefeh</span><br><span class="line">start:  mov    dx,IO244 ; 读取244引脚的输入值</span><br><span class="line">        in     al,dx</span><br><span class="line">        mov    ah,al</span><br><span class="line">        cmp    al,0ffh ; 判断输入值是否为0xff，如果不是，则进行翻转操作       </span><br><span class="line">        jnz    Next0</span><br><span class="line">        call   ROLeft ; 调用ROLeft函数进行左移操作</span><br><span class="line">        jmp    Next2</span><br><span class="line">Next0:  cmp    al,0 ; 判断输入值是否为0，如果不是，跳转Next1         </span><br><span class="line">        jnz    Next1</span><br><span class="line">        call   RORight </span><br><span class="line">        jmp    Next2</span><br><span class="line">Next1:  call   Light</span><br><span class="line">Next2:  call   Delay</span><br><span class="line">        jmp    start</span><br><span class="line">main endp</span><br><span class="line"></span><br><span class="line">ROLeft procnear</span><br><span class="line">; 左移bl寄存器，并将结果存储在al寄存器中</span><br><span class="line">        rol    bl,1</span><br><span class="line">        mov    al,bl</span><br><span class="line">; 输出左移后的值到273引脚</span><br><span class="line">        mov    dx,IO273</span><br><span class="line">        out    dx,ax</span><br><span class="line">        ret</span><br><span class="line">ROLeft endp</span><br><span class="line"></span><br><span class="line">RORight proc near</span><br><span class="line">; 右移bl寄存器，并将结果存储在al寄存器中</span><br><span class="line">        ror    bl,1</span><br><span class="line">        mov    al,bl</span><br><span class="line">        mov    dx,IO273</span><br><span class="line">        out    dx,ax</span><br><span class="line">        ret</span><br><span class="line">RORight endp</span><br><span class="line"></span><br><span class="line">Light proc near</span><br><span class="line">xor    bh,1  ;bx高八位与1异或</span><br><span class="line">        mov    al,bh</span><br><span class="line">        mov    dx,IO273</span><br><span class="line">        out    dx,ax</span><br><span class="line">call   Delay</span><br><span class="line">xor    bh,8 </span><br><span class="line">        mov    al,bh</span><br><span class="line">        mov    dx,IO273</span><br><span class="line">        out    dx,ax</span><br><span class="line">call   Delay</span><br><span class="line">xor    bh,2 </span><br><span class="line">        mov    al,bh</span><br><span class="line">        mov    dx,IO273</span><br><span class="line">        out    dx,ax</span><br><span class="line">call   Delay</span><br><span class="line">xor    bh,4 </span><br><span class="line">        mov    al,bh</span><br><span class="line">        mov    dx,IO273</span><br><span class="line">        out    dx,ax</span><br><span class="line">call   Delay</span><br><span class="line">        ret</span><br><span class="line">Light endp</span><br><span class="line"></span><br><span class="line">Delay proc near                 </span><br><span class="line">        xor    cx,cx</span><br><span class="line">delay1: loop   delay1</span><br><span class="line">        ret</span><br><span class="line">Delay endp</span><br><span class="line">code ends</span><br><span class="line">ENDmain</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> xdu </category>
          
      </categories>
      
      
        <tags>
            
            <tag> lab </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>流式异步响应实现</title>
      <link href="/2023/12/05/2023-12-5-OpenAI-01/"/>
      <url>/2023/12/05/2023-12-5-OpenAI-01/</url>
      
        <content type="html"><![CDATA[<h3 id="流式异步响应实现"><a href="#流式异步响应实现" class="headerlink" title="流式异步响应实现"></a>流式异步响应实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@RestController()</span>  <span class="comment">//注解为REST控制器,以便处理HTTP请求和响应</span></span><br><span class="line"><span class="meta">@CrossOrigin(&quot;*&quot;)</span>  <span class="comment">//允许所有跨域请求</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/api/v1/&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ChatGPTAIServiceControllerOld</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> OpenAiSession openAiSession;  </span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> ThreadPoolExecutor threadPoolExecutor;  <span class="comment">//注入线程池,提高处理效率</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;chat/completions&quot;, method = RequestMethod.POST)</span></span><br><span class="line">    <span class="keyword">public</span> ResponseBodyEmitter <span class="title function_">completionsStream</span><span class="params">(<span class="meta">@RequestBody</span> ChatGPTRequestDTO request, <span class="meta">@RequestHeader(&quot;Authorization&quot;)</span> String token, HttpServletResponse response)</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;流式问答请求开始，使用模型：&#123;&#125; 请求信息：&#123;&#125;&quot;</span>, request.getModel(), JSON.toJSONString(request.getMessages()));</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 1. 设置响应头参数；流式输出、UTF-8、禁用缓存</span></span><br><span class="line">            response.setContentType(<span class="string">&quot;text/event-stream&quot;</span>);</span><br><span class="line">            response.setCharacterEncoding(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">            response.setHeader(<span class="string">&quot;Cache-Control&quot;</span>, <span class="string">&quot;no-cache&quot;</span>);</span><br><span class="line">            <span class="comment">//简单校验token</span></span><br><span class="line">            <span class="keyword">if</span> (!token.equals(<span class="string">&quot;xxxx&quot;</span>)) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;token err!&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2. 异步处理 HTTP 响应处理类</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 创建ResponseBodyEmitter对象，设置超时时间</span></span><br><span class="line">            <span class="type">ResponseBodyEmitter</span> <span class="variable">emitter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ResponseBodyEmitter</span>(<span class="number">3</span> * <span class="number">60</span> * <span class="number">1000L</span>);  </span><br><span class="line">            <span class="comment">// 设置完成和错误事件的处理方法</span></span><br><span class="line">            emitter.onCompletion(() -&gt; &#123;</span><br><span class="line">                log.info(<span class="string">&quot;流式问答请求完成，使用模型：&#123;&#125;&quot;</span>, request.getModel());</span><br><span class="line">            &#125;);</span><br><span class="line">            emitter.onError(throwable -&gt; log.error(<span class="string">&quot;流式问答请求疫情，使用模型：&#123;&#125;&quot;</span>, request.getModel(), throwable));</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3.1 构建请求参数</span></span><br><span class="line">            List&lt;Message&gt; messages = request.getMessages().stream()  <span class="comment">//请求对象中的消息列表，并将其转换为Stream对象。</span></span><br><span class="line">                    .map(entity -&gt; Message.builder()  <span class="comment">//使用map方法将每个消息对象转换为一个Message.builder对象</span></span><br><span class="line">                            .role(Constants.Role.valueOf(entity.getRole().toUpperCase()))  </span><br><span class="line">                            .content(entity.getContent())</span><br><span class="line">                            .name(entity.getName())</span><br><span class="line">                            .build())  <span class="comment">//构建器创建新消息对象</span></span><br><span class="line">                    .collect(Collectors.toList());<span class="comment">// 将构建器创建的消息对象列表收集到一个新的列表中，并将新列表赋值给messages变量</span></span><br><span class="line">            <span class="comment">// 构建请求对象</span></span><br><span class="line">            <span class="type">ChatCompletionRequest</span> <span class="variable">chatCompletion</span> <span class="operator">=</span> ChatCompletionRequest</span><br><span class="line">                    .builder()</span><br><span class="line">                    .stream(<span class="literal">true</span>)</span><br><span class="line">                    .messages(messages)</span><br><span class="line">                    .model(ChatCompletionRequest.Model.GPT_3_5_TURBO.getCode())</span><br><span class="line">                    .build();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3.2 请求应答</span></span><br><span class="line">            openAiSession.chatCompletions(chatCompletion, <span class="keyword">new</span> <span class="title class_">EventSourceListener</span>() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onEvent</span><span class="params">(<span class="meta">@NotNull</span> EventSource eventSource, <span class="meta">@Nullable</span> String id, <span class="meta">@Nullable</span> String type, <span class="meta">@NotNull</span> String data)</span> &#123;</span><br><span class="line">                    <span class="type">ChatCompletionResponse</span> <span class="variable">chatCompletionResponse</span> <span class="operator">=</span> JSON.parseObject(data, ChatCompletionResponse.class);</span><br><span class="line">                    List&lt;ChatChoice&gt; choices = chatCompletionResponse.getChoices();</span><br><span class="line">                    <span class="keyword">for</span> (ChatChoice chatChoice : choices) &#123;</span><br><span class="line">                        <span class="type">Message</span> <span class="variable">delta</span> <span class="operator">=</span> chatChoice.getDelta();</span><br><span class="line">                        <span class="keyword">if</span> (Constants.Role.ASSISTANT.getCode().equals(delta.getRole())) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 应答完成</span></span><br><span class="line">                        <span class="type">String</span> <span class="variable">finishReason</span> <span class="operator">=</span> chatChoice.getFinishReason();</span><br><span class="line">                        <span class="keyword">if</span> (StringUtils.isNoneBlank(finishReason) &amp;&amp; <span class="string">&quot;stop&quot;</span>.equals(finishReason)) &#123;</span><br><span class="line">                            emitter.complete();</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 发送信息</span></span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            emitter.send(delta.getContent());  <span class="comment">//将内容添加到响应流中</span></span><br><span class="line">                        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="keyword">return</span> emitter;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;流式应答，请求模型：&#123;&#125; 发生异常&quot;</span>, request.getModel(), e);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ChatGPTException</span>(e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Hexo Butterfly博客添加Google分析</title>
      <link href="/2023/12/05/%E5%8D%9A%E5%AE%A2%E5%88%86%E6%9E%90/"/>
      <url>/2023/12/05/%E5%8D%9A%E5%AE%A2%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h2 id="Hexo-Butterfly博客添加Google分析"><a href="#Hexo-Butterfly博客添加Google分析" class="headerlink" title="Hexo Butterfly博客添加Google分析"></a>Hexo Butterfly博客添加Google分析</h2><p>进入谷歌分析官网:<a href="https://analytics.google.com/analytics/web/">https://analytics.google.com/analytics/web/</a><br>如下图所示:</p><p><img src="https://pb01.s3.bitiful.net/48.png" alt="avatar"></p><p>点击开始评估</p><p><img src="https://pb01.s3.bitiful.net/50.png" alt="avatar"></p><p>输入账户名,随便填就行,点击下一步</p><p><img src="https://pb01.s3.bitiful.net/51.png" alt="avatar"></p><p>输入属性名称(随便填),填上你的博客域名,点击下一步</p><p>剩下的步骤按自己的情况填就行</p><p>最后会弹出一个弹窗,上面会有一个跟踪id,一般以UA开头,将它复制下来,在_config.butterfly.yml文件中搜索google_analytics,在这个后面把你的跟踪id填进去,如下所示:</p><p><img src="https://pb01.s3.bitiful.net/52.png" alt="avatar"></p><p>如果你小心把谷歌分析的网址关了,应该怎么找跟踪id呢?</p><p>进入后台,点击管理:<br><img src="https://pb01.s3.bitiful.net/53.png" alt="avatar"></p><p>找到资源存取管理,点击:<br><img src="https://pb01.s3.bitiful.net/54.png" alt="avatar"></p><p>点开查看使用者的账户详细资料就能找到:</p><p><img src="https://pb01.s3.bitiful.net/56.png" alt="avatar"></p><p>下图我打红色码的就是跟踪id:</p><p><img src="https://pb01.s3.bitiful.net/55.png" alt="avatar"></p><p>更改好了以后,重新部署博客,最后看到这样的页面:</p><p><img src="https://pb01.s3.bitiful.net/49.png" alt="avatar"></p><p>就大功告成啦!</p>]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> blog </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Retrofit2简明讲解</title>
      <link href="/2023/12/05/2023-12-5-Retrofit2/"/>
      <url>/2023/12/05/2023-12-5-Retrofit2/</url>
      
        <content type="html"><![CDATA[<h3 id="Retrofit2简明讲解"><a href="#Retrofit2简明讲解" class="headerlink" title="Retrofit2简明讲解"></a>Retrofit2简明讲解</h3><h4 id="什么是Retrofit"><a href="#什么是Retrofit" class="headerlink" title="什么是Retrofit"></a>什么是Retrofit</h4><p>retrofit是现在比较流行的网络请求框架，可以理解为okhttp的加强版，底层封装了okhttp。准确来说，Retrofit是一个RESTful的http网络请求框架的封装。因为网络请求工作本质上是由okhttp来完成，而Retrofit负责网络请求接口的封装。</p><p><img src="https://pb01.s3.bitiful.net/45.png" alt="avatar"></p><p><strong>本质过程</strong>：App应用程序通过Retrofit请求网络，实质上是使用Retrofit接口层封装请求参数,即Header、Url等信息，之后由okhttp来完成后续的请求工作。在服务端返回数据后，okhttp将原始数据交给Retrofit，Retrofit根据用户需求解析。</p><p><img src="https://pb01.s3.bitiful.net/46.png" alt="avatar"></p><h4 id="使用介绍"><a href="#使用介绍" class="headerlink" title="使用介绍"></a>使用介绍</h4><p>使用 Retrofit 的步骤共有7个：</p><p><strong>步骤1</strong>：添加Retrofit库的依赖<br><strong>步骤2</strong>：创建 接收服务器返回数据 的类<br><strong>步骤3</strong>：创建 用于描述网络请求 的接口<br><strong>步骤4</strong>：创建Retrofit实例 并 创建网络请求接口实例<br><strong>步骤5</strong>：发送网络请求（异步 / 同步）</p><h5 id="步骤1：添加Retrofit库的依赖"><a href="#步骤1：添加Retrofit库的依赖" class="headerlink" title="步骤1：添加Retrofit库的依赖"></a>步骤1：添加Retrofit库的依赖</h5><p>如图所示:</p><p><img src="https://pb01.s3.bitiful.net/47.png" alt="avatar"></p><h5 id="步骤2：创建-接收服务器返回数据-的类"><a href="#步骤2：创建-接收服务器返回数据-的类" class="headerlink" title="步骤2：创建 接收服务器返回数据 的类"></a>步骤2：创建 接收服务器返回数据 的类</h5><p>在正式的请求网络数据中，返回的数据的外嵌套部分都是一样的，携带状态码、状态信息、实体数据一起返回，我们可以将它封装一个统一的数据回调类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ChatCompletionResponse</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** ID */</span></span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line">    <span class="comment">/** 对象 */</span></span><br><span class="line">    <span class="keyword">private</span> String object;</span><br><span class="line">    <span class="comment">/** 模型 */</span></span><br><span class="line">    <span class="keyword">private</span> String model;</span><br><span class="line">    <span class="comment">/** 对话 */</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;ChatChoice&gt; choices;</span><br><span class="line">    <span class="comment">/** 创建 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> created;</span><br><span class="line">    <span class="comment">/** 耗材 */</span></span><br><span class="line">    <span class="keyword">private</span> Usage usage;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="步骤3：创建-用于描述网络请求-的接口"><a href="#步骤3：创建-用于描述网络请求-的接口" class="headerlink" title="步骤3：创建 用于描述网络请求 的接口"></a>步骤3：创建 用于描述网络请求 的接口</h5><p>这个类就是Retrofit将okhttp请求抽象成java的接口类，用注解描述和配置网络请求参数，封装Url地址和网络数据请求</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IOpenAiApi</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 默认 GPT-3.5 问答模型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> chatCompletionRequest 请求信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>                      返回结果</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@POST(&quot;v1/chat/completions&quot;)</span></span><br><span class="line">    Single&lt;ChatCompletionResponse&gt; <span class="title function_">completions</span><span class="params">(<span class="meta">@Body</span> ChatCompletionRequest chatCompletionRequest)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在方法头部添加@POST注解，表示采用post方法访问网络请求，括号内的是请求的地址(Url的一部分) ，其中返回类型是Single&lt;<em>&gt;，</em>表示接收数据的类，ChatCompletionResponse是上面封装的一个接收数据的统一公共类</p><h5 id="步骤4：创建Retrofit实例-并-创建网络请求接口实例"><a href="#步骤4：创建Retrofit实例-并-创建网络请求接口实例" class="headerlink" title="步骤4：创建Retrofit实例 并 创建网络请求接口实例"></a>步骤4：创建Retrofit实例 并 创建网络请求接口实例</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> <span class="type">IOpenAiApi</span> <span class="variable">openAiApi</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Retrofit</span>.Builder()</span><br><span class="line">                .baseUrl(configuration.getApiHost())<span class="comment">//得到url</span></span><br><span class="line">                .client(okHttpClient)<span class="comment">//设置客户端</span></span><br><span class="line"><span class="comment">//        RxJava2CallAdapterFactory的主要作用是：</span></span><br><span class="line"><span class="comment">//        1.将Android的Call对象转换为RxJava的Observable类型。</span></span><br><span class="line"><span class="comment">//        2.处理Call的错误和结果，并将其转换为RxJava的onError和onNext事件。</span></span><br><span class="line"><span class="comment">//        3.添加适当的错误处理逻辑，例如重试、网络错误等。</span></span><br><span class="line">                .addCallAdapterFactory(RxJava2CallAdapterFactory.create())</span><br><span class="line">                .addConverterFactory(JacksonConverterFactory.create())<span class="comment">//在请求和响应中使用jackson库进行json转换</span></span><br><span class="line">                .build().create(IOpenAiApi.class);</span><br></pre></td></tr></table></figure><h5 id="步骤5：发送网络请求（异步-同步）"><a href="#步骤5：发送网络请求（异步-同步）" class="headerlink" title="步骤5：发送网络请求（异步 / 同步）"></a>步骤5：发送网络请求（异步 / 同步）</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DefaultOpenAiSession</span> <span class="keyword">implements</span> <span class="title class_">OpenAiSession</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> IOpenAiApi openAiApi;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DefaultOpenAiSession</span><span class="params">(IOpenAiApi openAiApi)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.openAiApi = openAiApi;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> ChatCompletionResponse <span class="title function_">completions</span><span class="params">(ChatCompletionRequest chatCompletionRequest)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.openAiApi.completions(chatCompletionRequest).blockingGet();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="References"><a href="#References" class="headerlink" title="References"></a>References</h4><ol><li><p><a href="https://www.jianshu.com/p/a3e162261ab6" style="color: #177cb0; text-decoration: underline;text-decoration-style: dotted;">Carson带你学Android：网络请求库Retrofit使用教程(含实例讲解)</a></p></li><li><p><a href="https://juejin.cn/post/6978777076073660429" style="color: #177cb0; text-decoration: underline;text-decoration-style: dotted;">Retrofit2 实战（一、使用详解篇）</a></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>DDD架构之端口</title>
      <link href="/2023/12/04/2023-12-4-DDD%E6%9E%B6%E6%9E%84-4/"/>
      <url>/2023/12/04/2023-12-4-DDD%E6%9E%B6%E6%9E%84-4/</url>
      
        <content type="html"><![CDATA[<h3 id="DDD架构之端口"><a href="#DDD架构之端口" class="headerlink" title="DDD架构之端口"></a>DDD架构之端口</h3><p>在领域驱动设计（DDD）的上下文中，适配器（Adapter）模式扮演着至关重要的角色。适配器模式允许将不兼容的接口转换为另一个预期的接口，从而使原本由于接口不兼容而不能一起工作的类可以协同工作。在DDD中，适配器通常与端口（Port）概念结合使用，形成”端口和适配器”（Ports and Adapters）架构，也称为”六边形架构”（Hexagonal Architecture）。这种架构风格旨在将应用程序的核心逻辑与外部世界的交互解耦。</p><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>Port 在这种架构中代表了应用程序的一个入口或出口点。它定义了一个与外部世界交互的接口，但不关心具体的实现细节。端口可以是驱动端口（Driving Ports，通常是输入端口）或被驱动端口（Driven Ports，通常是输出端口）。</p><h4 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h4><ul><li><strong>抽象性</strong>：端口提供了服务行为的抽象描述，明确了服务的功能和外部依赖。</li><li><strong>独立性</strong>：端口独立于具体实现，允许服务实现的灵活替换或扩展。</li><li><strong>灵活性</strong>：可以为同一端口提供不同的适配器实现，以适应不同的运行环境或需求。</li></ul><h4 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h4><ul><li><strong>标准定义</strong>：端口和适配器定义了服务的标准行为和外部依赖，提高了代码的可读性和可维护性。</li><li><strong>隔离变化</strong>：当外部系统变化时，只需更换或修改适配器，无需改动核心业务逻辑。</li><li><strong>促进测试</strong>：可以使用模拟适配器来测试核心逻辑，而不依赖真实的外部系统。</li></ul><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><p>实现端口和适配器架构通常涉及以下步骤：</p><ol><li><strong>定义端口</strong>：在领域层定义清晰的接口，这些接口代表了应用程序与外部世界的交互点。</li><li><strong>创建适配器</strong>：在基础层或应用层实现适配器，这些适配器负责将端口的抽象操作转换为具体的外部调用。</li><li><strong>依赖倒置</strong>：应用程序的核心逻辑依赖于端口接口，而不是适配器的具体实现。这样，适配器可以随时被替换，而不影响核心逻辑。</li><li><strong>配置和组装</strong>：在应用程序启动时，根据需要将适配器与相应的端口连接起来。</li></ol><p>通过这种方式，DDD中的适配器模式有助于构建一个灵活、可维护且易于测试的系统。</p><h4 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h4><p>以下是一个简单的Java示例，展示了如何在DDD架构中实现适配器模式。在这个例子中，我们将创建一个简单的支付系统，其中包含一个支付端口和一个适配器，该适配器负责调用外部支付服务的接口。</p><p>首先，我们定义一个支付端口（Port），它是一个接口，描述了支付服务应该提供的操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">PaymentPort</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">processPayment</span><span class="params">(<span class="type">double</span> amount)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来，我们创建一个适配器，它实现了支付端口，并负责调用外部支付服务的接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExternalPaymentService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">makePayment</span><span class="params">(<span class="type">double</span> amount)</span> &#123;</span><br><span class="line">        <span class="comment">// 这里是外部支付服务的具体调用逻辑</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Calling external payment service for amount: &quot;</span> + amount);</span><br><span class="line">        <span class="comment">// 假设支付总是成功</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PaymentAdapter</span> <span class="keyword">implements</span> <span class="title class_">PaymentPort</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> ExternalPaymentService externalPaymentService;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">PaymentAdapter</span><span class="params">(ExternalPaymentService externalPaymentService)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.externalPaymentService = externalPaymentService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">processPayment</span><span class="params">(<span class="type">double</span> amount)</span> &#123;</span><br><span class="line">        <span class="comment">// 调用外部支付服务的接口</span></span><br><span class="line">        <span class="keyword">return</span> externalPaymentService.makePayment(amount);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，我们可以在应用程序的核心逻辑中使用支付端口，而不依赖于适配器的具体实现。这样，如果将来需要更换外部支付服务，我们只需提供一个新的适配器实现即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PaymentService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> PaymentPort paymentPort;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">PaymentService</span><span class="params">(PaymentPort paymentPort)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.paymentPort = paymentPort;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">processUserPayment</span><span class="params">(<span class="type">double</span> amount)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (paymentPort.processPayment(amount)) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Payment processed successfully.&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Payment failed.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，我们在应用程序的启动或配置阶段组装这些组件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Application</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建外部支付服务的实例</span></span><br><span class="line">        <span class="type">ExternalPaymentService</span> <span class="variable">externalPaymentService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ExternalPaymentService</span>();</span><br><span class="line">        <span class="comment">// 创建适配器的实例，注入外部支付服务</span></span><br><span class="line">        <span class="type">PaymentAdapter</span> <span class="variable">paymentAdapter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PaymentAdapter</span>(externalPaymentService);</span><br><span class="line">        <span class="comment">// 创建支付服务的实例，注入适配器</span></span><br><span class="line">        <span class="type">PaymentService</span> <span class="variable">paymentService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PaymentService</span>(paymentAdapter);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 处理用户支付</span></span><br><span class="line">        paymentService.processUserPayment(<span class="number">100.0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，PaymentAdapter 负责调用外部的支付接口 ExternalPaymentService.makePayment。PaymentService 使用 PaymentPort 接口与外部世界交互，这样就实现了领域逻辑与外部服务之间的解耦。如果需要更换支付服务提供商，我们只需要实现一个新的 PaymentAdapter，而不需要修改 PaymentService 的代码。</p><h3 id="References"><a href="#References" class="headerlink" title="References"></a>References</h3><p><a href="https://bugstack.cn/" style="color: #177cb0; text-decoration: underline;text-decoration-style: dotted;">小傅哥 bugstack 虫洞栈</a></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DDD </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OpenAI SDK开发(2)</title>
      <link href="/2023/12/04/2023-12-4-OpenAI-SDK%E5%BC%80%E5%8F%91-2/"/>
      <url>/2023/12/04/2023-12-4-OpenAI-SDK%E5%BC%80%E5%8F%91-2/</url>
      
        <content type="html"><![CDATA[<h2 id="OpenAI-SDK开发-2-okhttp3的sse流式应答设计"><a href="#OpenAI-SDK开发-2-okhttp3的sse流式应答设计" class="headerlink" title="OpenAI SDK开发(2) okhttp3的sse流式应答设计"></a>OpenAI SDK开发(2) okhttp3的sse流式应答设计</h2><p>本次开发完成了流式应答,主要使用的就是okhttp3的eventsource</p><h4 id="流程验证"><a href="#流程验证" class="headerlink" title="流程验证"></a>流程验证</h4><p>跟之前的主要区别就是需要使用eventsource来监听流式应答,要将ChatCompletionRequest中的stream参数设置为true,以okHttpClient开启EventSource Factory,以全新的request格式传递数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test_client_stream</span><span class="params">()</span> <span class="keyword">throws</span> JsonProcessingException, InterruptedException &#123;</span><br><span class="line">        <span class="type">HttpLoggingInterceptor</span> <span class="variable">httpLoggingInterceptor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HttpLoggingInterceptor</span>();</span><br><span class="line">        httpLoggingInterceptor.setLevel(HttpLoggingInterceptor.Level.BODY);</span><br><span class="line"></span><br><span class="line">        <span class="type">OkHttpClient</span> <span class="variable">okHttpClient</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OkHttpClient</span></span><br><span class="line">                .Builder()</span><br><span class="line">                .addInterceptor(httpLoggingInterceptor)</span><br><span class="line">                .addInterceptor(chain -&gt; &#123;</span><br><span class="line">                    <span class="type">Request</span> <span class="variable">original</span> <span class="operator">=</span> chain.request();</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 从请求中获取 token 参数，并将其添加到请求路径中</span></span><br><span class="line">                    <span class="type">HttpUrl</span> <span class="variable">url</span> <span class="operator">=</span> original.url().newBuilder()</span><br><span class="line">                            .addQueryParameter(<span class="string">&quot;token&quot;</span>, <span class="string">&quot;xxx&quot;</span>)</span><br><span class="line">                            .build();</span><br><span class="line"></span><br><span class="line">                    <span class="type">Request</span> <span class="variable">request</span> <span class="operator">=</span> original.newBuilder()</span><br><span class="line">                            .url(url)</span><br><span class="line">                            .header(Header.AUTHORIZATION.getValue(), <span class="string">&quot;Bearer &quot;</span> + <span class="string">&quot;xxx&quot;</span>)</span><br><span class="line">                            .header(Header.CONTENT_TYPE.getValue(), ContentType.JSON.getValue())</span><br><span class="line">                            .method(original.method(), original.body())</span><br><span class="line">                            .build();</span><br><span class="line">                    <span class="keyword">return</span> chain.proceed(request);</span><br><span class="line">                &#125;)</span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">        <span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> Message.builder().role(Constants.Role.USER).content(<span class="string">&quot;写一个java冒泡排序&quot;</span>).build();</span><br><span class="line">        <span class="type">ChatCompletionRequest</span> <span class="variable">chatCompletion</span> <span class="operator">=</span> ChatCompletionRequest</span><br><span class="line">                .builder()</span><br><span class="line">                .messages(Collections.singletonList(message))</span><br><span class="line">                .model(ChatCompletionRequest.Model.GPT_3_5_TURBO.getCode())</span><br><span class="line">                .stream(<span class="literal">true</span>)</span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">        EventSource.<span class="type">Factory</span> <span class="variable">factory</span> <span class="operator">=</span> EventSources.createFactory(okHttpClient);</span><br><span class="line">        <span class="type">String</span> <span class="variable">requestBody</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>().writeValueAsString(chatCompletion);<span class="comment">//将chatCompletion转为json格式</span></span><br><span class="line"></span><br><span class="line">        <span class="type">Request</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Request</span>.Builder()</span><br><span class="line">                .url(<span class="string">&quot;xxx&quot;</span>)</span><br><span class="line">                .post(RequestBody.create(MediaType.parse(ContentType.JSON.getValue()), requestBody))</span><br><span class="line">                <span class="comment">//MediaType.parse用来声明浏览器将以什么形式、什么编码对requestBody进行解析</span></span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">        <span class="type">EventSource</span> <span class="variable">eventSource</span> <span class="operator">=</span> factory.newEventSource(request, <span class="keyword">new</span> <span class="title class_">EventSourceListener</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onEvent</span><span class="params">(EventSource eventSource, String id, String type, String data)</span> &#123;</span><br><span class="line">                log.info(<span class="string">&quot;测试结果：&#123;&#125;&quot;</span>, data);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 等待</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">1</span>).await();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="添加方法"><a href="#添加方法" class="headerlink" title="添加方法"></a>添加方法</h4><p>在OpenAiSession接口中添加如下方法,在传入参数为ChatCompletionRequest和EventSourceListener时采用流式应答</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 问答模型 GPT-3.5/4.0 &amp; 流式反馈</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> chatCompletionRequest 请求信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> eventSourceListener   实现监听；通过监听的 onEvent 方法接收数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>                      返回结果</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    EventSource <span class="title function_">chatCompletions</span><span class="params">(ChatCompletionRequest chatCompletionRequest, EventSourceListener eventSourceListener)</span> <span class="keyword">throws</span> JsonProcessingException;</span><br></pre></td></tr></table></figure><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><p>添加DefaultOpenAiSession类中的chatCompletions方法,实现流式应答</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> EventSource <span class="title function_">chatCompletions</span><span class="params">(ChatCompletionRequest chatCompletionRequest, EventSourceListener eventSourceListener)</span> <span class="keyword">throws</span> JsonProcessingException &#123;</span><br><span class="line">    <span class="comment">// 核心参数校验；不对用户的传参做更改，只返回错误信息。</span></span><br><span class="line">    <span class="keyword">if</span> (!chatCompletionRequest.isStream()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;illegal parameter stream is false!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构建请求信息</span></span><br><span class="line">    <span class="type">Request</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Request</span>.Builder()</span><br><span class="line">            <span class="comment">// url: https://api.openai.com/v1/chat/completions - 通过 IOpenAiApi 配置的 POST 接口，用这样的方式从统一的地方获取配置信息</span></span><br><span class="line">            .url(configuration.getApiHost().concat(IOpenAiApi.v1_chat_completions))</span><br><span class="line">            <span class="comment">// 封装请求参数信息，如果使用了 Fastjson 也可以替换 ObjectMapper 转换对象</span></span><br><span class="line">            .post(RequestBody.create(MediaType.parse(ContentType.JSON.getValue()), <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>().writeValueAsString(chatCompletionRequest)))</span><br><span class="line">            .build();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回结果信息；EventSource 对象可以取消应答</span></span><br><span class="line">    <span class="keyword">return</span> factory.newEventSource(request, eventSourceListener);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>DDD架构之仓储</title>
      <link href="/2023/12/03/2023-12-3-DDD%E6%9E%B6%E6%9E%84-3/"/>
      <url>/2023/12/03/2023-12-3-DDD%E6%9E%B6%E6%9E%84-3/</url>
      
        <content type="html"><![CDATA[<h3 id="DDD架构之仓储"><a href="#DDD架构之仓储" class="headerlink" title="DDD架构之仓储"></a>DDD架构之仓储</h3><p>Repository（仓储）模式是一种设计模式，它用于将数据访问逻辑封装起来，使得领域层可以通过一个简单、一致的接口来访问聚合根或实体对象。这个模式的关键在于提供了一个抽象的接口，领域层通过这个接口与数据存储层进行交互，而不需要知道背后具体的实现细节。</p><h4 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h4><ul><li><strong>封装持久化操作</strong>：Repository负责封装所有与数据源交互的操作，如创建、读取、更新和删除（CRUD）操作。这样，领域层的代码就可以避免直接处理数据库或其他存储机制的复杂性。</li><li><strong>领域对象的集合管理</strong>：Repository通常被视为领域对象的集合，提供了查询和过滤这些对象的方法，使得领域对象的获取和管理更加方便。<br>抽象接口：Repository定义了一个与持久化机制无关的接口，这使得领域层的代码可以在不同的持久化机制之间切换，而不需要修改业务逻辑。</li></ul><h4 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h4><ol><li><strong>数据访问抽象</strong>：Repository为领域层提供了一个清晰的数据访问接口，使得领域对象可以专注于业务逻辑的实现，而不是数据访问的细节。</li><li><strong>领域对象的查询和管理</strong>：Repository使得对领域对象的查询和管理变得更加方便和灵活，支持复杂的查询逻辑。</li><li><strong>领域逻辑与数据存储分离</strong>：通过Repository模式，领域逻辑与数据存储逻辑分离，提高了领域模型的纯粹性和可测试性。</li><li><strong>优化数据访问</strong>：Repository实现可以包含数据访问的优化策略，如缓存、批处理操作等，以提高应用程序的性能。</li></ol><h4 id="实现手段"><a href="#实现手段" class="headerlink" title="实现手段"></a>实现手段</h4><p>在实践中，Repository模式通常通过以下方式实现：</p><ol><li><strong>定义Repository接口</strong>：在领域层定义一个或多个Repository接口，这些接口声明了所需的数据访问方法。</li><li><strong>实现Repository接口</strong>：在基础设施层或数据访问层实现这些接口，具体实现可能是使用ORM（对象关系映射）框架，如MyBatis、Hibernate等，或者直接使用数据库访问API，如JDBC等。</li><li><strong>依赖注入</strong>：在应用程序中使用依赖注入（DI）来将具体的Repository实现注入到需要它们的领域服务或应用服务中。这样做可以进一步解耦领域层和数据访问层，同时也便于单元测试。</li><li><strong>使用规范模式（Specification Pattern）</strong>：有时候，为了构建复杂的查询，可以结合使用规范模式，这是一种允许将业务规则封装为单独的业务逻辑单元的模式，这些单元可以被Repository用来构建查询。</li></ol><p>总之，Repository模式是DDD（领域驱动设计）中的一个核心概念，它有助于保持领域模型的聚焦和清晰，同时提供了灵活、可测试和可维护的数据访问策略。</p><h4 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h4><p>以下是一个简单的Java代码示例，展示了如何在DDD架构中实现Repository模式。在这个例子中，我们将创建一个简单的用户管理系统，其中包含用户实体和用户仓储接口，以及一个基于内存的仓储实现。</p><p>首先，我们定义一个用户实体：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造函数、getter和setter省略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>接下来，我们定义用户仓储的接口：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserRepository</span> &#123;</span><br><span class="line">    User <span class="title function_">findById</span><span class="params">(Long id)</span>;</span><br><span class="line">    List&lt;User&gt; <span class="title function_">findAll</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">save</span><span class="params">(User user)</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">(User user)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>然后，我们提供一个基于内存的仓储实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InMemoryUserRepository</span> <span class="keyword">implements</span> <span class="title class_">UserRepository</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;Long, User&gt; database = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">AtomicLong</span> <span class="variable">idGenerator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicLong</span>();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">findById</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> database.get(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;User&gt; <span class="title function_">findAll</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(database.values());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">(User user)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (user.getId() == <span class="literal">null</span>) &#123;</span><br><span class="line">            user.setId(idGenerator.incrementAndGet());</span><br><span class="line">        &#125;</span><br><span class="line">        database.put(user.getId(), user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">(User user)</span> &#123;</span><br><span class="line">        database.remove(user.getId());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，我们可以在应用服务中使用这个仓储：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> UserRepository userRepository;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UserService</span><span class="params">(UserRepository userRepository)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.userRepository = userRepository;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">getUserById</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> userRepository.findById(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createUser</span><span class="params">(String username, String email)</span> &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">newUser</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        newUser.setUsername(username);</span><br><span class="line">        newUser.setEmail(email);</span><br><span class="line">        userRepository.save(newUser);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 其他业务逻辑方法...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p><p>在实际应用中，我们通常会使用依赖注入框架（如Spring）来自动注入仓储的实现。这里为了简单起见，我们可以手动创建服务和仓储的实例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Application</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">UserRepository</span> <span class="variable">userRepository</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InMemoryUserRepository</span>();</span><br><span class="line">        <span class="type">UserService</span> <span class="variable">userService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserService</span>(userRepository);</span><br><span class="line"></span><br><span class="line">        userService.createUser(<span class="string">&quot;XiaoFuGe&quot;</span>, <span class="string">&quot;xiaofuge@qq.com&quot;</span>);</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userService.getUserById(<span class="number">1L</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;User found: &quot;</span> + user.getUsername());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这个例子展示了Repository模式的基本结构和用法。在实际项目中，仓储的实现可能会连接到数据库，并使用ORM框架来处理数据持久化的细节。此外，仓储接口可能会包含更复杂的查询方法，以支持各种业务需求。</p><h3 id="References"><a href="#References" class="headerlink" title="References"></a>References</h3><p><a href="https://bugstack.cn/" style="color: #177cb0; text-decoration: underline;text-decoration-style: dotted;">小傅哥 bugstack 虫洞栈</a></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DDD </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DDD架构之领域,聚合,实体,值对象</title>
      <link href="/2023/12/03/2023-12-3-DDD%E6%9E%B6%E6%9E%84-2/"/>
      <url>/2023/12/03/2023-12-3-DDD%E6%9E%B6%E6%9E%84-2/</url>
      
        <content type="html"><![CDATA[<h2 id="DDD架构之领域-聚合-实体-值对象"><a href="#DDD架构之领域-聚合-实体-值对象" class="headerlink" title="DDD架构之领域,聚合,实体,值对象"></a>DDD架构之领域,聚合,实体,值对象</h2><h3 id="Domain（领域）"><a href="#Domain（领域）" class="headerlink" title="Domain（领域）"></a>Domain（领域）</h3><p>在DDD中，领域是指具体业务领域的知识、业务逻辑、数据以及业务规则的集合。它是软件要解决问题的业务环境，通常由一系列子领域组成，每个子领域代表业务中的一个特定部分。</p><h4 id="领域的特性"><a href="#领域的特性" class="headerlink" title="领域的特性"></a>领域的特性</h4><ol><li><strong>业务中心</strong>：领域是围绕业务需求和业务规则构建的，它是软件设计的核心。</li><li><strong>模型驱动</strong>：领域模型是对业务知识的抽象，它通过领域实体、值对象、服务、聚合等概念来表达。</li><li><strong>语言一致性</strong>：领域模型的构建基于统一语言（Ubiquitous Language），这是开发团队与业务专家共同使用的语言，确保沟通无歧义。</li><li><strong>边界清晰</strong>：领域模型定义了清晰的边界，这些边界划分了不同的子领域和聚合，有助于管理复杂性和维护性。</li></ol><h4 id="领域的用途"><a href="#领域的用途" class="headerlink" title="领域的用途"></a>领域的用途</h4><p>业务逻辑的封装：领域模型封装了业务逻辑，使得业务规则和数据操作集中管理，便于理解和维护。<br>沟通工具：领域模型作为开发团队与业务专家之间的共同语言，有助于提高沟通效率，确保软件开发紧密跟随业务需求。<br>软件设计的基础：领域模型是软件设计的基础，它指导着软件的架构和实现。</p><h4 id="实现手段"><a href="#实现手段" class="headerlink" title="实现手段"></a>实现手段</h4><ol><li><strong>实体（Entity）</strong>：具有唯一标识的领域对象，代表业务中的实体。</li><li><strong>值对象（Value Object）</strong>：描述领域中的一些特性或概念，没有唯一标识，通常是不可变的。</li><li><strong>聚合（Aggregate）</strong>：一组相关的实体和值对象的集合，它们一起构成一个数据和业务规则的单元。</li><li><strong>领域服务（Domain Service）</strong>：在领域模型中执行特定业务逻辑的无状态服务，通常操作多个实体或聚合。</li><li><strong>领域事件（Domain Event）</strong>：表示领域中发生的重要业务事件，用于解耦系统的不同部分。</li><li><strong>仓储（Repository）</strong>：提供对聚合根的持久化操作，如保存和检索，通常与数据库交互。</li><li><strong>领域适配器（Domain Adapter）</strong>：领域适配器是适配器模式在DDD中的应用，它的目的是使得领域模型能够与外部系统或技术细节进行交互，而不会受到污染。</li><li><strong>工厂（Factory）</strong>：用于创建复杂的聚合或实体，封装创建逻辑。如 OpenAi项目、Lottery 项目都运用了工厂，也包括如 chatglm-sdk-java 的开发，就是会话模型结构用工厂对外提供服务。</li></ol><p>通过这些实现手段，DDD使得软件设计更加贴近业务需求，提高了软件的质量和可维护性。开发团队可以更好地理解业务逻辑，从而设计出更加健壮和灵活的系统。</p><h3 id="聚合对象"><a href="#聚合对象" class="headerlink" title="聚合对象"></a>聚合对象</h3><p>聚合是一组相关对象的集合，它们一起形成一个单一的单元。</p><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>聚合是领域模型中的一个关键概念，它是一组具有内聚性的相关对象的集合，这些对象一起工作以执行某些业务规则或操作。聚合定义了一组对象的边界，这些对象可以被视为一个单一的单元进行处理。</p><p><strong>关键</strong>：聚合内实现事务一致性、聚合外实现最终一致性。</p><h4 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h4><ol><li><strong>一致性边界</strong>：聚合确保其内部对象的状态变化是一致的。当对聚合内的对象进行操作时，这些操作必须保持聚合内所有对象的一致性。</li><li><strong>根实体</strong>：每个聚合都有一个根实体（Aggregate Root），它是聚合的入口点。根实体拥有一个全局唯一的标识符，其他对象通过根实体与聚合交互。</li><li><strong>事务边界</strong>：聚合也定义了事务的边界。在聚合内部，所有的变更操作应该是原子的，即它们要么全部成功，要么全部失败，以此来保证数据的一致性。</li></ol><h4 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h4><ol><li><strong>封装业务逻辑</strong>：聚合通过将相关的对象和操作封装在一起，提供了一个清晰的业务逻辑模型，有助于业务规则的实施和维护。</li><li><strong>保证一致性</strong>：聚合确保内部状态的一致性，通过定义清晰的边界和规则，聚合可以在内部强制执行业务规则，从而保证数据的一致性。</li><li><strong>简化复杂性</strong>：聚合通过组织相关的对象，简化了领域模型的复杂性。这有助于开发者更好地理解和扩展系统。</li></ol><h4 id="实现手段-1"><a href="#实现手段-1" class="headerlink" title="实现手段"></a>实现手段</h4><ol><li><strong>定义聚合根</strong>：选择合适的聚合根是实现聚合的第一步。聚合根应该是能够代表整个聚合的实体，并且拥有唯一标识。</li><li><strong>限制访问路径</strong>：只能通过聚合根来修改聚合内的对象，不允许直接修改聚合内部对象的状态，以此来维护边界和一致性。</li><li><strong>设计事务策略</strong>：在聚合内部实现事务一致性，确保操作要么全部完成，要么全部回滚。对于聚合之间的交互，可以采用领域事件或其他机制来实现最终一致性。</li><li><strong>封装业务规则</strong>：在聚合内部实现业务规则和逻辑，确保所有的业务操作都遵循这些规则。<br>持久化：聚合根通常与数据持久化层交互，以保存聚合的状态。这通常涉及到对象-关系映射（ORM）或其他数据映射技术。</li></ol><p>通过这些实现手段，DDD中的聚合模型能够帮助开发者构建出既符合业务需求又具有良好架构设计的软件系统。</p><h3 id="实体"><a href="#实体" class="headerlink" title="实体"></a>实体</h3><p>实体（Entity）在领域驱动设计（Domain-Driven Design, DDD）中是一个核心概念，用于表示具有唯一标识的领域对象。以下是实体的详细介绍：</p><h4 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h4><p>实体 = 唯一标识 + 状态属性 + 行为动作（功能），是DDD中的一个基本构建块，它代表了具有唯一标识的领域对象。实体不仅仅包含数据（状态属性），还包含了相关的行为（功能），并且它的标识在整个生命周期中保持不变。</p><h4 id="特性-1"><a href="#特性-1" class="headerlink" title="特性"></a>特性</h4><ol><li><strong>唯一标识</strong>：实体具有一个可以区分其他实体的标识符。这个标识符可以是一个ID、一个复合键或者是一个自然键，关键是它能够唯一地标识实体实例。</li><li><strong>领域标识</strong>：实体的标识通常来源于业务领域，例如用户ID、订单ID等。这些标识符在业务上有特定的含义，并且在系统中是唯一的。</li><li><strong>委派标识</strong>：在某些情况下，实体的标识可能是由ORM（对象关系映射）框架自动生成的，如数据库中的自增主键。这种标识符虽然可以唯一标识实体，但它并不直接来源于业务领域。</li></ol><h4 id="用途-1"><a href="#用途-1" class="headerlink" title="用途"></a>用途</h4><ol><li><strong>表达业务概念</strong>：实体用于在软件中表达具体的业务概念，如用户、订单、交易等。通过实体的属性和行为，可以描述这些业务对象的特征和能力。</li><li><strong>封装业务逻辑</strong>：实体不仅仅承载数据，还封装了业务规则和逻辑。这些逻辑包括验证数据的有效性、执行业务规则、计算属性值等。这样做的目的是保证业务逻辑的集中和一致性。</li><li><strong>保持数据一致性</strong>：实体负责维护自身的状态和数据一致性。它确保自己的属性和关联关系在任何时候都是正确和完整的，从而避免数据的不一致性。</li></ol><h4 id="实现手段-2"><a href="#实现手段-2" class="headerlink" title="实现手段"></a>实现手段</h4><p>在实现实体时，通常会采用以下手段：</p><ol><li><strong>定义实体类</strong>：在代码中定义一个类，该类包含实体的属性、构造函数、方法等。</li><li><strong>实现唯一标识</strong>：为实体类提供一个唯一标识的属性，如ID，并确保在实体的生命周期中这个标识保持不变。</li><li><strong>封装行为</strong>：在实体类中实现业务逻辑的方法，这些方法可以操作实体的状态，并执行相关的业务规则。</li><li><strong>使用ORM框架</strong>：利用ORM框架将实体映射到数据库表中，这样可以简化数据持久化的操作。</li><li><strong>实现领域服务</strong>：对于跨实体或跨聚合的操作，可以实现领域服务来处理这些操作，而不是在实体中直接实现。</li><li><strong>使用领域事件</strong>：当实体的状态发生变化时，可以发布领域事件，这样可以通知其他部分的系统进行相应的处理。</li></ol><p>通过上述手段，实体在DDD架构中扮演着重要的角色，它不仅代表了业务概念，还封装了业务逻辑，并通过其唯一标识确保了数据的一致性。</p><h3 id="值对象"><a href="#值对象" class="headerlink" title="值对象"></a>值对象</h3><p>在领域驱动设计（Domain-Driven Design, DDD）中，值对象（Value Object）是一个核心概念，用于封装和表示领域中的概念，其特点是它们描述了领域中的某些属性或度量，但不具有唯一标识。</p><p>值对象 = 值 + 对象，用于描述对象属性的值，表示具体固定不变的属性值信息。</p><h4 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h4><p>值对象是由一组属性组成的，它们共同描述了一个领域概念。与实体（Entity）不同，值对象不需要有一个唯一的标识符来区分它们。值对象通常是不可变的，这意味着一旦创建，它们的状态就不应该改变。</p><h4 id="特性-2"><a href="#特性-2" class="headerlink" title="特性"></a>特性</h4><ol><li><strong>不可变性（Immutability）</strong>：值对象一旦被创建，它的状态就不应该发生变化。这有助于保证领域模型的一致性和线程安全性。</li><li><strong>等价性（Equality）</strong>：值对象的等价性不是基于身份或引用，而是基于对象的属性值。如果两个值对象的所有属性值都相等，那么这两个对象就被认为是等价的。</li><li><strong>替换性（Replaceability）</strong>：由于值对象是不可变的，任何需要改变值对象的操作都会导致创建一个新的值对象实例，而不是修改现有的实例。</li><li><strong>侧重于描述事物的状态</strong>：值对象通常用来描述事物的状态，而不是事物的唯一身份。</li><li><strong>可复用性（Reusability）</strong>：值对象可以在不同的领域实体或其他值对象中重复使用。</li></ol><h4 id="用途-2"><a href="#用途-2" class="headerlink" title="用途"></a>用途</h4><p>值对象的用途非常广泛，它们可以用来表示：</p><p>金额和货币（如价格、工资、费用等）<br>度量和数据（如重量、长度、体积等）<br>范围或区间（如日期范围、温度区间等）<br>复杂的数学模型（如坐标、向量等）<br>任何其他需要封装的属性集合</p><h4 id="实现手段-3"><a href="#实现手段-3" class="headerlink" title="实现手段"></a>实现手段</h4><p>在实现值对象时，通常会遵循以下几个步骤：</p><p>定义不可变类：确保类的所有属性都是私有的，并且只能通过构造函数来设置。<br>重写equals和hashCode方法：这样可以确保值对象的等价性是基于它们的属性值，而不是对象的引用。<br>提供只读访问器：只提供获取属性值的方法，不提供修改属性值的方法。<br>使用工厂方法或构造函数创建实例：这有助于确保值对象的有效性和一致性。<br>考虑序列化支持：如果值对象需要在网络上传输或存储到数据库中，需要提供序列化和反序列化的支持。</p><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><p>以订单状态为例，可以定义一个值对象来表示不同的状态：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Order</span> StatusVO&#123;</span><br><span class="line">    PLACED(<span class="number">0</span>,<span class="string">&quot;下单&quot;</span>),</span><br><span class="line">    PAID(<span class="number">1</span>,<span class="string">&quot;支付&quot;</span>),</span><br><span class="line">    COMPLETED(<span class="number">2</span>,<span class="string">&quot;完成&quot;</span>),</span><br><span class="line">    CANCELLED(<span class="number">3</span>,<span class="string">&quot;退单&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> code;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String description;</span><br><span class="line"></span><br><span class="line">OrderStatusVO(intcode,String description)&#123;</span><br><span class="line">    <span class="built_in">this</span>.code = code;</span><br><span class="line">    <span class="built_in">this</span>.description = description;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getCode</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> code;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getDescription</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> description;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//根据code获取对应的OrderStatus</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="title function_">OrderStatusVOfromCode</span><span class="params">(<span class="type">int</span> code)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(OrderStatusVO status:OrderStatusVO.values())&#123;</span><br><span class="line">        <span class="keyword">if</span>(status.getCode()==code)&#123;</span><br><span class="line">        <span class="keyword">return</span> status;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">throw</span> newIllegalArgumentException(<span class="string">&quot;Invalid code for OrderStatus:&quot;</span>+code);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，OrderStatusVO是一个枚举类型的值对象，它封装了订单状态的代码和描述。它是不可变的，并且提供了基于属性值的等价性。通过定义一个枚举，我们可以确保订单状态的值是受限的，并且每个状态都有一个明确的含义。</p><p>在数据库中，订单状态可能会以整数形式存储（例如，0表示下单，1表示支付等）。在应用程序中，我们可以使用OrderStatusVO枚举来确保我们在代码中使用的是类型安全的值，而不是裸露的整数。这样可以减少错误，并提高代码的可读性和可维护性。</p><p>当需要将订单状态存储到数据库中时，我们可以存储枚举的code值。当从数据库中读取订单状态时，我们可以使用fromCode方法来将整数值转换回OrderStatusVO枚举，这样我们就可以在代码中使用丰富的枚举类型而不是简单的整数。</p><p>值对象也可以用来表示更复杂的结构，比如一个地址：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> classAddressVO&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Stringstreet;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Stringcity;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> StringzipCode;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Stringcountry;</span><br><span class="line"></span><br><span class="line">    publicAddress(Stringstreet,Stringcity,StringzipCode,Stringcountry)&#123;</span><br><span class="line">        <span class="comment">//这里可以添加验证逻辑以确保地址的有效性</span></span><br><span class="line">        <span class="built_in">this</span>.street=street;</span><br><span class="line">        <span class="built_in">this</span>.city=city;</span><br><span class="line">        <span class="built_in">this</span>.zipCode=zipCode;</span><br><span class="line">        <span class="built_in">this</span>.country=country;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//只读访问器</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getStreet</span><span class="params">()</span>&#123;</span><br><span class="line">        returnstreet;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getCity</span><span class="params">()</span>&#123;</span><br><span class="line">        returncity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getZipCode</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> zipCode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getCountry</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> country;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重写equals和hashCode方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Objecto)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">this</span>==o)returntrue;</span><br><span class="line">        <span class="keyword">if</span>(o==<span class="literal">null</span>||getClass()!=o.getClass())returnfalse;</span><br><span class="line">        Address address=(Address)o;</span><br><span class="line">        <span class="keyword">return</span> street.equals(address.street)&amp;&amp;</span><br><span class="line">        city.equals(address.city)&amp;&amp;</span><br><span class="line">        zipCode.equals(address.zipCode)&amp;&amp;</span><br><span class="line">        country.equals(address.country);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.hash(street,city,zipCode,country);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，AddressVO是一个不可变的值对象，它封装了一个地址的所有部分。它提供了只读访问器，并且重写了equals和hashCode方法以确保基于属性值的等价性。这样的设计有助于确保地址的一致性，并且可以在不同的实体之间重复使用，例如用户和商店都可能有地址。</p><p>总的来说，值对象是DDD中用于封装领域概念的重要工具，它们通过提供不可变性、基于属性的等价性和替换性来帮助构建一个清晰、一致和可维护的领域模型。</p><h3 id="References"><a href="#References" class="headerlink" title="References"></a>References</h3><p><a href="https://bugstack.cn/" style="color: #177cb0; text-decoration: underline;text-decoration-style: dotted;">小傅哥 bugstack 虫洞栈</a></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DDD </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OpenAI SDK开发(1)</title>
      <link href="/2023/12/03/2023-12-3-OpenAI-SDK%E5%BC%80%E5%8F%91-1/"/>
      <url>/2023/12/03/2023-12-3-OpenAI-SDK%E5%BC%80%E5%8F%91-1/</url>
      
        <content type="html"><![CDATA[<h2 id="OpenAI-SDK开发-1"><a href="#OpenAI-SDK开发-1" class="headerlink" title="OpenAI SDK开发(1)"></a>OpenAI SDK开发(1)</h2><p>本次完成的是基本框架的搭建,项目结构如下图所示:</p><p><img src="https://pb01.s3.bitiful.net/36.png" alt="avatar"></p><h3 id="common"><a href="#common" class="headerlink" title="common"></a>common</h3><h5 id="Constants"><a href="#Constants" class="headerlink" title="Constants"></a>Constants</h5><p>common包下定义了Constants类,里面暂时写了一个枚举对象Role,是要用在Message中的一个参数,而Message在Request和Response中都有,所以放在common包下,后面会用到.</p><p><img src="https://pb01.s3.bitiful.net/37.png" alt="avatar"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Constants</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 官网支持的请求角色类型；system、user、assistant</span></span><br><span class="line"><span class="comment">     * https://platform.openai.com/docs/guides/chat/introduction</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Role</span> &#123;</span><br><span class="line"></span><br><span class="line">        SYSTEM(<span class="string">&quot;system&quot;</span>),</span><br><span class="line">        USER(<span class="string">&quot;user&quot;</span>),</span><br><span class="line">        ASSISTANT(<span class="string">&quot;assistant&quot;</span>),</span><br><span class="line">        ;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> String code;</span><br><span class="line"></span><br><span class="line">        Role(String code) &#123;</span><br><span class="line">            <span class="built_in">this</span>.code = code;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">getCode</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> code;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="domain"><a href="#domain" class="headerlink" title="domain"></a>domain</h3><h4 id="chat-聊天模型"><a href="#chat-聊天模型" class="headerlink" title="chat(聊天模型)"></a>chat(聊天模型)</h4><h5 id="ChatChoice"><a href="#ChatChoice" class="headerlink" title="ChatChoice"></a>ChatChoice</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ChatChoice</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> index;</span><br><span class="line">    <span class="meta">@JsonProperty(&quot;message&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Message message;</span><br><span class="line">    <span class="meta">@JsonProperty(&quot;finish_reason&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String finishReason;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里面定义的是choices中的几个参数,choices参数是在Response中的</p><p><img src="https://pb01.s3.bitiful.net/38.png" alt="avatar"></p><h5 id="ChatCompletionRequest-聊天完成请求"><a href="#ChatCompletionRequest-聊天完成请求" class="headerlink" title="ChatCompletionRequest(聊天完成请求)"></a>ChatCompletionRequest(聊天完成请求)</h5><p>把model单独写了一个枚举类,定义类所需参数</p><p>这些参数里只有model和message是必须的,其他的都是可选的,所以用Builder模式来构建对象</p><p><img src="https://pb01.s3.bitiful.net/39.png" alt="avatar"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Builder</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@JsonInclude(JsonInclude.Include.NON_NULL)</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ChatCompletionRequest</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 默认模型 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">model</span> <span class="operator">=</span> Model.GPT_3_5_TURBO.getCode();</span><br><span class="line">    <span class="comment">/** 问题描述 */</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;Message&gt; messages;</span><br><span class="line">    <span class="comment">/** 控制温度【随机性】；0到2之间。较高的值(如0.8)将使输出更加随机，而较低的值(如0.2)将使输出更加集中和确定 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> <span class="variable">temperature</span> <span class="operator">=</span> <span class="number">0.2</span>;</span><br><span class="line">    <span class="comment">/** 多样性控制；使用温度采样的替代方法称为核心采样，其中模型考虑具有top_p概率质量的令牌的结果。因此，0.1 意味着只考虑包含前 10% 概率质量的代币 */</span></span><br><span class="line">    <span class="meta">@JsonProperty(&quot;top_p&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Double</span> <span class="variable">topP</span> <span class="operator">=</span> <span class="number">1d</span>;</span><br><span class="line">    <span class="comment">/** 为每个提示生成的完成次数 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Integer</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="comment">/** 是否为流式输出；就是一蹦一蹦的，出来结果 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">stream</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">/** 停止输出标识 */</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; stop;</span><br><span class="line">    <span class="comment">/** 输出字符串限制；0 ~ 4096 */</span></span><br><span class="line">    <span class="meta">@JsonProperty(&quot;max_tokens&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Integer</span> <span class="variable">maxTokens</span> <span class="operator">=</span> <span class="number">2048</span>;</span><br><span class="line">    <span class="comment">/** 频率惩罚；降低模型重复同一行的可能性 */</span></span><br><span class="line">    <span class="meta">@JsonProperty(&quot;frequency_penalty&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> <span class="variable">frequencyPenalty</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/** 存在惩罚；增强模型谈论新话题的可能性 */</span></span><br><span class="line">    <span class="meta">@JsonProperty(&quot;presence_penalty&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> <span class="variable">presencePenalty</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/** 生成多个调用结果，只显示最佳的。这样会更多的消耗你的 api token */</span></span><br><span class="line">    <span class="meta">@JsonProperty(&quot;logit_bias&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Map logitBias;</span><br><span class="line">    <span class="comment">/** 调用标识，避免重复调用 */</span></span><br><span class="line">    <span class="keyword">private</span> String user;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Getter</span></span><br><span class="line">    <span class="meta">@AllArgsConstructor</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Model</span> &#123;</span><br><span class="line">        <span class="comment">/** gpt-3.5-turbo */</span></span><br><span class="line">        GPT_3_5_TURBO(<span class="string">&quot;gpt-3.5-turbo&quot;</span>),</span><br><span class="line">        <span class="comment">/** GPT4.0 */</span></span><br><span class="line">        GPT_4(<span class="string">&quot;gpt-4&quot;</span>),</span><br><span class="line">        <span class="comment">/** GPT4.0 超长上下文 */</span></span><br><span class="line">        GPT_4_32K(<span class="string">&quot;gpt-4-32k&quot;</span>),</span><br><span class="line">        ;</span><br><span class="line">        <span class="keyword">private</span> String code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="ChatCompletionResponse-聊天完成响应"><a href="#ChatCompletionResponse-聊天完成响应" class="headerlink" title="ChatCompletionResponse(聊天完成响应)"></a>ChatCompletionResponse(聊天完成响应)</h5><p>定义了Response中的参数</p><p><img src="https://pb01.s3.bitiful.net/38.png" alt="avatar"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ChatCompletionResponse</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** ID */</span></span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line">    <span class="comment">/** 对象 */</span></span><br><span class="line">    <span class="keyword">private</span> String object;</span><br><span class="line">    <span class="comment">/** 模型 */</span></span><br><span class="line">    <span class="keyword">private</span> String model;</span><br><span class="line">    <span class="comment">/** 对话 */</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;ChatChoice&gt; choices;</span><br><span class="line">    <span class="comment">/** 创建 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> created;</span><br><span class="line">    <span class="comment">/** 耗材 */</span></span><br><span class="line">    <span class="keyword">private</span> Usage usage;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="Message"><a href="#Message" class="headerlink" title="Message"></a>Message</h5><p>定义的聊天消息对象，包含消息角色、消息内容、消息名称</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@JsonInclude(JsonInclude.Include.NON_NULL)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Message</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String role;</span><br><span class="line">    <span class="keyword">private</span> String content;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Message</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Message</span><span class="params">(Builder builder)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.role = builder.role;</span><br><span class="line">        <span class="built_in">this</span>.content = builder.content;</span><br><span class="line">        <span class="built_in">this</span>.name = builder.name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Builder <span class="title function_">builder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Builder</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 建造者模式</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Builder</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> String role;</span><br><span class="line">        <span class="keyword">private</span> String content;</span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Builder</span><span class="params">()</span> &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> Builder <span class="title function_">role</span><span class="params">(Constants.Role role)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.role = role.getCode();</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> Builder <span class="title function_">content</span><span class="params">(String content)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.content = content;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> Builder <span class="title function_">name</span><span class="params">(String name)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.name = name;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> Message <span class="title function_">build</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Message</span>(<span class="built_in">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="other"><a href="#other" class="headerlink" title="other"></a>other</h4><h5 id="Usage-使用量"><a href="#Usage-使用量" class="headerlink" title="Usage(使用量)"></a>Usage(使用量)</h5><p>是Response中的一个参数,记录了token的使用量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Usage</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 提示令牌 */</span></span><br><span class="line">    <span class="meta">@JsonProperty(&quot;prompt_tokens&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> promptTokens;</span><br><span class="line">    <span class="comment">/** 完成令牌 */</span></span><br><span class="line">    <span class="meta">@JsonProperty(&quot;completion_tokens&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> completionTokens;</span><br><span class="line">    <span class="comment">/** 总量令牌 */</span></span><br><span class="line">    <span class="meta">@JsonProperty(&quot;total_tokens&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> totalTokens;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">getPromptTokens</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> promptTokens;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setPromptTokens</span><span class="params">(<span class="type">long</span> promptTokens)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.promptTokens = promptTokens;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">getCompletionTokens</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> completionTokens;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setCompletionTokens</span><span class="params">(<span class="type">long</span> completionTokens)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.completionTokens = completionTokens;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">getTotalTokens</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> totalTokens;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setTotalTokens</span><span class="params">(<span class="type">long</span> totalTokens)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.totalTokens = totalTokens;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="OpenAiResponse"><a href="#OpenAiResponse" class="headerlink" title="OpenAiResponse"></a>OpenAiResponse</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OpenAiResponse</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String object;</span><br><span class="line">    <span class="keyword">private</span> List&lt;T&gt; data;</span><br><span class="line">    <span class="keyword">private</span> Error error;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Data</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Error</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> String message;</span><br><span class="line">        <span class="keyword">private</span> String type;</span><br><span class="line">        <span class="keyword">private</span> String param;</span><br><span class="line">        <span class="keyword">private</span> String code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="qa-问答模型"><a href="#qa-问答模型" class="headerlink" title="qa(问答模型)"></a>qa(问答模型)</h4><p><img src="https://pb01.s3.bitiful.net/40.png" alt="avatar"><br>很快就不能用了,而且跟聊天模型差不多,就不贴代码了</p><h5 id="QAChoice"><a href="#QAChoice" class="headerlink" title="QAChoice"></a>QAChoice</h5><p><img src="https://pb01.s3.bitiful.net/41.png" alt="avatar"></p><h5 id="QACompletionRequest"><a href="#QACompletionRequest" class="headerlink" title="QACompletionRequest"></a>QACompletionRequest</h5><p>model和prompt参数必要,其他参数可选</p><p><img src="https://pb01.s3.bitiful.net/42.png" alt="avatar"></p><h5 id="QACompletionResponse"><a href="#QACompletionResponse" class="headerlink" title="QACompletionResponse"></a>QACompletionResponse</h5><p><img src="https://pb01.s3.bitiful.net/43.png" alt="avatar"></p><h3 id="interceptor"><a href="#interceptor" class="headerlink" title="interceptor"></a>interceptor</h3><h5 id="OpenAiInterceptor-自定义拦截器"><a href="#OpenAiInterceptor-自定义拦截器" class="headerlink" title="OpenAiInterceptor(自定义拦截器)"></a>OpenAiInterceptor(自定义拦截器)</h5><p>auth方法将token参数加入url对象,返回一个新的请求,intercept对该请求进行预处理，然后将处理后的请求传递给下一个拦截器（或目标方法）继续处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OpenAiInterceptor</span> <span class="keyword">implements</span> <span class="title class_">Interceptor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** OpenAi apiKey 需要在官网申请 */</span></span><br><span class="line">    <span class="keyword">private</span> String apiKey;</span><br><span class="line">    <span class="comment">/** 访问授权接口的认证 Token */</span></span><br><span class="line">    <span class="keyword">private</span> String authToken;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">OpenAiInterceptor</span><span class="params">(String apiKey, String authToken)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.apiKey = apiKey;</span><br><span class="line">        <span class="built_in">this</span>.authToken = authToken;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotNull</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Response <span class="title function_">intercept</span><span class="params">(Chain chain)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="keyword">return</span> chain.proceed(<span class="built_in">this</span>.auth(apiKey, chain.request()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Request <span class="title function_">auth</span><span class="params">(String apiKey, Request original)</span> &#123;</span><br><span class="line">        <span class="comment">// 设置Token信息；如果没有此类限制，是不需要设置的。</span></span><br><span class="line">        <span class="type">HttpUrl</span> <span class="variable">url</span> <span class="operator">=</span> original.url().newBuilder()</span><br><span class="line">                .addQueryParameter(<span class="string">&quot;token&quot;</span>, authToken)</span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建请求</span></span><br><span class="line">        <span class="keyword">return</span> original.newBuilder()</span><br><span class="line">                .url(url)</span><br><span class="line">                .header(Header.AUTHORIZATION.getValue(), <span class="string">&quot;Bearer &quot;</span> + apiKey)</span><br><span class="line">                .header(Header.CONTENT_TYPE.getValue(), ContentType.JSON.getValue())</span><br><span class="line">                .method(original.method(), original.body())</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="session"><a href="#session" class="headerlink" title="session"></a>session</h3><h5 id="IOpenAiApi"><a href="#IOpenAiApi" class="headerlink" title="IOpenAiApi"></a>IOpenAiApi</h5><p>定义访问接口,传入请求</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IOpenAiApi</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Body</span>注解用于描述一个接口中的一个方法参数，该参数将接收请求体中的表单数据。</span></span><br><span class="line"><span class="comment">     * 当处理HTTP POST请求时，通常将请求体中的表单数据映射到接口中的方法参数。</span></span><br><span class="line"><span class="comment">     **/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 文本问答</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> qaCompletionRequest 请求信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>                    返回结果</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@POST(&quot;v1/completions&quot;)</span></span><br><span class="line">    Single&lt;QACompletionResponse&gt; <span class="title function_">completions</span><span class="params">(<span class="meta">@Body</span> QACompletionRequest qaCompletionRequest)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 默认 GPT-3.5 问答模型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> chatCompletionRequest 请求信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>                      返回结果</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@POST(&quot;v1/chat/completions&quot;)</span></span><br><span class="line">    Single&lt;ChatCompletionResponse&gt; <span class="title function_">completions</span><span class="params">(<span class="meta">@Body</span> ChatCompletionRequest chatCompletionRequest)</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="OpenAiSession"><a href="#OpenAiSession" class="headerlink" title="OpenAiSession"></a>OpenAiSession</h5><p>会话接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">OpenAiSession</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 文本问答</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> qaCompletionRequest 请求信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>                    返回结果</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    QACompletionResponse <span class="title function_">completions</span><span class="params">(QACompletionRequest qaCompletionRequest)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 文本问答；简单请求</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> question 请求信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>         返回结果</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    QACompletionResponse <span class="title function_">completions</span><span class="params">(String question)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 默认 GPT-3.5 问答模型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> chatCompletionRequest 请求信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>                      返回结果</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ChatCompletionResponse <span class="title function_">completions</span><span class="params">(ChatCompletionRequest chatCompletionRequest)</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="OpenAiSessionFactory"><a href="#OpenAiSessionFactory" class="headerlink" title="OpenAiSessionFactory"></a>OpenAiSessionFactory</h5><p>会话工厂接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">OpenAiSessionFactory</span> &#123;</span><br><span class="line"></span><br><span class="line">    OpenAiSession <span class="title function_">openSession</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="Configuration"><a href="#Configuration" class="headerlink" title="Configuration"></a>Configuration</h5><p>配置类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Configuration</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Getter</span></span><br><span class="line">    <span class="meta">@NotNull</span></span><br><span class="line">    <span class="keyword">private</span> String apiKey;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Getter</span></span><br><span class="line">    <span class="keyword">private</span> String apiHost;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Getter</span></span><br><span class="line"><span class="comment">//    @NotNull</span></span><br><span class="line">    <span class="keyword">private</span> String authToken;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="DefaultOpenAiSession"><a href="#DefaultOpenAiSession" class="headerlink" title="DefaultOpenAiSession"></a>DefaultOpenAiSession</h5><p>实现OpenAiSession接口</p><p>blockingGet()是RxJava中Single<T>中的方法,用于将当前线程阻塞,这里的作用是将异步计算的结果转换为同步结果，使得调用这个方法的线程会等待异步计算完成后才继续执行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DefaultOpenAiSession</span> <span class="keyword">implements</span> <span class="title class_">OpenAiSession</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> IOpenAiApi openAiApi;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DefaultOpenAiSession</span><span class="params">(IOpenAiApi openAiApi)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.openAiApi = openAiApi;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> QACompletionResponse <span class="title function_">completions</span><span class="params">(QACompletionRequest qaCompletionRequest)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.openAiApi.completions(qaCompletionRequest).blockingGet();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> QACompletionResponse <span class="title function_">completions</span><span class="params">(String question)</span> &#123;</span><br><span class="line">        <span class="type">QACompletionRequest</span> <span class="variable">request</span> <span class="operator">=</span> QACompletionRequest</span><br><span class="line">                .builder()</span><br><span class="line">                .prompt(question)</span><br><span class="line">                .build();</span><br><span class="line">        Single&lt;QACompletionResponse&gt; completions = <span class="built_in">this</span>.openAiApi.completions(request);</span><br><span class="line">        <span class="keyword">return</span> completions.blockingGet();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> ChatCompletionResponse <span class="title function_">completions</span><span class="params">(ChatCompletionRequest chatCompletionRequest)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.openAiApi.completions(chatCompletionRequest).blockingGet();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="DefaultOpenAiSessionFactory"><a href="#DefaultOpenAiSessionFactory" class="headerlink" title="DefaultOpenAiSessionFactory"></a>DefaultOpenAiSessionFactory</h5><p>实现OpenAiSessionFactory接口,其实实现的是IOpenAiApi接口,返回一个DefaultOpenAiSession(openAiApi)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DefaultOpenAiSessionFactory</span> <span class="keyword">implements</span> <span class="title class_">OpenAiSessionFactory</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Configuration configuration;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DefaultOpenAiSessionFactory</span><span class="params">(Configuration configuration)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.configuration = configuration;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> OpenAiSession <span class="title function_">openSession</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 1. 日志配置</span></span><br><span class="line">        <span class="type">HttpLoggingInterceptor</span> <span class="variable">httpLoggingInterceptor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HttpLoggingInterceptor</span>();</span><br><span class="line">        httpLoggingInterceptor.setLevel(HttpLoggingInterceptor.Level.HEADERS);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 开启 Http 客户端</span></span><br><span class="line">        <span class="type">OkHttpClient</span> <span class="variable">okHttpClient</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OkHttpClient</span></span><br><span class="line">                .Builder()</span><br><span class="line">                .addInterceptor(httpLoggingInterceptor)</span><br><span class="line">                .addInterceptor(<span class="keyword">new</span> <span class="title class_">OpenAiInterceptor</span>(configuration.getApiKey(), configuration.getAuthToken()))</span><br><span class="line">                .connectTimeout(<span class="number">450</span>, TimeUnit.SECONDS)</span><br><span class="line">                .writeTimeout(<span class="number">450</span>, TimeUnit.SECONDS)</span><br><span class="line">                .readTimeout(<span class="number">450</span>, TimeUnit.SECONDS)</span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 实现IOpenAiApi接口,创建 API 服务,即网络请求接口对象实例</span></span><br><span class="line">        <span class="type">IOpenAiApi</span> <span class="variable">openAiApi</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Retrofit</span>.Builder()</span><br><span class="line">                .baseUrl(configuration.getApiHost())<span class="comment">//得到url</span></span><br><span class="line">                .client(okHttpClient)<span class="comment">//设置客户端</span></span><br><span class="line"><span class="comment">//        RxJava2CallAdapterFactory的主要作用是：</span></span><br><span class="line"><span class="comment">//        1.将Android的Call对象转换为RxJava的Observable类型。</span></span><br><span class="line"><span class="comment">//        2.处理Call的错误和结果，并将其转换为RxJava的onError和onNext事件。</span></span><br><span class="line"><span class="comment">//        3.添加适当的错误处理逻辑，例如重试、网络错误等。</span></span><br><span class="line">                .addCallAdapterFactory(RxJava2CallAdapterFactory.create())</span><br><span class="line">                .addConverterFactory(JacksonConverterFactory.create())<span class="comment">//在请求和响应中使用jackson库进行json转换</span></span><br><span class="line">                .build().create(IOpenAiApi.class);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DefaultOpenAiSession</span>(openAiApi);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h3><p>传url,key,token和request就行</p><p><img src="https://pb01.s3.bitiful.net/44.png" alt="avatar"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ApiTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> OpenAiSession openAiSession;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test_OpenAiSessionFactory</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 1. 配置文件</span></span><br><span class="line">        <span class="type">Configuration</span> <span class="variable">configuration</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Configuration</span>();</span><br><span class="line">        configuration.setApiHost(<span class="string">&quot;https://api.openai-proxy.com/&quot;</span>);</span><br><span class="line">        configuration.setApiKey(<span class="string">&quot;xxx&quot;</span>);</span><br><span class="line">        configuration.setAuthToken(<span class="string">&quot;xxx&quot;</span>);</span><br><span class="line">        <span class="comment">// 2. 会话工厂</span></span><br><span class="line">        <span class="type">OpenAiSessionFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultOpenAiSessionFactory</span>(configuration);</span><br><span class="line">        <span class="comment">// 3. 开启会话</span></span><br><span class="line">        <span class="built_in">this</span>.openAiSession = factory.openSession();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 此对话模型 3.5 接近于官网体验</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test_chat_completions</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 1. 创建参数</span></span><br><span class="line">        <span class="type">ChatCompletionRequest</span> <span class="variable">chatCompletion</span> <span class="operator">=</span> ChatCompletionRequest</span><br><span class="line">                .builder()</span><br><span class="line">                .messages(Collections.singletonList(Message.builder().role(Constants.Role.USER).content(<span class="string">&quot;写一个java冒泡排序&quot;</span>).build()))</span><br><span class="line">                .model(ChatCompletionRequest.Model.GPT_3_5_TURBO.getCode())</span><br><span class="line">                .build();</span><br><span class="line">        <span class="comment">// 2. 发起请求</span></span><br><span class="line">        <span class="type">ChatCompletionResponse</span> <span class="variable">chatCompletionResponse</span> <span class="operator">=</span> openAiSession.completions(chatCompletion);</span><br><span class="line">        <span class="comment">// 3. 解析结果</span></span><br><span class="line">        chatCompletionResponse.getChoices().forEach(e -&gt; &#123;</span><br><span class="line">            log.info(<span class="string">&quot;测试结果：&#123;&#125;&quot;</span>, e.getMessage());</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>西电计科微机原理实验二(详细注释版)</title>
      <link href="/2023/12/02/2023-12-2-%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86%E5%AE%9E%E9%AA%8C2/"/>
      <url>/2023/12/02/2023-12-2-%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86%E5%AE%9E%E9%AA%8C2/</url>
      
        <content type="html"><![CDATA[<h3 id="西电计科微机原理实验二-详细注释版"><a href="#西电计科微机原理实验二-详细注释版" class="headerlink" title="西电计科微机原理实验二(详细注释版)"></a>西电计科微机原理实验二(详细注释版)</h3><p><strong>环境</strong>:VSCode+MASM/TASM插件(建议使用相同环境,学校机房环境有点老,可能会出一些奇怪的问题)</p><p><img src="https://pb01.s3.bitiful.net/32.png" alt="avatar"></p><h4 id="实验要求"><a href="#实验要求" class="headerlink" title="实验要求"></a>实验要求</h4><ol><li>输入一个不超过5位的十进制数,回车结束输入,并将其转换为二进制数,输出到屏幕上</li><li>输入非数字字符,报错,重新输入</li><li>输入q或Q,结束程序</li><li>输入字符串,空格结束输入,统计字符串中数字的个数 <strong>(选做)</strong></li></ol><h4 id="基础版本-不做4"><a href="#基础版本-不做4" class="headerlink" title="基础版本(不做4)"></a>基础版本(不做4)</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br></pre></td><td class="code"><pre><span class="line">_STACK SEGMENT PARA STACK&#x27;_STACK&#x27;</span><br><span class="line">DB 128 DUP(0)</span><br><span class="line">_STACK ENDS</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">DATA SEGMENT</span><br><span class="line">    hello DB &#x27;Input a number or an instruction!!Q OR q: EXIT&#x27;,0AH,0DH,&#x27;$&#x27;</span><br><span class="line">    wrong DB 0AH,0DH,&#x27;Wrong Input(only numbers!)&#x27;,0AH,0DH,&#x27;$&#x27;</span><br><span class="line">    endofhex DB 0AH,0DH,&#x27;Binary:&#x27;,0AH,0DH,&#x27;$&#x27;</span><br><span class="line">    finish DB 0AH,0DH,&#x27;Finished&#x27;,0AH,0DH,&#x27;$&#x27;</span><br><span class="line">    got DB 5 DUP(0)</span><br><span class="line">DATA ENDS</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">CODE SEGMENT</span><br><span class="line">assume cs:CODE,ds:DATA,ss:_STACK</span><br><span class="line"></span><br><span class="line">START:</span><br><span class="line"></span><br><span class="line">beginofread:</span><br><span class="line">    mov ax,DATA</span><br><span class="line">    mov ds,ax</span><br><span class="line">    ;取偏移地址</span><br><span class="line">    mov dx,offset hello</span><br><span class="line">    ;显示字符串</span><br><span class="line">    mov ah,09H</span><br><span class="line">    int 21H</span><br><span class="line">    ; 清零BX</span><br><span class="line">    mov bx,0H</span><br><span class="line">    ; 初始化DI和CX</span><br><span class="line">    mov di,offset got</span><br><span class="line">    mov cx,0H</span><br><span class="line">readchar:</span><br><span class="line">    ; 读取字符</span><br><span class="line">    mov ah,01H</span><br><span class="line">    int 21H</span><br><span class="line">    ; 比较BX是否为0，如果不是，跳到notfirst</span><br><span class="line">    cmp bx,0H</span><br><span class="line">    jne notfirst</span><br><span class="line">    ; 比较AL是否为Q或q，如果是，则退出程序</span><br><span class="line">    cmp al,&#x27;Q&#x27;</span><br><span class="line">    je exit</span><br><span class="line">    cmp al,&#x27;q&#x27;</span><br><span class="line">    je exit</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">notfirst:</span><br><span class="line">;判断是否合法</span><br><span class="line">    mov bx,01H</span><br><span class="line">    call legalcheck</span><br><span class="line">;不合法重新开始</span><br><span class="line">    cmp bx,02H</span><br><span class="line">    je beginofread</span><br><span class="line">;换行输入结束</span><br><span class="line">    cmp bx,04H</span><br><span class="line">    je endofinput</span><br><span class="line"></span><br><span class="line">    jmp loadinmemory</span><br><span class="line"></span><br><span class="line">loadinmemory:</span><br><span class="line">;输入存入内存</span><br><span class="line">    mov [di],al</span><br><span class="line">    inc cx</span><br><span class="line">    inc di</span><br><span class="line">    jmp readchar</span><br><span class="line"></span><br><span class="line">endofinput:</span><br><span class="line">;取前5位</span><br><span class="line">    mov dx,0H</span><br><span class="line">    mov di,offset got</span><br><span class="line"></span><br><span class="line">;将数字转换为ascii码</span><br><span class="line">beginofhandle:</span><br><span class="line">    mov bx,0H</span><br><span class="line">    mov bl,[di]</span><br><span class="line">    ; 将寄存器BX中的值减去30H</span><br><span class="line">    sub bx,30H  </span><br><span class="line">    add dx,bx</span><br><span class="line">    ;处理完毕</span><br><span class="line">    cmp cx,1H</span><br><span class="line">    je endofhandle</span><br><span class="line">    ;ax清零,乘10</span><br><span class="line">    call mulAHdxtodx</span><br><span class="line">    ;待处理字符减一</span><br><span class="line">    dec cx</span><br><span class="line">    ;下一位</span><br><span class="line">    inc di</span><br><span class="line">    jmp beginofhandle</span><br><span class="line"></span><br><span class="line">;输出ASCII码</span><br><span class="line">endofhandle:</span><br><span class="line">;输出2进制</span><br><span class="line">    call binaryoutput</span><br><span class="line">;跳转重新开始</span><br><span class="line">    jmp beginofread</span><br><span class="line"></span><br><span class="line">binaryoutput:</span><br><span class="line">    mov bx,dx</span><br><span class="line">    mov dx,0H</span><br><span class="line">    mov cx,10H ;循环16次</span><br><span class="line">    ;开始循环</span><br><span class="line">beginofoutputloop:</span><br><span class="line">;左移1位</span><br><span class="line">    shl bx,1</span><br><span class="line">;不进位则跳转</span><br><span class="line">    jnc out0</span><br><span class="line">    mov dl,&#x27;1&#x27;</span><br><span class="line">    jmp outputdl</span><br><span class="line">out0:</span><br><span class="line">    mov dl,&#x27;0&#x27;</span><br><span class="line">outputdl:</span><br><span class="line">    mov ah,02H</span><br><span class="line">    int 21H</span><br><span class="line">    dec cx ;循环次数减1</span><br><span class="line">    cmp cx,0H ;判断循环是否结束</span><br><span class="line">    jne beginofoutputloop</span><br><span class="line">    ;结束循环,输出结束语句</span><br><span class="line">    mov dx,offset finish </span><br><span class="line">    mov ah,09H </span><br><span class="line">    int 21H</span><br><span class="line">    ret</span><br><span class="line"></span><br><span class="line">legalcheck:</span><br><span class="line">;判断换行</span><br><span class="line">    cmp al,0DH</span><br><span class="line">    je endlegalnextline</span><br><span class="line">;判断数字0-9</span><br><span class="line">    cmp al,30H</span><br><span class="line">    jb endlegalfalse</span><br><span class="line">    cmp al,39H</span><br><span class="line">    ja endlegalfalse</span><br><span class="line"></span><br><span class="line">endlegaltrue:</span><br><span class="line">    mov bx,03H</span><br><span class="line">    ret</span><br><span class="line"></span><br><span class="line">endlegalnextline:</span><br><span class="line">    mov bx,04H</span><br><span class="line">    ret</span><br><span class="line"></span><br><span class="line">endlegalfalse:</span><br><span class="line">;输出wrong语句</span><br><span class="line">    mov dx,offset wrong</span><br><span class="line">    mov ah,09H</span><br><span class="line">    int 21H</span><br><span class="line">;重新开始程序</span><br><span class="line">    mov bx,02H</span><br><span class="line">    ret</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">mulAHdxtodx:</span><br><span class="line">    mov bx,0H</span><br><span class="line">    mov ax,0H</span><br><span class="line">    </span><br><span class="line">loopofmul:</span><br><span class="line">    add ax,dx</span><br><span class="line">    inc bx</span><br><span class="line">    cmp bx,0AH</span><br><span class="line">    jb loopofmul</span><br><span class="line">    mov dx,ax</span><br><span class="line">    ret</span><br><span class="line"></span><br><span class="line">exit:</span><br><span class="line">    mov ah,4CH</span><br><span class="line">    int 21H</span><br><span class="line">CODE ENDS</span><br><span class="line">END START</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>运行结果:</strong></p><p><img src="https://pb01.s3.bitiful.net/34.png" alt="avatar"></p><h4 id="完整版-实验结束后完成"><a href="#完整版-实验结束后完成" class="headerlink" title="完整版(实验结束后完成)"></a>完整版(实验结束后完成)</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br></pre></td><td class="code"><pre><span class="line">_STACK SEGMENT PARA STACK&#x27;_STACK&#x27;</span><br><span class="line">DB 128 DUP(0)</span><br><span class="line">_STACK ENDS</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">DATA SEGMENT</span><br><span class="line">    hello DB &#x27;Input a number or an instruction!!Q OR q: EXIT,s:SEARCH&#x27;,0AH,0DH,&#x27;$&#x27;</span><br><span class="line">    wrong DB 0AH,0DH,&#x27;Wrong Input(only numbers!)&#x27;,0AH,0DH,&#x27;$&#x27;</span><br><span class="line">    endofhex DB 0AH,0DH,&#x27;Binary:&#x27;,0AH,0DH,&#x27;$&#x27;</span><br><span class="line">    finish DB 0AH,0DH,&#x27;Finished&#x27;,0AH,0DH,&#x27;$&#x27;</span><br><span class="line">    hello2 DB 0AH,0DH,&#x27;Search number inyour string. Space to end input&#x27;,0AH,0DH,&#x27;Input string:&#x27;,0AH,0DH,&#x27;$&#x27;</span><br><span class="line">    finish2 DB 0AH,0DH,&#x27;FINISHED!!!&#x27;,0AH,0DH,&#x27;THERE ARE &#x27;,&#x27;$&#x27;</span><br><span class="line">    finish3 DB &#x27; numbers&#x27;,0AH,0DH,&#x27;$&#x27;</span><br><span class="line">    got DB 5 DUP(0)</span><br><span class="line">DATA ENDS</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">CODE SEGMENT</span><br><span class="line">assume cs:CODE,ds:DATA,ss:_STACK</span><br><span class="line"></span><br><span class="line">START:</span><br><span class="line"></span><br><span class="line">beginofread:</span><br><span class="line">    mov ax,DATA</span><br><span class="line">    mov ds,ax</span><br><span class="line">    ;取偏移地址</span><br><span class="line">    mov dx,offset hello</span><br><span class="line">    ;显示字符串</span><br><span class="line">    mov ah,09H</span><br><span class="line">    int 21H</span><br><span class="line">    ; 清零BX</span><br><span class="line">    mov bx,0H</span><br><span class="line">    ; 初始化DI和CX</span><br><span class="line">    mov di,offset got</span><br><span class="line">    mov cx,0H</span><br><span class="line">readchar:</span><br><span class="line">    ; 读取字符</span><br><span class="line">    mov ah,01H</span><br><span class="line">    int 21H</span><br><span class="line">    ; 比较BX是否为0，如果不是，跳到notfirst</span><br><span class="line">    cmp bx,0H</span><br><span class="line">    jne notfirst</span><br><span class="line">    ; 比较AL是否为Q或q，如果是，则退出程序</span><br><span class="line">    cmp al,&#x27;Q&#x27;</span><br><span class="line">    je exit</span><br><span class="line">    cmp al,&#x27;q&#x27;</span><br><span class="line">    je exit</span><br><span class="line">    ; 比较AL是否为s，如果是，则进行搜索操作</span><br><span class="line">    cmp al,&#x27;s&#x27;</span><br><span class="line">    je counterofnumber</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">notfirst:</span><br><span class="line">;判断是否合法</span><br><span class="line">    mov bx,01H</span><br><span class="line">    call legalcheck</span><br><span class="line">;不合法重新开始</span><br><span class="line">    cmp bx,02H</span><br><span class="line">    je beginofread</span><br><span class="line">;换行输入结束</span><br><span class="line">    cmp bx,04H</span><br><span class="line">    je endofinput</span><br><span class="line"></span><br><span class="line">    jmp loadinmemory</span><br><span class="line"></span><br><span class="line">loadinmemory:</span><br><span class="line">;输入存入内存</span><br><span class="line">    mov [di],al</span><br><span class="line">    inc cx</span><br><span class="line">    inc di</span><br><span class="line">    jmp readchar</span><br><span class="line"></span><br><span class="line">endofinput:</span><br><span class="line">;取前5位</span><br><span class="line">    mov dx,0H</span><br><span class="line">    mov di,offset got</span><br><span class="line"></span><br><span class="line">;将数字转换为ascii码</span><br><span class="line">beginofhandle:</span><br><span class="line">    mov bx,0H</span><br><span class="line">    mov bl,[di]</span><br><span class="line">    ; 将寄存器BX中的值减去30H</span><br><span class="line">    sub bx,30H  </span><br><span class="line">    add dx,bx</span><br><span class="line">    ;处理完毕</span><br><span class="line">    cmp cx,1H</span><br><span class="line">    je endofhandle</span><br><span class="line">    ;ax清零,乘10</span><br><span class="line">    call mulAHdxtodx</span><br><span class="line">    ;待处理字符减一</span><br><span class="line">    dec cx</span><br><span class="line">    ;下一位</span><br><span class="line">    inc di</span><br><span class="line">    jmp beginofhandle</span><br><span class="line"></span><br><span class="line">;输出ASCII码</span><br><span class="line">endofhandle:</span><br><span class="line">;输出2进制</span><br><span class="line">    call binaryoutput</span><br><span class="line">;跳转重新开始</span><br><span class="line">    jmp beginofread</span><br><span class="line"></span><br><span class="line">binaryoutput:</span><br><span class="line">    mov bx,dx</span><br><span class="line">    mov dx,0H</span><br><span class="line">    mov cx,10H ;循环16次</span><br><span class="line">    ;开始循环</span><br><span class="line">beginofoutputloop:</span><br><span class="line">;左移1位</span><br><span class="line">    shl bx,1</span><br><span class="line">;不进位则跳转</span><br><span class="line">    jnc out0</span><br><span class="line">    mov dl,&#x27;1&#x27;</span><br><span class="line">    jmp outputdl</span><br><span class="line">out0:</span><br><span class="line">    mov dl,&#x27;0&#x27;</span><br><span class="line">outputdl:</span><br><span class="line">    mov ah,02H</span><br><span class="line">    int 21H</span><br><span class="line">    dec cx ;循环次数减1</span><br><span class="line">    cmp cx,0H ;判断循环是否结束</span><br><span class="line">    jne beginofoutputloop</span><br><span class="line">    ;结束循环,输出结束语句</span><br><span class="line">    mov dx,offset finish </span><br><span class="line">    mov ah,09H </span><br><span class="line">    int 21H</span><br><span class="line">    ret</span><br><span class="line"></span><br><span class="line">legalcheck:</span><br><span class="line">;判断换行</span><br><span class="line">    cmp al,0DH</span><br><span class="line">    je endlegalnextline</span><br><span class="line">;判断数字0-9</span><br><span class="line">    cmp al,30H</span><br><span class="line">    jb endlegalfalse</span><br><span class="line">    cmp al,39H</span><br><span class="line">    ja endlegalfalse</span><br><span class="line"></span><br><span class="line">endlegaltrue:</span><br><span class="line">    mov bx,03H</span><br><span class="line">    ret</span><br><span class="line"></span><br><span class="line">endlegalnextline:</span><br><span class="line">    mov bx,04H</span><br><span class="line">    ret</span><br><span class="line"></span><br><span class="line">endlegalfalse:</span><br><span class="line">;输出wrong语句</span><br><span class="line">    mov dx,offset wrong</span><br><span class="line">    mov ah,09H</span><br><span class="line">    int 21H</span><br><span class="line">;重新开始程序</span><br><span class="line">    mov bx,02H</span><br><span class="line">    ret</span><br><span class="line"></span><br><span class="line">mulAHdxtodx:</span><br><span class="line">    mov bx,0H</span><br><span class="line">    mov ax,0H</span><br><span class="line">    </span><br><span class="line">loopofmul:</span><br><span class="line">    add ax,dx</span><br><span class="line">    inc bx</span><br><span class="line">    cmp bx,0AH</span><br><span class="line">    jb loopofmul</span><br><span class="line">    mov dx,ax</span><br><span class="line">    ret</span><br><span class="line"></span><br><span class="line">counterofnumber:</span><br><span class="line">    mov dx,offset hello2</span><br><span class="line">    mov ah,09H</span><br><span class="line">    int 21H</span><br><span class="line">    mov cx,0H</span><br><span class="line">beginofcount:</span><br><span class="line">    mov ah,01H</span><br><span class="line">    int 21H</span><br><span class="line">    ;空格完成输入</span><br><span class="line">    cmp al,20H</span><br><span class="line">    je endofcount</span><br><span class="line">    cmp al,30H</span><br><span class="line">    jb notnum</span><br><span class="line">    cmp al,39H</span><br><span class="line">    ja notnum</span><br><span class="line">isnum:</span><br><span class="line">    inc cx</span><br><span class="line">    jmp beginofcount</span><br><span class="line">notnum:</span><br><span class="line">    jmp beginofcount</span><br><span class="line">endofcount:</span><br><span class="line">    add cx,30H</span><br><span class="line">    mov dx,offset finish2</span><br><span class="line">    mov ah,09H</span><br><span class="line">    int 21H</span><br><span class="line">    mov dx,0H</span><br><span class="line">    mov dl,cl</span><br><span class="line">    mov ah,02H</span><br><span class="line">    int 21H</span><br><span class="line">    mov dx,offset finish3</span><br><span class="line">    mov ah,09H</span><br><span class="line">    int 21H</span><br><span class="line">    ;跳回开始位置</span><br><span class="line">    jmp beginofread</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">exit:</span><br><span class="line">    mov ah,4CH</span><br><span class="line">    int 21H</span><br><span class="line">CODE ENDS</span><br><span class="line">END START</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>运行结果:</strong><br><img src="https://pb01.s3.bitiful.net/35.png" alt="avatar"></p>]]></content>
      
      
      <categories>
          
          <category> xdu </category>
          
      </categories>
      
      
        <tags>
            
            <tag> lab </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>西电计科微机原理实验一(详细注释版)</title>
      <link href="/2023/12/02/2023-12-2-%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86%E5%AE%9E%E9%AA%8C1/"/>
      <url>/2023/12/02/2023-12-2-%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86%E5%AE%9E%E9%AA%8C1/</url>
      
        <content type="html"><![CDATA[<h3 id="西电计科微机原理实验一-详细注释版"><a href="#西电计科微机原理实验一-详细注释版" class="headerlink" title="西电计科微机原理实验一(详细注释版)"></a>西电计科微机原理实验一(详细注释版)</h3><p><strong>环境</strong>:VSCode+MASM/TASM插件(建议使用相同环境,学校机房环境有点老,可能会出一些奇怪的问题)</p><p><img src="https://pb01.s3.bitiful.net/32.png" alt="avatar"></p><h4 id="实验要求"><a href="#实验要求" class="headerlink" title="实验要求"></a>实验要求</h4><ol><li>打印Hello World!</li><li>打印输入的姓名</li><li>打印输入的id</li><li>将输入的字符转换成ASCII码</li><li>输入q或Q退出程序</li></ol><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br></pre></td><td class="code"><pre><span class="line">stack segment</span><br><span class="line">    db 128 dup(0)</span><br><span class="line">stack ends</span><br><span class="line"></span><br><span class="line">data segment</span><br><span class="line">   msg1 db &#x27;hello world!$&#x27;       ; 定义一个字符串，表示“hello world!”</span><br><span class="line">   msg2 db &#x27;please input your name:$&#x27;  ; 定义一个字符串，表示提示输入名字</span><br><span class="line">   msg3 db &#x27;please input your id:$&#x27;    ; 定义一个字符串，表示提示输入ID</span><br><span class="line">   msg4 db &#x27;please input a char:$&#x27;    ; 定义一个字符串，表示提示输入一个字符</span><br><span class="line">   buffer db &#x27;$&#x27;                  ; 定义一个字符串，表示空字符串 </span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">assume cs:code,ds:data</span><br><span class="line"></span><br><span class="line">start:</span><br><span class="line">; 将数据段地址赋值给AX</span><br><span class="line">    mov ax,data</span><br><span class="line">    ; 将AX的值赋值给DS</span><br><span class="line">    mov ds,ax</span><br><span class="line">    ; 将AX的值赋值给ES</span><br><span class="line">    mov es,ax</span><br><span class="line"></span><br><span class="line">; 显示“hello world!”字符串</span><br><span class="line">    lea dx, msg1</span><br><span class="line">    mov ah, 9</span><br><span class="line">    int 21h  ;中断调用指令</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">; 回车换行</span><br><span class="line">    mov dl, 0Dh  </span><br><span class="line">    mov ah, 2  </span><br><span class="line">    int 21h</span><br><span class="line">mov dl, 0Ah</span><br><span class="line">    mov ah, 2</span><br><span class="line">    int 21h</span><br><span class="line"></span><br><span class="line">; 提示输入名字</span><br><span class="line">    lea dx, msg2</span><br><span class="line">    mov ah, 9</span><br><span class="line">    int 21h</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    ; 输入名字</span><br><span class="line">    lea dx, buffer</span><br><span class="line">    mov ah, 0Ah</span><br><span class="line">    mov al, 00h</span><br><span class="line">    int 21h</span><br><span class="line">    ; 清空缓冲区</span><br><span class="line">    xor bx,bx</span><br><span class="line">mov bl,buffer[1]</span><br><span class="line">mov buffer[bx+2],&#x27;$&#x27;</span><br><span class="line"></span><br><span class="line">    ;换行</span><br><span class="line">mov dl,0Dh</span><br><span class="line">mov ah,2</span><br><span class="line">int 21h</span><br><span class="line">mov dl,0Ah</span><br><span class="line">mov ah,2</span><br><span class="line">int 21h</span><br><span class="line"></span><br><span class="line">;输出姓名</span><br><span class="line">lea dx, offset [buffer+2]      </span><br><span class="line">    mov ah, 09h</span><br><span class="line">    int 21h</span><br><span class="line"></span><br><span class="line">;换行</span><br><span class="line">mov dl,0Dh</span><br><span class="line">mov ah,2</span><br><span class="line">int 21h</span><br><span class="line">mov dl,0Ah</span><br><span class="line">mov ah,2</span><br><span class="line">int 21h</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">; 提示输入ID</span><br><span class="line">lea dx, msg3</span><br><span class="line">mov ah,9</span><br><span class="line">int 21h</span><br><span class="line"></span><br><span class="line">; 提示输入ID的后续操作</span><br><span class="line">lea dx,buffer</span><br><span class="line">mov ah,0Ah</span><br><span class="line">mov al,00h</span><br><span class="line">int 21h</span><br><span class="line"> </span><br><span class="line">;清空缓冲区</span><br><span class="line">xor bx,bx</span><br><span class="line">mov bl,buffer[1]</span><br><span class="line">mov buffer[bx+2],&#x27;$&#x27;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">;换行</span><br><span class="line">mov dl,0Dh</span><br><span class="line">mov ah,2</span><br><span class="line">int 21h</span><br><span class="line">mov dl,0Ah</span><br><span class="line">mov ah,2</span><br><span class="line">int 21h</span><br><span class="line"></span><br><span class="line">; 显示ID</span><br><span class="line">lea dx, offset [buffer+2]      </span><br><span class="line">    mov ah, 09h</span><br><span class="line">    int 21h</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">cmpq:</span><br><span class="line">mov dl, 0Dh</span><br><span class="line">    mov ah, 2</span><br><span class="line">    int 21h</span><br><span class="line">    mov dl, 0Ah</span><br><span class="line">    mov ah, 2</span><br><span class="line">    int 21h</span><br><span class="line">; 显示提示输入字符的字符串</span><br><span class="line">lea dx,msg4</span><br><span class="line">mov ah,9</span><br><span class="line">int 21h</span><br><span class="line">    </span><br><span class="line">    mov dl, 0Dh</span><br><span class="line">    mov ah, 2</span><br><span class="line">    int 21h</span><br><span class="line">    mov dl, 0Ah</span><br><span class="line">    mov ah, 2</span><br><span class="line">    int 21h</span><br><span class="line">;输入一个字符并回显</span><br><span class="line">    mov ah, 1</span><br><span class="line">    int 21h ;执行中断1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    cmp al, &#x27;q&#x27;</span><br><span class="line">    ;若等于q，则跳转到ending</span><br><span class="line">    je ending</span><br><span class="line">    cmp al, &#x27;Q&#x27;</span><br><span class="line">    ;若等于Q，则跳转到ending</span><br><span class="line">    je ending</span><br><span class="line">;低八位存入bl</span><br><span class="line">    mov bl, al</span><br><span class="line">;高八位存入bh</span><br><span class="line">    mov bh, al</span><br><span class="line">    ;回车+换行</span><br><span class="line">    mov dl, 0Dh</span><br><span class="line">    mov ah, 2</span><br><span class="line">    int 21h</span><br><span class="line">    mov dl, bh</span><br><span class="line">    mov ah, 2</span><br><span class="line">    int 21h</span><br><span class="line">    mov dl, 9</span><br><span class="line">    mov ah, 2</span><br><span class="line">    and bl, 0F0h  ;取bl高四位</span><br><span class="line">    mov cl, 4  </span><br><span class="line">;右移4位,高4位变为低4位</span><br><span class="line">    shr bl, cl</span><br><span class="line">    cmp bl, 9</span><br><span class="line">    ja alph1</span><br><span class="line">;处理数字</span><br><span class="line">numb1:</span><br><span class="line">;转换为ascii码</span><br><span class="line">    add bl, &#x27;0&#x27;</span><br><span class="line">    mov dl, bl</span><br><span class="line">    mov ah, 2</span><br><span class="line">    int 21h ;执行2号中断,显示输出</span><br><span class="line">    jmp low4</span><br><span class="line">alph1:</span><br><span class="line">;转换为ascii码</span><br><span class="line">    add bl, 37h</span><br><span class="line">    mov dl, bl</span><br><span class="line">    mov ah, 2</span><br><span class="line">    int 21h</span><br><span class="line">low4:</span><br><span class="line">    and bh, 0Fh  ;取低四位</span><br><span class="line">    cmp bh, 9</span><br><span class="line">    ja alph2</span><br><span class="line">numb2:</span><br><span class="line">    add bh, &#x27;0&#x27;  ;加0</span><br><span class="line">    mov dl, bh</span><br><span class="line">    mov ah, 2</span><br><span class="line">    int 21h</span><br><span class="line">    jmp cmpq</span><br><span class="line">alph2:</span><br><span class="line">    add bh, 37h ;加A</span><br><span class="line">    mov dl, bh</span><br><span class="line">    mov ah, 2</span><br><span class="line">    int 21h </span><br><span class="line">    jmp cmpq</span><br><span class="line">ending:</span><br><span class="line">    ;回车+换行</span><br><span class="line">    mov dl, 0Dh</span><br><span class="line">    mov ah, 2</span><br><span class="line">    int 21h</span><br><span class="line">    mov dl, 0Ah</span><br><span class="line">    mov ah, 2</span><br><span class="line">    int 21h</span><br><span class="line">    ;终止程序</span><br><span class="line">    mov ax, 4c00h</span><br><span class="line">    int 21h</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><h4 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h4><p><img src="https://pb01.s3.bitiful.net/33.png" alt="avatar"></p>]]></content>
      
      
      <categories>
          
          <category> xdu </category>
          
      </categories>
      
      
        <tags>
            
            <tag> lab </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DDD是什么？</title>
      <link href="/2023/12/01/2023-12-1-DDD%E6%9E%B6%E6%9E%84-1/"/>
      <url>/2023/12/01/2023-12-1-DDD%E6%9E%B6%E6%9E%84-1/</url>
      
        <content type="html"><![CDATA[<h2 id="DDD是什么？"><a href="#DDD是什么？" class="headerlink" title="DDD是什么？"></a>DDD是什么？</h2><p>DDD 是领域驱动设计（Domain-Driven Design）的缩写，这是一种主要软件开发方法，由 Eric Evans 在他的书《领域驱动设计：软件核心复杂性应对之道》（Domain-Driven Design: Tackling Complexity in the Heart of Software）中首次提出。</p><p>DDD 主要关注于创建与业务领域紧密相关的软件模型，以确保软件能够准确地解决实际问题。</p><p>DDD 的核心理念包括以下几个方面：</p><ol><li><p><strong>领域模型（Domain Model）：</strong><br>领域模型是对特定业务领域知识的精确表述，它包括业务中的实体（Entities）、值对象（Value Objects）、服务（Services）、聚合（Aggregates）、聚合根（Aggregate Roots）等概念。领域模型是DDD的核心，它反映了业务专家的语言和决策。</p></li><li><p><strong>统一语言（Ubiquitous Language）：</strong><br>统一语言是开发团队与业务专家共同使用的语言，它在整个项目中保持一致。统一语言确保所有人都对业务概念有着相同的理解，减少沟通成本和误解。</p></li><li><p><strong>限界上下文（Bounded Context）：</strong><br>限界上下文是明确界定的系统边界，在这个边界内部有一套统一的模型和语言。不同的限界上下文之间可能有不同的模型，它们通过上下文映射（Context Mapping）来进行交互和集成。</p></li><li><p><strong>聚合（Aggregate）：</strong><br>聚合是一组相关对象的集合，它们被视为数据修改的单元。每个聚合都有一个聚合根，它是外部对象与聚合内部对象交互的唯一入口。</p></li><li><p><strong>领域服务（Domain Services）：</strong><br>当某些行为不自然属于任何实体或值对象时，这些行为可以被定义为领域服务。领域服务通常表示领域中的一些操作或业务逻辑。</p></li><li><p><strong>应用服务（Application Services）：</strong><br>应用服务是软件的一部分，它们协调领域对象来执行任务。它们负责应用程序的工作流程，但不包含业务规则或知识。</p></li><li><p><strong>基础设施（Infrastructure）：</strong><br>基础设施包括为领域模型提供持久化机制（如数据库）、消息传递、应用程序的配置等技术组件。</p></li><li><p><strong>领域事件（Domain Events）：</strong><br>领域事件是领域中发生的有意义的业务事件，它们可以触发其他子系统的反应或流程。</p></li></ol><p>DDD 的目标是通过将软件的关注点集中在<strong>核心领域</strong>上，并通过丰富的领域模型来管理复杂性，从而提高软件的<strong>质量和维护性</strong>。DDD 强调与业务专家的紧密合作，以确保软件解决方案能够准确反映<strong>业务需求</strong>。通过这种方法，软件开发团队可以创建出更加灵活、可扩展且与业务紧密结合的系统。</p><p>其中DDD所提到的软件设计方法涵盖了：范式、模型、框架、方法论，主要活动包括建模、测试、工程、开发、部署、维护。</p><p>软件设计方法是指一系列用于指导软件开发过程的原则、概念和实践。这些方法通常包括范式、模型、框架和方法论。下面我将分别介绍这些概念以及软件设计的主要活动。</p><h4 id="范式-Paradigms"><a href="#范式-Paradigms" class="headerlink" title="范式 (Paradigms)"></a>范式 (Paradigms)</h4><p>范式是指软件设计和开发的基本风格或哲学。它通常定义了编程的基本原则和模式。常见的软件设计范式包括：</p><ul><li><strong>结构化编程</strong>：强调程序结构的重要性，使用顺序、选择和循环控制结构。</li><li><strong>面向对象编程 (OOP)</strong>：基于对象的概念，将数据和处理数据的方法封装在一起。</li><li><strong>函数式编程</strong>：将计算视为数学函数的评估，避免状态改变和可变数据。</li><li><strong>事件驱动编程</strong>：以事件为中心，响应用户操作、消息或其他系统事件。</li></ul><h4 id="模型-Models"><a href="#模型-Models" class="headerlink" title="模型 (Models)"></a>模型 (Models)</h4><p>模型是对软件系统的抽象表示，用于帮助理解、设计和测试系统。常用的软件设计模型包括：</p><ul><li><strong>UML (统一建模语言)</strong>：一套图形化的建模语言，用于描述、设计和文档化软件项目。</li><li><strong>ER模型 (实体-关系模型)</strong>：用于数据库设计，描述数据的实体及其之间的关系。</li><li><strong>状态机模型</strong>：描述系统可能的状态、事件和在这些事件发生时的转换。</li></ul><h4 id="框架-Frameworks"><a href="#框架-Frameworks" class="headerlink" title="框架 (Frameworks)"></a>框架 (Frameworks)</h4><p>框架是一套预先制定的代码库和组件，用于提供软件开发的骨架。框架通常定义了应用程序的结构，提供了一组通用的功能和模式，以便开发者可以专注于实现特定的业务逻辑。例如：</p><ul><li><strong>Spring Framework</strong>：一个用于Java应用程序的全面编程和配置模型。</li><li><strong>Ruby on Rails</strong>：一个用于快速开发Web应用程序的Ruby框架。</li><li><strong>Django</strong>：一个高级Python Web框架，鼓励快速开发和干净、实用的设计。</li></ul><h4 id="方法论-Methodologies"><a href="#方法论-Methodologies" class="headerlink" title="方法论 (Methodologies)"></a>方法论 (Methodologies)</h4><p>方法论是指一套指导软件开发过程的规则和实践。它包括项目管理、开发流程、团队协作等方面。常见的软件开发方法论有：</p><ul><li><strong>敏捷开发</strong>：一种迭代和增量的开发方法，强调灵活性和客户合作。</li><li><strong>Scrum</strong>：一种敏捷开发框架，用于管理复杂的软件和产品开发。</li><li><strong>瀑布模型</strong>：一种线性顺序的开发方法，将项目分为不同阶段，每个阶段完成后才能进入下一个阶段。</li></ul><h4 id="主要活动"><a href="#主要活动" class="headerlink" title="主要活动"></a>主要活动</h4><p>软件设计的主要活动包括：</p><ul><li><strong>建模 (Modeling)</strong> ：通过创建模型来表示系统的不同方面，如使用UML图来描述系统架构。</li><li><strong>测试 (Testing)</strong> ：确保软件的质量，包括单元测试、集成测试、系统测试和验收测试。</li><li><strong>工程 (Engineering)</strong> ：应用工程原则和实践来构建软件，包括需求分析、设计、实现和测试。</li><li><strong>开发 (Development)</strong> ：编写代码和实现功能，将设计转化为实际的软件产品。</li><li><strong>部署 (Deployment)</strong> ：将软件发布到生产环境，使其可供用户使用。</li><li><strong>维护 (Maintenance)</strong> ：在软件发布后对其进行更新和改进，修复缺陷，提升性能和适应性。</li></ul><p>每个活动都是软件开发生命周期的重要组成部分，它们相互依赖，共同确保软件项目的成功。</p><h4 id="维护-Maintenance"><a href="#维护-Maintenance" class="headerlink" title="维护 (Maintenance)"></a>维护 (Maintenance)</h4><p>软件维护是在软件发布后进行的活动，包括以下几个方面：</p><ul><li><strong>纠错</strong>：修复软件中发现的缺陷或错误。</li><li><strong>适应性维护</strong>：修改软件以适应环境的变化，如操作系统升级、硬件更换等。</li><li><strong>完善性维护</strong>：增加新功能或提升性能，以满足用户新的或变化的需求。</li><li><strong>预防性维护</strong>：改进软件内部结构，以防止潜在的问题发生，提高软件的可维护性和可扩展性。</li></ul><p>软件维护是一个持续的过程，它确保软件能够长期有效地服务于用户。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>软件设计方法是一个复杂的领域，涉及多种概念和实践。范式提供了设计哲学，模型帮助我们理解和抽象系统，框架为开发提供了基础结构，方法论指导整个开发过程。软件设计的主要活动——建模、测试、工程、开发、部署和维护——是确保软件项目成功的关键步骤。每个活动都需要专业知识和技能，以及对应的工具和技术的支持。通过这些活动的协同工作，软件工程师能够交付高质量、满足用户需求的软件产品。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DDD </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>解决no main manifest attribute, in app.jar(Docker)</title>
      <link href="/2023/11/25/Docker(3)/"/>
      <url>/2023/11/25/Docker(3)/</url>
      
        <content type="html"><![CDATA[<h3 id="解决no-main-manifest-attribute-in-app-jar"><a href="#解决no-main-manifest-attribute-in-app-jar" class="headerlink" title="解决no main manifest attribute, in app.jar"></a>解决no main manifest attribute, in app.jar</h3><p><strong>环境:SpringBoot2.6.13+java8</strong></p><ul><li><strong>重点</strong>:pom.xml文件是IDEA自动配的</li></ul><p>我在将一个SpringBoot程序打包成镜像部署到Docker容器上,然后执行run命令启动容器:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --rm springboot-test:1.0</span><br></pre></td></tr></table></figure><p>springboot-test:1.0是我的镜像</p><p>出现报错:<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">no main manifest attribute, in app.jar</span><br></pre></td></tr></table></figure><br>我排查出来问题就在pom.xml文件中我画红线的这一句<br><img src="https://pb01.s3.bitiful.net/30.png" alt="avatar"></p><p>改为下面这张图这样就好了<br><img src="https://pb01.s3.bitiful.net/31.png" alt="avatar"></p><p>完整的pom.xml文件如下:<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.example<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>DockerTest<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>DockerTest<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">description</span>&gt;</span>DockerTest<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">project.reporting.outputEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.reporting.outputEncoding</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">spring-boot.version</span>&gt;</span>2.6.13<span class="tag">&lt;/<span class="name">spring-boot.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring-boot.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.8.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">source</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">encoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">encoding</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring-boot.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">mainClass</span>&gt;</span>com.example.dockertest.DockerTestApplication<span class="tag">&lt;/<span class="name">mainClass</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">layout</span>&gt;</span>JAR<span class="tag">&lt;/<span class="name">layout</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">id</span>&gt;</span>repackage<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">goal</span>&gt;</span>repackage<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>自定义构建Docker镜像</title>
      <link href="/2023/11/25/Docker(2)/"/>
      <url>/2023/11/25/Docker(2)/</url>
      
        <content type="html"><![CDATA[<h3 id="自定义构建Docker镜像"><a href="#自定义构建Docker镜像" class="headerlink" title="自定义构建Docker镜像"></a>自定义构建Docker镜像</h3><p>实际上所有常用的应用程序都有对应的镜像，我们只需要下载这些镜像然后就可以使用了，而不需要自己去手动安装，顶多需要进行一些特别的配置。但是我们程序员在遇到小众项目的时候，可能没有提供镜像，这时就要我们手动去安装，接着我们就来看看如何构建我们自己的Docker镜像。构建镜像有两种方式，一种是使用commit命令来完成，还有一种是使用Dockerfile来完成，我们先来看第一种。</p><p>这里我们就做一个简单的例子，比如我们现在想要在Ubuntu的base镜像中安装Java环境，并将其打包为新的镜像（这个新的镜像就是一个包含Java8环境的Ubuntu系统镜像）</p><h4 id="第一种-commit命令-不推荐"><a href="#第一种-commit命令-不推荐" class="headerlink" title="第一种:commit命令(不推荐)"></a>第一种:commit命令(不推荐)</h4><p>拉取Ubuntu镜像<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull ubuntu</span><br></pre></td></tr></table></figure><br><img src="https://pb01.s3.bitiful.net/16.png" alt="avatar"><br>接着启动Ubuntu：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it ubuntu</span><br></pre></td></tr></table></figure><br><img src="https://pb01.s3.bitiful.net/17.png" alt="avatar"></p><p>更新apt<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt update</span><br></pre></td></tr></table></figure><br><img src="https://pb01.s3.bitiful.net/18.png" alt="avatar"><br>apt安装java环境<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt install openjdk-8-jdk</span><br></pre></td></tr></table></figure><br>安装完成后查看一下<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -version</span><br></pre></td></tr></table></figure><br><img src="https://pb01.s3.bitiful.net/19.png" alt="avatar"></p><p>退出Ubuntu到Docker环境下<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exit</span><br></pre></td></tr></table></figure><br><img src="https://pb01.s3.bitiful.net/20.png" alt="avatar"><br>查看所有容器<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps -a</span><br></pre></td></tr></table></figure><br><img src="https://pb01.s3.bitiful.net/21.png" alt="avatar"></p><p>使用commit命令将容器打包为新的镜像：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker commit 容器名称/ID 新的镜像名称</span><br></pre></td></tr></table></figure><br><img src="https://pb01.s3.bitiful.net/22.png" alt="avatar"></p><p>查看镜像<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker images</span><br></pre></td></tr></table></figure><br><img src="https://pb01.s3.bitiful.net/23.png" alt="avatar"></p><p>可以看到我们的镜像已经被打包好了</p><p>这个方式存在一个问题,就是如果这个镜像不是我们构建的或者构建完过了一段时间,我们就不知道具体这个镜像的构建过程,也就是说<strong>我们不能确保这个镜像百分百安全</strong>,这就引出了下面这种构建方式</p><h4 id="第二种-Dockerfile-推荐"><a href="#第二种-Dockerfile-推荐" class="headerlink" title="第二种:Dockerfile(推荐)"></a>第二种:Dockerfile(推荐)</h4><p>首先新建一个名为Dockerfile的文件：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">touch Dockerfile</span><br></pre></td></tr></table></figure></p><p>vim打开Dockerfile进行编辑<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi Dockerfile</span><br></pre></td></tr></table></figure><br><img src="https://pic-bed-1c9.pages.dev/img/24.png" alt="avatar"></p><p>Dockerfile内部需要我们编写多种指令来告诉Docker我们的镜像的相关信息</p><p>首先我们需要使用FROM指令来选择当前镜像的基础镜像（必须以这个指令开始），这里我们直接使用ubuntu作为基础镜像即可，当然如果不需要任何基础镜像的话，直接使用scratch表示从零开始构建:<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FROM ubuntu</span><br></pre></td></tr></table></figure><br>在容器中运行RUN命令来安装Java环境了<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RUN apt update</span><br><span class="line">RUN apt install -y openjdk-8-jdk</span><br></pre></td></tr></table></figure><br><img src="https://pb01.s3.bitiful.net/25.png" alt="avatar"><br>每条指令执行之后，都会生成一个新的镜像层</p><p>退出并保存,运行build命令构建镜像<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t 镜像名称 构建目录</span><br></pre></td></tr></table></figure><br><img src="https://pb01.s3.bitiful.net/26.png" alt="avatar"><br>执行后，Docker会在构建目录中寻找Dockerfile文件，然后开始依次执行Dockerfile中的指令：</p><p>—tag, -t: 镜像的名字及标签，通常 name:tag 或者 name 格式；可以在一次构建中为一个镜像设置多个标签。构建目录的.代表当前目录</p><p>构建完成后查看本地镜像<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker images</span><br></pre></td></tr></table></figure><br><img src="https://pb01.s3.bitiful.net/27.png" alt="avatar"></p><p>我们可以使用history命令来查看构建历史<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker history ubuntu-java2:latest</span><br></pre></td></tr></table></figure><br><img src="https://pb01.s3.bitiful.net/28.png" alt="avatar"><br><img src="https://pb01.s3.bitiful.net/29.png" alt="avatar"><br>我们可以看到每一步我们构建的命令都成为了一个镜像,我们可以清楚地知道这个镜像是如何被构建的,而使用第一种方式构建的镜像是看不到具体构建命令的</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker安装与镜像下载和删除(优雅)</title>
      <link href="/2023/11/23/Docker(1)/"/>
      <url>/2023/11/23/Docker(1)/</url>
      
        <content type="html"><![CDATA[<h3 id="Docker安装与镜像下载和删除-优雅"><a href="#Docker安装与镜像下载和删除-优雅" class="headerlink" title="Docker安装与镜像下载和删除(优雅)"></a>Docker安装与镜像下载和删除(优雅)</h3><hr><p><strong>环境:Ubuntu 22.04.3 LTS</strong></p><hr><h4 id="Docker安装"><a href="#Docker安装" class="headerlink" title="Docker安装"></a>Docker安装</h4><p>首先安装一些工具：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install ca-certificates curl gnupg lsb-release</span><br></pre></td></tr></table></figure></p><p>接着安装官方的GPG key：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo mkdir -p /etc/apt/keyrings</span><br><span class="line"></span><br><span class="line">curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /etc/apt/keyrings/docker.gpg</span><br></pre></td></tr></table></figure></p><p>最后将Docker的库添加到apt资源列表中：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable&quot; | sudo tee /etc/apt/sources.list.d/docker.list &gt; /dev/null</span><br></pre></td></tr></table></figure></p><p>接着我们更新一次apt：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update</span><br></pre></td></tr></table></figure></p><p>最后安装Docker CE版本：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install docker-ce</span><br></pre></td></tr></table></figure></p><p>最后我们将当前用户添加到docker用户组中：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo usermod -aG docker &lt;用户名&gt;</span><br></pre></td></tr></table></figure></p><p>配置好后，我们先退出SSH终端，然后重新连接就可以生效了。</p><h4 id="镜像相关操作"><a href="#镜像相关操作" class="headerlink" title="镜像相关操作"></a>镜像相关操作</h4><p>下载镜像:<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull repository:tag</span><br></pre></td></tr></table></figure></p><p>实际上一个镜像的名称是由两部分组成的，一个是repository，还有一个是tag，一般情况下约定repository就是镜像名称，tag作为版本，默认为latest，表示最新版本。</p><p>镜像下载之后会存放在本地，要启动这个镜像的容器，实际上就像我们之前那样，输入run命令就可以了(以hello-world镜像为例)：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run hello-world</span><br></pre></td></tr></table></figure><p>启动之后，会使用当前镜像自动创建一个容器，我们可以输入ps命令来查看当前容器的容器列表：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps -a</span><br></pre></td></tr></table></figure><p>注意后面要加一个-a表示查看所有容器（其他选项可以使用-h查看），如果不加的话，只会显示当前正在运行的容器。</p><p>可以看到容器列表中有我们刚刚创建的hello-world（注意同一个镜像可以创建多个容器），每个容器都有一个随机生成的容器ID写在最前面，后面是容器的创建时间以及当前的运行状态，最后一列是容器的名称，在创建容器时，名称可以由我们指定也可以自动生成，这里就是自动生成的。</p><p>当一个镜像有多个容器时，我们可以手动指定名称启动，在使用run命令时，添加—name参数即可：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --name=名称 hello-world</span><br></pre></td></tr></table></figure></p><p>我们可以手动开启处于停止状态的容器：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker start 容器名称/容器ID</span><br></pre></td></tr></table></figure><br><strong>容器名称可以使用Tab键自动补全,ID可以只输入前三位</strong>(一般不会重复,除非容器非常多,这时就得保证输入的ID的前n位可以唯一标识这个ID)</p><p>如果想要停止容器直接输入stop命令就可以了：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker stop 容器名称/容器ID</span><br></pre></td></tr></table></figure></p><p>或是重启：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker restart 容器名称/容器ID</span><br></pre></td></tr></table></figure></p><h4 id="删除容器"><a href="#删除容器" class="headerlink" title="删除容器"></a>删除容器</h4><p>如果我们不需要使用容器了，那么可以将容器删除，但是注意只有容器处于非运行状态时才可以删除：</p><p>先查看所有容器:<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps -a</span><br></pre></td></tr></table></figure></p><p>如果要删除的容器仍在运行,先将其停止:<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker stop 容器名称/容器ID</span><br></pre></td></tr></table></figure></p><p>最后删除:<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rm 容器名称/容器ID</span><br></pre></td></tr></table></figure></p><p>如果想要强制删除容器,加上-f就行:<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rm -f 容器名称/容器ID</span><br></pre></td></tr></table></figure><br>无论容器是否正在运行中或者已停止，都可被强制删除！</p><h4 id="删除镜像"><a href="#删除镜像" class="headerlink" title="删除镜像"></a>删除镜像</h4><p>先查看Docker中的镜像:<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker images</span><br></pre></td></tr></table></figure></p><p><strong>想要删除镜像就得先删除此镜像的全部容器</strong></p><p><strong>只有容器处于非运行状态时才可以删除</strong></p><p>先查看所有容器:<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps -a</span><br></pre></td></tr></table></figure></p><p>如果要删除的容器仍在运行,先将其停止:<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker stop 容器名称/容器ID</span><br></pre></td></tr></table></figure></p><p>删除容器:<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rm 容器名称/容器ID</span><br></pre></td></tr></table></figure></p><p>删除镜像:<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rmi 镜像ID</span><br></pre></td></tr></table></figure><br><strong>镜像ID也是输入前三位就好</strong></p><p>如果想要强制删除镜像,加上-f就行:<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rmi -f 镜像ID</span><br></pre></td></tr></table></figure><br>镜像中的容器状态为已停止或已删除的才能被强制删除，同时对应的容器也会被删除。若容器还在运行中，删除镜像会报错！</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JWT详解</title>
      <link href="/2023/11/18/JWT%E8%AF%A6%E8%A7%A3/"/>
      <url>/2023/11/18/JWT%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h3 id="JWT详解"><a href="#JWT详解" class="headerlink" title="JWT详解"></a>JWT详解</h3><p><a href="https://jwt.io/introduction" style="color: #177cb0; text-decoration: underline;text-decoration-style: dotted;">JWT官网</a></p><p><img src="https://pb01.s3.bitiful.net/13.png" alt="avatar"></p><h4 id="什么是JWT"><a href="#什么是JWT" class="headerlink" title="什么是JWT"></a>什么是JWT</h4><p>JWT的全称是Json Web Token。是基于RFC 7519开放标准的，它定义了一种紧凑且独立的方式，用于在各方之间以 JSON 对象的形式<strong>安全地</strong>传输信息。此信息可以用作验证和相互信任，因为它是经过数字签名的。JWT 可以使用密钥（使用 HMAC 算法）或使用 RSA 或 ECDSA 的公钥/私钥对进行签名。</p><p>JWT由三部分组成:<strong>Header（标头）</strong>,<strong>Payload（有效载荷）</strong>,<strong>Signature（签名）</strong>,中间用点分开,即<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Header.Payload.signature</span><br></pre></td></tr></table></figure></p><p>我们可以使用<a href="https://jwt.io/#debugger-io" style="color: #177cb0; text-decoration: underline;text-decoration-style: dotted;">jwt.io.Debugger</a>去解码,验证和生成JWT令牌.</p><p><img src="https://pb01.s3.bitiful.net/14.png" alt="avatar"></p><h4 id="Header（标头）"><a href="#Header（标头）" class="headerlink" title="Header（标头）"></a>Header（标头）</h4><p>Header通常由两部分组成：令牌的类型（JWT）和所使用的签名算法（如HMAC SHA256或RSA）。<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;alg&quot;</span><span class="punctuation">:</span> <span class="string">&quot;HS256&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;typ&quot;</span><span class="punctuation">:</span> <span class="string">&quot;JWT&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><br>然后，这个JSON被Base64Url编码，形成JWT的第一部分。</p><h4 id="Payload（有效载荷）"><a href="#Payload（有效载荷）" class="headerlink" title="Payload（有效载荷）"></a>Payload（有效载荷）</h4><p>Payload包含声明。声明是关于实体（通常是用户）和附加数据的声明(claims),一般存放一些不敏感的信息，比如用户名、权限、角色等</p><p>声明(claims)也分为三种:Registered claim,Public claims和Private claims.</p><ul><li><p>Registered claim(已注册声明):其中包含了一组官方定义好的推荐的声明(共7个),有</p><ol><li>iss (issuer)：签发人</li><li>exp (expiration time)：过期时间</li><li>sub (subject)：主题</li><li>aud (audience)：受众</li><li>nbf (Not Before)：生效时间</li><li>iat (Issued At)：签发时间</li><li>jti (JWT ID)：编号</li></ol></li><li><p>Public claims(公开声明):声明名称可以由使用JWT的人员随意定义.然而，<strong>为了防止冲突</strong>，任何新的声明名称都应该要么在IANA“JSON Web令牌声明”注册中心注册,要么得包含防撞(冲突)名称.</p></li><li><p>Private claims(私有声明):JWT的生产者和消费者一致同意使用的不是已注册声明和公开声明的声明.私有声明可能会发生冲突，应该小心使用.</p></li></ul><p>例如:<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;sub&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1234567890&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;John Doe&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;admin&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><br>然后，这个JSON被Base64Url编码，形成JWT的第二部分。</p><p>应当注意的是，对于已签名的令牌，这些信息虽然受到保护，不会被篡改，但任何人都可以读取。除非经过加密，否则不要将机密信息放入JWT的有效载荷或标头元素中。</p><h4 id="Signature（签名）"><a href="#Signature（签名）" class="headerlink" title="Signature（签名）"></a>Signature（签名）</h4><p>要创建签名部分，您必须获取编码的标头、编码的有效载荷、秘钥、标头中指定的算法，并对其进行签名。</p><p>例如，如果要使用HMAC SHA256算法，则将以以下方式创建签名：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">HMACSHA256</span>(</span><br><span class="line">  <span class="title function_">base64UrlEncode</span>(header) + <span class="string">&quot;.&quot;</span> +</span><br><span class="line">  <span class="title function_">base64UrlEncode</span>(payload),</span><br><span class="line">  secret)</span><br></pre></td></tr></table></figure></p><p>签名用于验证消息在发送过程中没有更改，在使用私钥签名的令牌的情况下，它还可以验证JWT的发送者是否就是它所说的那个人。</p><h4 id="JWT是如何工作的"><a href="#JWT是如何工作的" class="headerlink" title="JWT是如何工作的?"></a>JWT是如何工作的?</h4><p>在认证的时候，当用户用他们的凭证成功登录以后，一个JWT将会被返回。此后，token 就是用户凭证了，你必须非常小心以防止出现安全问题。一般而言，你保存令牌的时候不应该超过你所需要它的时间。</p><p>无论何时用户想要访问受保护的路由或者资源的时候，用户代理（通常是浏览器）都应该带上 JWT，典型的，通常放在 Authorization header 中，用 Bearer schema。</p><p>header 应该看起来是这样的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Authorization</span>: <span class="title class_">Bearer</span> <span class="variable constant_">JWT</span></span><br></pre></td></tr></table></figure><p>服务器上的受保护的路由将会检查 Authorization header 中的 JWT 是否有效，如果有效，则用户可以访问受保护的资源。如果 JWT 包含足够多的必需的数据，那么就可以减少对某些操作的数据库查询的需要，尽管可能并不总是如此。</p><p>如果 token  是在授权头（Authorization header）中发送的，那么跨源资源共享 (CORS) 将不会成为问题，因为它不使用 cookie。</p><p><strong>JWT认证流程如下:</strong></p><p><img src="https://pb01.s3.bitiful.net/15.png" alt="avatar"></p><ol><li>用户登录账号，客户端发送 POST 请求，将用户名和密码发送到服务器。</li><li>服务器会验证用户的登录信息（用户名、密码），校验成功的时候会使用 JWT 算法，生成一个 token （已签名的 token）。</li><li>服务器返回给客户端 HTTP 200 状态码，并且会将生成的 token 放在请求头中（header），并不能放在请求体（body）中。客户端一般会将接收到的 token 存储在浏览器的 localstorage,cookie 或者 sessionstorage 。</li><li>当客户端之后再向服务器发送请求的时候，都会携带上 token （当然也可以将 token 放在 cookie 中自动发送，但是这样不能跨域发送）。最好的做法是将 token 放在 http 的头信息中的 Authorization 字段中（这是官方文档建议的做法）。</li><li>当服务器接收到请求的时候，接收到了 token 信息，这时候 JWT 进行反向验证，验证对应的 token 是否正确。</li><li>当服务器交验完毕后，会产生两种情况：第一种情况就是校验成功，返回给客户端 HTTP 200 状态码和客户端所需要的数据；第二种情况就是校验失败，这个时候会返回给客户端 HTTP 401 状态码，Not authorized。</li></ol><h4 id="JWT的优缺点"><a href="#JWT的优缺点" class="headerlink" title="JWT的优缺点"></a>JWT的优缺点</h4><ul><li><p><strong>无状态</strong>:JWT 自身包含了身份验证所需要的所有信息，因此，我们的服务器不需要存储 Session 信息。这显然增加了系统的可用性和伸缩性，大大减轻了服务端的压力。</p></li><li><p><strong>单点登录友好</strong>:使用 Session 进行身份认证的话，实现单点登录，需要我们把用户的 Session 信息保存在一台电脑上，并且还会遇到常见的 Cookie 跨域的问题。但是，使用 JWT 进行认证的话， JWT 被保存在客户端，不会存在这些问题。</p></li><li><p><strong>有效避免了 CSRF 攻击</strong>:CSRF 攻击需要依赖 Cookie ，Session 认证中 Cookie 中的 SessionID 是由浏览器发送到服务端的，只要发出请求，Cookie 就会被携带。借助这个特性，即使黑客无法获取你的 SessionID，只要让你误点攻击链接，就可以达到攻击效果.JWT一般会选择存放在 localStorage 中。前端的每一个请求后续都会附带上这个 JWT，整个过程压根不会涉及到 Cookie。</p></li><li><p><strong>不可控</strong>:我们想要在JWT有效期内废弃一个JWT或者更改它的权限的话，并不会立即生效，通常需要等到有效期过后才可以。</p></li></ul><h4 id="JWT身份认证常见问题及解决办法"><a href="#JWT身份认证常见问题及解决办法" class="headerlink" title="JWT身份认证常见问题及解决办法"></a>JWT身份认证常见问题及解决办法</h4><h5 id="注销登录等场景下JWT还有效"><a href="#注销登录等场景下JWT还有效" class="headerlink" title="注销登录等场景下JWT还有效"></a><strong>注销登录等场景下JWT还有效</strong></h5><ol><li><p><strong>将JWT存入内存数据库</strong><br> 将 JWT存入数据库中，Redis 内存数据库在这里是不错的选择。如果需要让某个 JWT 失效就直接从 Redis 中删除这个 JWT 即可。但是，这样会导致每次使用 JWT 发送请求都要先从 DB 中查询 JWT 是否存在的步骤，而且违背了 JWT 的无状态原则。</p></li><li><p><strong>黑名单机制</strong><br> 使用内存数据库比如 Redis 维护一个黑名单，如果想让某个 JWT 失效的话就直接将这个 JWT 加入到 黑名单 即可。然后，每次使用 JWT 进行请求的话都会先判断这个 JWT 是否存在于黑名单中。缺点和第一种方案相同。</p></li><li><p><strong>修改密钥(Secret)</strong><br> 我们为每个用户都创建一个专属密钥，如果我们想让某个 JWT 失效，我们直接修改对应用户的密钥即可。但是，这样相比于前两种引入内存数据库带来了危害更大：</p><ul><li><p>如果服务是分布式的，则每次发出新的 JWT 时都必须在多台机器同步密钥。为此，你需要将密钥存储在数据库或其他外部服务中，这样和 Session 认证就没太大区别了。</p></li><li><p>如果用户同时在两个浏览器打开系统，或者在手机端也打开了系统，如果它从一个地方将账号退出，那么其他地方都要重新进行登录，这是不可取的</p></li></ul></li><li><p><strong>保持令牌的有效期限短并经常轮换</strong><br> 很简单的一种方式。但是，会导致用户登录状态不会被持久记录，而且需要用户经常登录。</p></li></ol><h5 id="JWT的续签问题"><a href="#JWT的续签问题" class="headerlink" title="JWT的续签问题"></a><strong>JWT的续签问题</strong></h5><ol><li><p><strong>类似于Session认证中的做法</strong><br> 假设服务端给的 JWT 有效期设置为 30 分钟，服务端每次进行校验时，如果发现 JWT 的有效期马上快过期了，服务端就重新生成 JWT 给客户端。客户端每次请求都检查新旧 JWT，如果不一致，则更新本地的 JWT。这种做法的问题是仅仅在快过期的时候请求才会更新 JWT ,对客户端不是很友好。</p></li><li><p><strong>每次请求都返回新JWT</strong><br> 这种方案的的思路很简单，但是，开销会比较大</p></li><li><p><strong>JWT有效期设置到半夜</strong><br> 这种方案是一种折中的方案，保证了大部分用户白天可以正常登录，适用于对安全性要求不高的系统。</p></li><li><p><strong>用户登录返回两个JWT</strong></p><p> 第一个是 accessJWT ，它的过期时间为JWT本身的过期时间比如半个小时，另外一个是refreshJWT它的过期时间更长一点比如为 1 天。客户端登录后，将 accessJWT 和 refreshJWT 保存在本地，每次访问将 accessJWT 传给服务端。服务端校验 accessJWT 的有效性，如果过期的话，就将 refreshJWT 传给服务端。如果有效，服务端就生成新的 accessJWT 给客户端。否则，客户端就重新登录即可。</p><p> 这种方案的不足是：</p><ul><li>需要客户端来配合；</li><li>用户注销的时候需要同时保证两个 JWT 都无效；</li><li>重新请求获取 JWT 的过程中会有短暂 JWT 不可用的情况（可以通过在客户端设置定时器，当 accessJWT 快过期的时候，提前去通过 refreshJWT 获取新的 accessJWT）。</li></ul></li></ol><h4 id="References"><a href="#References" class="headerlink" title="References"></a>References</h4><ol><li><p>JWT官方文档:本文开头有</p></li><li><p><a href="https://javaguide.cn/system-design/security/jwt-intro.html" style="color: #177cb0; text-decoration: underline;text-decoration-style: dotted;">JavaGuide</a></p></li><li><p><a href="https://ruanyifeng.com/blog/2018/07/json_web_token-tutorial.html" style="color: #177cb0; text-decoration: underline;text-decoration-style: dotted;">JSON Web Token 入门教程</a><br>……</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>RabbitMQ报错:unable to perform an operation on node &#39;rabbit@ubuntuserver&#39;</title>
      <link href="/2023/11/15/rabbitmq%E6%8A%A5%E9%94%99/"/>
      <url>/2023/11/15/rabbitmq%E6%8A%A5%E9%94%99/</url>
      
        <content type="html"><![CDATA[<h3 id="RabbitMQ报错-unable-to-perform-an-operation-on-node-‘rabbit-ubuntuserver’"><a href="#RabbitMQ报错-unable-to-perform-an-operation-on-node-‘rabbit-ubuntuserver’" class="headerlink" title="RabbitMQ报错:unable to perform an operation on node ‘rabbit@ubuntuserver’"></a>RabbitMQ报错:unable to perform an operation on node ‘rabbit@ubuntuserver’</h3><hr><p><strong>环境:VMware+Ubuntu</strong></p><hr><h4 id="出问题的前置步骤"><a href="#出问题的前置步骤" class="headerlink" title="出问题的前置步骤:"></a>出问题的前置步骤:</h4><ol><li>安装Erlang<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install erlang</span><br></pre></td></tr></table></figure></li><li>安装RabbitMQ<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install rabbitmq-server</span><br></pre></td></tr></table></figure></li><li>开启RabbitMQ管理面板<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo rabbitmq-plugins enable rabbitmq_management</span><br></pre></td></tr></table></figure></li><li>在查看RabbitMQ状态或为RabbitMQ添加用户时,即:<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo rabbitmqctl status</span><br></pre></td></tr></table></figure>或<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo rabbitmqctl add_user 用户名 密码</span><br></pre></td></tr></table></figure>出现<strong>Error:unable to perform an operation on node ‘rabbit@ubuntuserver’</strong></li></ol><p><img src="https://pb01.s3.bitiful.net/9.png" alt="avatar"><br><img src="https://pb01.s3.bitiful.net/10.png" alt="avatar"></p><h4 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法:"></a>解决方法:</h4><p><strong>首先,切换到root权限</strong></p><ol><li>为root设置密码<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo passwd root</span><br></pre></td></tr></table></figure>设置密码</li><li>切换到root权限<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">su root</span><br></pre></td></tr></table></figure>然后输入密码便可切换到root权限</li></ol><p><strong>更改/etc/hosts文件</strong></p><ol><li>先进根目录<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd /</span><br></pre></td></tr></table></figure></li><li>进入etc目录<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd /etc</span><br></pre></td></tr></table></figure></li><li>在hosts文件中添加主机名映射<br>vim打开hosts文件<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi hosts</span><br></pre></td></tr></table></figure>键入i转换到insert模式<br><img src="https://pb01.s3.bitiful.net/11.png" alt="avatar"></li></ol><p>在127.0.0.1 localhost 后面添加你的主机名,就是root@xxxx中的xxxx,我的是ubuntuserver</p><p><img src="https://pb01.s3.bitiful.net/12.png" alt="avatar"></p><p>最后按Esc键退出insert模式,输入:wq保存并退出</p><p>然后再执行上面的操作就一切正常了</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RabbitMQ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis分布式锁</title>
      <link href="/2023/11/13/Redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/"/>
      <url>/2023/11/13/Redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/</url>
      
        <content type="html"><![CDATA[<h2 id="Redis分布式锁"><a href="#Redis分布式锁" class="headerlink" title="Redis分布式锁"></a>Redis分布式锁</h2><hr><h4 id="分布式锁的由来"><a href="#分布式锁的由来" class="headerlink" title="分布式锁的由来"></a>分布式锁的由来</h4><p>在传统单机部署的情况下，可以使用Java并发处理相关的API(如ReentrantLcok或synchronized)进行互斥控制。</p><p>但是在分布式系统后，由于分布式系统多线程、多进程并且分布在不同机器上，这将使原单机并发控制锁策略失效，为了解决这个问题就需要一种跨JVM的互斥机制来控制共享资源的访问，这就是分布式锁的由来。</p><p>当多个进程不在同一个系统中，就需要用分布式锁控制多个进程对资源的访问。最实际的应用场景应该是控制库存，比如说电商平台防止商品超卖这类场景。</p><h4 id="分布式锁需要满足的条件"><a href="#分布式锁需要满足的条件" class="headerlink" title="分布式锁需要满足的条件"></a>分布式锁需要满足的条件</h4><ul><li><p><strong>互斥性</strong>：任意时刻，只能有一个客户端获取锁，不能同时有两个客户端获取到锁。</p></li><li><p><strong>安全性</strong>：锁只能被持有该锁的客户端删除，不能由其它客户端删除。</p></li><li><p><strong>不会死锁</strong>：获取锁的客户端因为某些原因（如down机等）而未能释放锁，也能保证后续其他客户端能加锁。</p></li><li><p><strong>容错</strong>：只要大部分的Redis节点正常运行，客户端就可以加锁和解锁。</p></li></ul><h4 id="Redis分布式锁实现一-setnx-expire"><a href="#Redis分布式锁实现一-setnx-expire" class="headerlink" title="Redis分布式锁实现一(setnx+expire)"></a>Redis分布式锁实现一(setnx+expire)</h4><p>实现命令如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">seynx key value</span><br><span class="line">expire key time</span><br></pre></td></tr></table></figure><p>setnx其实就是set if not exists的意思,仅当key不存在的时候才能进行插入,执行完操作后可以将锁删除<br>expire命令为锁设置过期时间</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">del key</span><br></pre></td></tr></table></figure><p>这样就能重新对key的值进行操作了</p><h4 id="Redis分布式锁实现二-set"><a href="#Redis分布式锁实现二-set" class="headerlink" title="Redis分布式锁实现二(set)"></a>Redis分布式锁实现二(set)</h4><p>上面那种实现方式存在一种问题,如果在执行完 setnx 之后,执行expire之前,服务器 crash 或重启了导致加的这个锁没有设置过期时间，就会导致死锁的情况（别的线程就永远获取不到锁了）</p><p>代码如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jedis.set(lockKey, requestId, SET_IF_NOT_EXIST, SET_WITH_EXPIRE_TIME, expireTime)</span><br></pre></td></tr></table></figure><p> <strong>第一个为</strong>key，我们使用key来当锁，因为key是唯一的。</p><p><strong>第二个</strong>为value，我们传的是requestId，很多人可能不明白，有key作为锁不就够了吗，为什么还要用到value？原因就是我们在上面讲到分布式锁要满足的条件时,提到的<strong>安全性</strong>这一条，通过给value赋值为requestId，我们就知道这把锁是哪个请求加的了，在解锁的时候就可以有依据。requestId可以使用UUID.randomUUID().toString()方法生成。</p><p><strong>第三个</strong>为nxxx，这个参数我们填的是NX，意思是SET IF NOT EXIST，即当key不存在时，我们进行set操作；若key已经存在，则不做任何操作；</p><p><strong>第四个</strong>为expx，这个参数我们传的是PX，意思是我们要给这个key加一个过期的设置，具体时间由第五个参数决定。</p><p><strong>第五个</strong>为time，与第四个参数相呼应，代表key的过期时间。<br>总的来说，执行上面的set()方法就只会导致两种结果：1. 当前没有锁（key不存在），那么就进行加锁操作，并对锁设置个有效期，同时value表示加锁的客户端。2. 已有锁存在，不做任何操作。</p><p>我们的加锁代码满足我们可靠性里描述的三个条件:</p><ul><li><strong>首先</strong>，set()加入了NX参数，可以保证如果已有key存在，则函数不会调用成功，也就是只有一个客户端能持有锁，满足<strong>互斥性</strong>。</li><li><strong>其次</strong>，由于我们对锁设置了过期时间，即使锁的持有者后续发生崩溃而没有解锁，锁也会因为到了过期时间而自动解锁（即key被删除），<strong>不会发生死锁</strong>。</li><li><strong>最后</strong>，因为我们将value赋值为requestId，代表加锁的客户端请求标识，那么在客户端在解锁的时候就可以进行校验是否是同一个客户端。<strong>这样就避免了锁被别的线程删除</strong>,保证了<strong>安全性</strong>。</li></ul><h4 id="Redis分布式锁实现三-Redission框架"><a href="#Redis分布式锁实现三-Redission框架" class="headerlink" title="Redis分布式锁实现三(Redission框架)"></a>Redis分布式锁实现三(Redission框架)</h4><p>方案二还是可能存在<strong>锁过期释放，业务没执行完</strong>的问题。有些小伙伴认为，稍微把锁过期时间设置长一些就可以啦。其实问题的关键就在于我们不确定要设置多长时间,时间太短就会导致锁过期释放，业务没执行完,时间太长就会使系统运行效率下降. 我们设想一下，是否可以给获得锁的线程，开启一个定时守护线程，每隔一段时间检查锁是否还存在，存在则对锁的过期时间延长，防止锁过期提前释放。Redission框架帮我们实现了此功能,名为<strong>看门狗</strong></p><p><img src="https://pb01.s3.bitiful.net/7.png" alt="avatar"></p><p>只要线程一加锁成功，就会启动一个watch dog看门狗，它是一个后台线程，会每隔10秒检查一下，如果线程1还持有锁，那么就会不断的延长锁key的生存时间。因此，Redisson就是使用Redisson解决了<strong>锁过期释放，业务没执行完</strong>问题。</p><p><img src="https://pb01.s3.bitiful.net/8.png" alt="avatar"></p><p>如果线程一在Redis的master节点上拿到了锁，但是加锁的key还没同步到slave节点。恰好这时，master节点发生故障，一个slave节点就会升级为master节点。线程二就可以获取同个key的锁啦，但线程一也已经拿到锁了，锁的安全性就没了。</p><p>这个时候我们就可以使用RedLock，它的思路是，在多个Redis服务器上保存锁，只需要超过半数的Redis服务器获取到锁，那么就真的获取到锁了，这样就算挂掉一部分节点，也能保证正常运行，保证了<strong>容错性</strong>。</p><h4 id="References"><a href="#References" class="headerlink" title="References"></a>References</h4><ul><li><a href="https://www.cnblogs.com/wangyingshuo/p/14510524.html" style="color: #177cb0; text-decoration: underline;text-decoration-style: dotted;">Redis实现分布式锁的7种方案，及正确使用姿势！</a></li><li>Redis笔记 by itbaima</li><li><a href="https://developer.aliyun.com/article/307547" style="color: #177cb0; text-decoration: underline;text-decoration-style: dotted;">Redis 分布式锁的正确实现方式（ Java 版 ）</a></li><li><a href="https://www.runoob.com/redis/redis-tutorial.html" style="color: #177cb0; text-decoration: underline;text-decoration-style: dotted;">菜鸟教程|Redis教程</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis与分布式</title>
      <link href="/2023/11/13/redis%E4%B8%8E%E5%88%86%E5%B8%83%E5%BC%8F/"/>
      <url>/2023/11/13/redis%E4%B8%8E%E5%88%86%E5%B8%83%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="Redis与分布式"><a href="#Redis与分布式" class="headerlink" title="Redis与分布式"></a>Redis与分布式</h2><hr><h3 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h3><p><img src="https://pb01.s3.bitiful.net/4.png" alt="avatar"></p><h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><p>有多个redis服务器,只有一个<strong>主节点(Master)</strong>,其余均为<strong>从节点(Slave)</strong>,主节点可以进行读写操作,从节点只能进行读操作.数据的复制是单向的,从节点中的内容是由主节点中复制过来的(直接复制/间接复制).</p><p>一个主节点可以有多个从节点(也可以没有),一个从节点只能有一个主节点.redis主从复制是<code>异步复制</code>,主节点收到写命令,先写到内部缓冲区,然后异步发送给从节点.</p><h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><p>在配置文件中添加从节点信息：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">slaveof 主节点IP 主节点端口</span><br></pre></td></tr></table></figure></p><h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><ul><li><strong>数据冗余</strong>：主从复制实现了数据的热备份，是持久化之外的一种数据冗余方式。</li><li><strong>故障恢复</strong>：当主节点出现问题时，可以由从节点提供服务，实现快速的故障恢复；实际上是一种服务的冗余。</li><li><strong>负载均衡</strong>：在主从复制的基础上，配合读写分离，可以由主节点提供写服务，由从节点提供读服务（即写Redis数据时应用连接主节点，读Redis数据时应用连接从节点），分担服务器负载；尤其是在写少读多的场景下，通过多个从节点分担读负载，可以大大提高Redis服务器的并发量。</li><li><strong>高可用基石</strong>：除了上述作用以外，主从复制还是哨兵和集群能够实施的基础，因此说主从复制是Redis高可用的基础。</li></ul><h4 id="Redis为什么需要主从复制"><a href="#Redis为什么需要主从复制" class="headerlink" title="Redis为什么需要主从复制"></a>Redis为什么需要主从复制</h4><p>使用Redis主从复制的原因主要是单台Redis节点存在以下的局限性：</p><ul><li><p>Redis虽然读写的速度都很快，单节点的Redis能够支撑<strong>每秒请求数(QPS)</strong>大概在5w左右，如果上千万的用户访问，Redis就承载不了，成为了高并发的瓶颈。</p></li><li><p>单节点的Redis不能保证高可用，当Redis因为某些原因意外宕机时，会导致缓存不可用</p></li><li><p>CPU的利用率上，单台Redis实例只能利用单个核心，这单个核心在面临海量数据的存取和管理工作时压力会非常大。</p></li></ul><h4 id="主从复制流程"><a href="#主从复制流程" class="headerlink" title="主从复制流程"></a>主从复制流程</h4><p>第一次同步一般是<code>全量同步</code>,后续基于已经建立的TCP长连接进行<code>增量同步</code>,如果TCP长连接断开,再次连接后进行同步,主节点会判断从节点要读的数据是否在repl_backlog_buffer缓冲区中,如果在,则进行增量同步,否则进行全量同步.</p><ol><li><p>若启动一个Slave机器进程，则它会向Master机器发送一个“sync command”命令，请求同步连接。</p></li><li><p>无论是第一次连接还是重新连接，Master机器都会启动一个后台进程，将数据快照保存到数据文件中（执行rdb操作），同时Master还会记录修改数据的所有命令并缓存在数据文件中。</p></li><li><p>后台进程完成缓存操作之后，Maste机器就会向Slave机器发送数据文件，Slave端机器将数据文件保存到硬盘上，然后将其加载到内存中，接着Master机器就会将修改数据的所有操作一并发送给Slave端机器。若Slave出现故障导致宕机，则恢复正常后会自动重新连接。</p></li><li><p>Master机器收到Slave端机器的连接后，将其完整的数据文件发送给Slave端机器，如果Mater同时收到多个Slave发来的同步请求，则Master会在后台启动一个进程以保存数据文件，然后将其发送给所有的Slave端机器，确保所有的Slave端机器都正常。</p></li></ol><h4 id="主从数据不一致"><a href="#主从数据不一致" class="headerlink" title="主从数据不一致"></a>主从数据不一致</h4><p><strong>原因</strong>: 主从节点的命令复制是<code>异步</code>执行的.在主从节点命令传播阶段，主节点收到新的写命令后，会发送给从节点。但是，主节点并不会等到从节点实际执行完命令后，再把结果返回给客户端，而是主节点自己在本地执行完命令后，就会向客户端返回结果了。如果从节点还没有执行主节点同步过来的命令，主从节点间的数据就不一致了.</p><p><strong>如何应对</strong>:<br>第一种方法，尽量保证主从节点间的网络连接状况良好，避免主从节点在不同的机房。</p><p>第二种方法，可以开发一个外部程序来监控主从节点间的复制进度。具体做法：</p><ul><li><p>Redis 的 INFO replication 命令可以查看主节点接收写命令的进度信息（master_repl_offset）和从节点复制写命令的进度信息（slave_repl_offset），所以，我们就可以开发一个监控程序，先用 INFO replication 命令查到主、从节点的进度，然后，我们用 master_repl_offset 减去 slave_repl_offset，这样就能得到从节点和主节点间的复制进度差值了。</p></li><li><p>如果某个从节点的进度差值大于我们预设的阈值，我们可以让客户端不再和这个从节点连接进行数据读取，这样就可以减少读到不一致数据的情况。不过，为了避免出现客户端和所有从节点都不能连接的情况，我们需要把复制进度差值的阈值设置得大一些。</p></li></ul><h4 id="主从切换如何减少数据丢失？"><a href="#主从切换如何减少数据丢失？" class="headerlink" title="主从切换如何减少数据丢失？"></a>主从切换如何减少数据丢失？</h4><p>主从切换过程中，产生数据丢失的情况有两种：</p><ul><li>异步复制同步丢失</li><li>集群产生脑裂数据丢失<br>我们不可能保证数据完全不丢失，只能做到使得尽量少的数据丢失。</li></ul><p><strong>异步复制同步丢失</strong><br>当客户端发送写请求给主节点的时候，客户端会返回 ok，接着主节点将写请求异步同步给各个从节点，但是如果此时主节点还没来得及同步给从节点时发生了断电，那么主节点内存中的数据会丢失。</p><p>Redis 配置里有一个参数 <code>min-slaves-max-lag</code>，表示一旦所有的从节点数据复制和同步的延迟都超过了 min-slaves-max-lag 定义的值，那么主节点就会拒绝接收任何请求。</p><p>假设将 min-slaves-max-lag 配置为 10s 后，根据目前 master-&gt;slave 的复制速度，如果数据同步完成所需要时间超过10s，就会认为 master 未来宕机后损失的数据会很多，master 就拒绝写入新请求。这样就能将 master 和 slave 数据差控制在10s内，即使 master 宕机也只是这未复制的 10s 数据。</p><p>那么对于客户端，当客户端发现 master 不可写后，我们可以采取降级措施，将数据暂时写入本地缓存和磁盘中，在一段时间（等 master 恢复正常）后重新写入 master 来保证数据不丢失，也可以将数据写入 kafka 消息队列，等 master 恢复正常，再隔一段时间去消费 kafka 中的数据，让将数据重新写入 master 。</p><p><strong>集群产生脑裂数据丢失</strong><br>如果主节点的网络突然发生了问题，它与所有的从节点都失联了，但是此时的主节点和客户端的网络是正常的，这个客户端并不知道 Redis 内部已经出现了问题，还在照样的向这个失联的主节点写数据（过程A），此时这些数据被主节点缓存到了缓冲区里，因为主从节点之间的网络问题，这些数据都是无法同步给从节点的。</p><p>这时，哨兵也发现主节点失联了，它就认为主节点挂了（但实际上主节点正常运行，只是网络出问题了），于是哨兵就会在从节点中选举出一个 leader 作为主节点，这时集群就有两个主节点了 —— 脑裂出现了。</p><p>这时候网络突然好了，哨兵因为之前已经选举出一个新主节点了，它就会把旧主节点降级为从节点（A），然后从节点（A）会向新主节点请求数据同步，因为第一次同步是全量同步的方式，此时的从节点（A）会清空掉自己本地的数据，然后再做全量同步。所以，之前客户端在过程 A 写入的数据就会丢失了，也就是集群产生脑裂数据丢失的问题。</p><p><code>方案</code>:当主节点发现「从节点下线的数量太多」，或者「网络延迟太大」的时候，那么主节点会禁止写操作，直接把错误返回给客户端。</p><p>在 Redis 的配置文件中有两个参数我们可以设置：</p><p>min-slaves-to-write x，主节点必须要有至少 x 个从节点连接，如果小于这个数，主节点会禁止写数据。<br>min-slaves-max-lag x，主从数据复制和同步的延迟不能超过 x 秒，如果主从同步的延迟超过 x 秒，主节点会禁止写数据。<br>我们可以把 min-slaves-to-write 和 min-slaves-max-lag 这两个配置项搭配起来使用，分别给它们设置一定的阈值，假设为 N 和 T。</p><p>这两个配置项组合后的要求是，主节点连接的从节点中至少有 N 个从节点，「并且」主节点进行数据复制时的 ACK 消息延迟不能超过 T 秒，否则，主节点就不会再接收客户端的写请求了。</p><p>即使原主节点是假故障，它在假故障期间也无法响应哨兵心跳，也不能和从节点进行同步，自然也就无法和从节点进行 ACK 确认了。这样一来，min-slaves-to-write 和 min-slaves-max-lag 的组合要求就无法得到满足，原主节点就会被限制接收客户端写请求，客户端也就不能在原主节点中写入新数据了。</p><p>等到新主节点上线时，就只有新主节点能接收和处理客户端请求，此时，新写的数据会被直接写到新主节点中。而原主节点会被哨兵降为从节点，即使它的数据被清空了，也不会有新数据丢失。我再来给你举个例子。</p><p>假设我们将 min-slaves-to-write 设置为 1，把 min-slaves-max-lag 设置为 12s，把哨兵的 down-after-milliseconds 设置为 10s，主节点因为某些原因卡住了 15s，导致哨兵判断主节点客观下线，开始进行主从切换。同时，因为原主节点卡住了 15s，没有一个从节点能和原主节点在 12s 内进行数据复制，原主节点也无法接收客户端请求了。这样一来，主从切换完成后，也只有新主节点能接收请求，不会发生脑裂，也就不会发生数据丢失的问题了。</p><h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><p><strong>过期key如何处理?</strong><br>主节点中的key被删除或淘汰,会模拟一条删除命令发送给从节点,从节点收到这条命令后,会删除对应的key.</p><p><strong>为了避免网络恢复时,频繁进行全量同步,该怎么做?</strong><br>要将repl_backlog_buffer缓冲区调得大一些,至少为主节点一秒写的数据量<em>重连时间</em>2.</p><p><strong>如何分摊主服务器的压力?</strong><br>将一部分从节点升级为其他从节点的主节点</p><p><strong>怎么判断 Redis 某个节点是否正常工作？</strong><br>Redis 判断节点是否正常工作，基本都是通过互相的 ping-pong 心态检测机制，如果有一半以上的节点去 ping 一个节点的时候没有 pong 回应，集群就会认为这个节点挂掉了，会断开与这个节点的连接。</p><h3 id="哨兵模式"><a href="#哨兵模式" class="headerlink" title="哨兵模式"></a>哨兵模式</h3><p>经过之前的学习，我们发现，实际上最关键的还是主节点，因为一旦主节点出现问题，那么整个主从系统将无法写入，因此，我们得想一个办法，处理一下<strong>主节点故障</strong>的情况。实际上我们可以参考Spring的服务治理模式，比如Nacos和Eureka，所有的服务都会被实时监控，那么只要出现问题，肯定是可以及时发现的，并且能够采取响应的补救措施，这就是我们即将介绍的哨兵：</p><p><img src="https://pb01.s3.bitiful.net/5.png" alt="avatar"></p><p><strong>哨兵</strong> (<strong>也是一个Redis服务器</strong>)会对所有的节点进行监控，如果发现主节点出现问题，那么会立即让从节点进行投票，选举一个新的主节点出来，这样就不会由于主节点的故障导致整个系统不可写（注意要实现这样的功能最小的系统必须是一主一从，再小的话就没有意义了）</p><p>那么怎么启动一个哨兵呢？我们只需要稍微修改一下配置文件(conf文件)即可，修改：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sentinel monitor name ip port number</span><br></pre></td></tr></table></figure></p><p>其他配置都是次要的,我们都采用默认配置.</p><p>其中第一个和第二个是固定，第三个是为监控对象名称，随意，后面就是主节点的相关信息，包括IP地址和端口，最后的一个数字的意思是当有number个哨兵判断主节点挂掉后,我们认为主节点真的挂掉了,一般number是要比哨兵数量少的,因为哨兵也可能挂掉.如果number等于哨兵数量,如果哨兵挂掉了一个,那么就永远判断不出主节点是否挂了.number一般设置为哨兵数量/2+1.</p><p><strong>不需要填写其他哨兵信息,如何组成哨兵集群?</strong><br>哨兵节点之间通过redis的发布者/订阅者机制互相发现,主节点有一个<em>sentinel</em>:hello频道,哨兵可以将自己的ip和端口信息发到这个频道上,这样其他哨兵就可以通过订阅这个频道来获取到这个哨兵的信息,这样哨兵之间就可以建立网络,哨兵集群就形成了.</p><p><img src="https://pb01.s3.bitiful.net/167.webp" alt="avatar"></p><p>哨兵模式启动后，会自动监控主节点，然后还会显示那些节点是作为从节点存在的。如果主节点挂了,一个哨兵认为其主观下线,会向其他哨兵发起投票,如果认为主节点主观下线的数量到达设置得数,则认为主节点客观下线.之后就要进行主从切换了,哨兵节点中投票选出执行的leader.候选者为判断主节点客观下线的哨兵,候选者可以给自己投票,其他哨兵不能给自己投票,每个哨兵只有一次投票机会.任何候选者想要成为leader需要满足两个条件:</p><ul><li>拿到半数以上的票</li><li>票数大于设置的number值</li></ul><p>之后leader会选出新的主节点,将从节点指向新主节点,通知客户端主节点更换,将旧主节点变为从节点</p><p><strong>那么，这个选新主节点的规则是怎样的呢？是在所有的从节点中随机选取还是遵循某种规则呢？</strong></p><ol><li><p>首先会根据优先级进行选择，可以在配置文件中进行配置，添加replica-priority配置项（默认是100），越小表示优先级越高。</p></li><li><p>如果优先级一样，那就选择偏移量最大的</p></li><li><p>要是还选不出来，那就选择runid（启动时随机生成的）最小的。</p></li></ol><h3 id="集群模式"><a href="#集群模式" class="headerlink" title="集群模式"></a>集群模式</h3><p>如果我们服务器的内存不够用了，但是现在我们的Redis又需要继续存储内容，那么这个时候就可以利用集群来实现扩容。</p><p>因为单机的内存容量最大就那么多，已经没办法再继续扩展了，但是现在又需要存储更多的内容，这时我们就可以让N台机器上的Redis来分别存储各个部分的数据（每个Redis可以存储1/N的数据量），这样就实现了容量的横向扩展。同时每台Redis还可以配一个从节点，这样就可以更好地保证数据的安全性。</p><p><img src="https://pb01.s3.bitiful.net/6.png" alt="avatar"></p><h4 id="集群的作用"><a href="#集群的作用" class="headerlink" title="集群的作用"></a>集群的作用</h4><ul><li><p><strong>数据分区</strong>：数据分区(或称数据分片)是集群最核心的功能。</p><ul><li>集群将数据分散到多个节点，一方面突破了Redis单机内存大小的限制，存储容量大大增加；另一方面每个主节点都可以对外提供读服务和写服务，大大提高了集群的响应能力。</li><li>Redis单机内存大小受限问题，在介绍主从复制时有提及；例如，如果单机内存太大，bgsave和bgrewriteaof的fork操作可能导致主进程阻塞，主从环境下主机切换时可能导致从节点长时间无法提供服务，全量复制阶段主节点的复制缓冲区可能溢出。</li></ul></li><li><p><strong>高可用</strong>：集群支持主从复制和主节点的自动故障转移（与哨兵类似）；当任一节点发生故障时，集群仍然可以对外提供服务。</p></li></ul><p>那么问题来，现在用户来了一个写入的请求，数据该写到哪个节点上呢？我们来研究一下<strong>集群的机制</strong>：</p><p>首先，一个Redis集群包含16384个插槽，集群中的每个Redis 实例负责维护一部分插槽以及插槽所映射的键值数据，那么这个插槽是什么意思呢？</p><p>实际上，插槽就是键的Hash计算后的一个结果，注意这里出现了计算机网络中的<strong>CRC循环冗余校验</strong>，这里采用CRC16，能得到16个bit位的数据，也就是说算出来之后结果是0-65535之间，再进行取模，得到最终结果：</p><p><strong>Redis key的路由计算公式</strong>：</p><script type="math/tex; mode=display">slot = CRC16(key)\mod  16384</script><p>结果的值是多少，就应该存放到对应维护的Redis下，比如Redis节点1负责0-25565的插槽，而这时客户端插入了一个新的数据a=10，a在Hash计算后结果为666，那么a就应该存放到1号Redis节点中。</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微服务CAP原则</title>
      <link href="/2023/11/12/CAP%E5%8E%9F%E5%88%99/"/>
      <url>/2023/11/12/CAP%E5%8E%9F%E5%88%99/</url>
      
        <content type="html"><![CDATA[<h2 id="微服务CAP原则"><a href="#微服务CAP原则" class="headerlink" title="微服务CAP原则"></a>微服务CAP原则</h2><hr><p>CAP原则又称CAP定理，指的是在一个分布式系统中，存在<strong>Consistency（一致性）、Availability（可用性）、Partition tolerance（分区容错性）</strong>，三者不可同时保证，最多只能保证其中的两者。</p><ul><li><p>一致性（C）：在分布式系统中的所有数据备份，在同一时刻都是同样的值（所有的节点无论何时访问都能拿到最新的值）</p></li><li><p>可用性（A）：系统中非故障节点收到的每个请求都必须得到响应（比如我们之前使用的服务降级和熔断，其实就是一种维持可用性的措施，虽然服务返回的是没有什么意义的数据，但是不至于用户的请求会被服务器忽略）</p></li><li><p>分区容错性（P）：一个分布式系统里面，节点之间组成的网络本来应该是连通的，然而可能因为一些故障（比如网络丢包等，这是很难避免的），使得有些节点之间不连通了，整个网络就分成了几块区域，数据就散布在了这些不连通的区域中（这样就可能出现某些被分区节点存放的数据访问失败，我们需要来容忍这些不可靠的情况）</p></li></ul><p>总的来说，数据存放的节点数越多，分区容错性就越高，但是要复制更新的次数就越多，一致性就越难保证。同时为了保证一致性，更新所有节点数据所需要的时间就越长，那么可用性就会降低。</p><p>所以说，只能存在以下三种方案：</p><h3 id="AC-可用性-一致性"><a href="#AC-可用性-一致性" class="headerlink" title="AC 可用性+一致性"></a>AC 可用性+一致性</h3><p>要同时保证可用性和一致性，代表着某个节点数据更新之后，需要立即将结果通知给其他节点，并且要尽可能的快，这样才能及时响应保证可用性，这就对网络的稳定性要求非常高，但是实际情况下，网络很容易出现丢包等情况，并不是一个可靠的传输，如果需要避免这种问题，就只能将节点全部放在一起，但是这显然违背了分布式系统的概念，所以对于我们的分布式系统来说，很难接受。</p><h3 id="CP-一致性-分区容错性"><a href="#CP-一致性-分区容错性" class="headerlink" title="CP 一致性+分区容错性"></a>CP 一致性+分区容错性</h3><p>为了保证一致性，那么就得将某个节点的最新数据发送给其他节点，并且需要等到所有节点都得到数据才能进行响应，同时有了分区容错性，那么代表我们可以容忍网络的不可靠问题，所以就算网络出现卡顿，那么也必须等待所有节点完成数据同步，才能进行响应，因此就会导致服务在一段时间内完全失效，所以可用性是无法得到保证的。</p><h3 id="AP-可用性-分区容错性"><a href="#AP-可用性-分区容错性" class="headerlink" title="AP 可用性+分区容错性"></a>AP 可用性+分区容错性</h3><p>既然CP可能会导致一段时间内服务得不到任何响应，那么要保证可用性，就只能放弃节点之间数据的高度统一，也就是说可以在数据不统一的情况下，进行响应，因此就无法保证一致性了。虽然这样会导致拿不到最新的数据，但是只要数据同步操作在后台继续运行，一定能够在某一时刻完成所有节点数据的同步，那么就能实现最终一致性，所以AP实际上是最能接受的一种方案。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>工厂模式</title>
      <link href="/2023/11/06/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
      <url>/2023/11/06/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><p><img src="https://pb01.s3.bitiful.net/1.png" alt="avatar"></p><p>工厂模式主要可分为三种:简单工厂,工厂方法,抽象工厂</p><h3 id="简单工厂"><a href="#简单工厂" class="headerlink" title="简单工厂"></a>简单工厂</h3><p><strong>提供实现方法的工厂</strong></p><p>简单工厂主要有使用工厂的对象,工厂,具体实现类以及从实现类中抽象出的接口,如下图:</p><p><img src="https://pb01.s3.bitiful.net/2.png" alt="avatar"></p><p>简单工厂的<strong>问题</strong>在于当具体实现类的增加,工厂的代码也得不断修改(增加),违反了开闭原则(OOP)</p><h3 id="工厂方法"><a href="#工厂方法" class="headerlink" title="工厂方法"></a>工厂方法</h3><p><strong>提供工厂的方法</strong></p><p>具体来说有:工厂接口,产品接口,产品实现类,工厂实现类,使用类</p><ul><li>每类产品都有自己的工厂,符合单一职责原则;</li><li>这类产品变化只改变这类产品的工厂,更符合开闭原则</li></ul><p>但工厂方法也有自己的问题,就是每当新增一类产品时,就得多增加一个工厂,当产品种类非常多时,就会有非常多的工厂,这会导致代码变得复杂和难以维护.</p><h3 id="抽象工厂"><a href="#抽象工厂" class="headerlink" title="抽象工厂"></a>抽象工厂</h3><p><strong>提供组合工厂的方法</strong></p><p>具体来说有:抽象工厂接口,工厂,产品接口,产品实现</p><p>举个例子,我要代工生产的产品有手机,电脑,路由器…等产品,这些产品的制造方法在抽象工厂接口被定义,根据具体的品牌分别创建不同品牌的工厂,像小米工厂,华为工厂,vivo工厂等,产品的制造方法在具体品牌的工厂实现,这些产品实现也实现了具体的产品接口,华为手机实现手机接口,制造华为手机的方法返回华为手机,实现制造手机接口,每种产品都是如此.</p><p>优点：</p><ul><li>可以确保同一工厂生成的产品相互匹配.</li><li>可以避免客户端和具体产品代码的耦合.</li><li>单一职责原则:可以将产品生成代码抽取到同一位置， 使得代码易于维护。</li><li>开闭原则:向应用程序中引入新产品变体时， 无需修改客户端代码</li></ul><p>缺点:</p><ul><li>全新品类产品难以扩展:本来只准备生产手机,电脑,路由器,现在又要添加手表这类产品,从抽象工厂开始的所有往底层所有代码都要修改.</li></ul>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面向对象六大设计原则</title>
      <link href="/2023/11/04/%E9%9D%A2%E7%9B%B8%E5%AF%B9%E8%B1%A1%E5%85%AD%E5%A4%A7%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/"/>
      <url>/2023/11/04/%E9%9D%A2%E7%9B%B8%E5%AF%B9%E8%B1%A1%E5%85%AD%E5%A4%A7%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/</url>
      
        <content type="html"><![CDATA[<h2 id="面向对象六大设计原则"><a href="#面向对象六大设计原则" class="headerlink" title="面向对象六大设计原则"></a>面向对象六大设计原则</h2><hr><h4 id="单一职责原则-Single-Responsibility-Principle"><a href="#单一职责原则-Single-Responsibility-Principle" class="headerlink" title="单一职责原则(Single Responsibility Principle)"></a>单一职责原则(Single Responsibility Principle)</h4><p>主要指的是一个类,方法,接口中只实现单一职责,这样能够提升代码可读性,可维护性也大大提高,有效避免了屎山代码的出现(<strong>确信</strong>),进行功能变更时的风险也会降低.</p><h4 id="开闭原则-Open-Closed-Principle"><a href="#开闭原则-Open-Closed-Principle" class="headerlink" title="开闭原则(Open Closed Principle)"></a>开闭原则(Open Closed Principle)</h4><p><strong>对于扩展开放,对于修改封闭.</strong></p><p>一个软件实体应该通过扩展来实现变化,而不是通过修改已有的代码实现变化.这是为软件实体的未来事件而制定的对现行开发设计进行约束的一个原则.</p><p>比如一个类可能有多方需要调用,有时部分调用方有了新的需求,这时不能直接修改类的代码来更改功能,而是需求方将这个类继承过去再进行添加,修改功能,这样出问题不会影响其他调用方,真正做到高内聚,低耦合.</p><p>其实类的例子还不够准确,一般都是先将职责方法抽象成接口,然后再根据各自需求的不同进行具体实现.</p><h4 id="里式替换原则-Liskov-Substitution-Principle"><a href="#里式替换原则-Liskov-Substitution-Principle" class="headerlink" title="里式替换原则(Liskov Substitution Principle)"></a>里式替换原则(Liskov Substitution Principle)</h4><p><strong>所有引用基类的地方必须能够透明地使用其子类的对象.</strong></p><p>通俗点说，只要父类能出现的地方子类就可以出现,而且替换为子类也不会产生任何异常.但是反过来就不行了,因为子类可以扩展父类没有的功能,同时子类还不能改变父类原有的功能.</p><p>里氏替换原则为良好的继承定义了一个规范，它包含了4层含义：</p><p>1、子类可以实现父类的抽象方法,但是不能覆盖父类的非抽象方法.</p><p>2、子类可以有自己的个性,可以有自己的属性和方法.</p><p>3、子类覆盖或重载父类的方法时输入参数可以被放大.</p><p>4、子类覆盖或重载父类的方法时输出结果可以被缩小,也就是说返回值要小于或等于父类的方法返回值.</p><h4 id="迪米特法则-Law-of-Demeter"><a href="#迪米特法则-Law-of-Demeter" class="headerlink" title="迪米特法则(Law of Demeter)"></a>迪米特法则(Law of Demeter)</h4><p><strong>一个对象应尽量减少对其他对象的了解.</strong></p><p>一个类应该对自己需要耦合或调用的类知道的最少,类与类之间的关系越密切,耦合度越大,那么类的变化对其耦合的类的影响也会越大,这也是我们面向设计的核心原则:高内聚,低耦合.</p><h4 id="接口隔离原则-Interface-Segregation-Principle"><a href="#接口隔离原则-Interface-Segregation-Principle" class="headerlink" title="接口隔离原则(Interface Segregation Principle)"></a>接口隔离原则(Interface Segregation Principle)</h4><p><strong>客户端不应该依赖它不需要的接口</strong></p><p>意思就是客户端需要什么接口就提供什么接口，把不需要的接口剔除掉，这就需要对接口进行细化，保证接口的纯洁性。换成另一种说法就是，类间的依赖关系应该建立在最小的接口上，也就是建立单一的接口。</p><p>你可能会疑惑，建立单一接口，这不是单一职责原则吗？其实不是，单一职责原则要求的是类和接口职责单一，注重的是职责，一个职责的接口是可以有多个方法的，而接口隔离原则要求的是接口的方法尽量少，模块尽量单一，如果需要提供给客户端很多的模块，那么就要相应的定义多个接口，不要把所有的模块功能都定义在一个接口中，那样会显得很臃肿。</p><h4 id="依赖倒置原则-Dependency-Inversion-Principle"><a href="#依赖倒置原则-Dependency-Inversion-Principle" class="headerlink" title="依赖倒置原则(Dependency Inversion Principle)"></a>依赖倒置原则(Dependency Inversion Principle)</h4><p><strong>高层模块不应该依赖底层模块,两者都应该依赖其抽象;</strong><br><strong>抽象不应该依赖细节;</strong><br><strong>细节应该依赖抽象.</strong></p><p>抽象就是指接口或抽象类，两者都不能被实例化；而细节就是实现接口或继承抽象类产生的类，也就是可以被实例化的实现类。依赖倒置原则是指模块间的依赖是通过抽象来发生的，实现类之间不发生直接的依赖关系，其依赖关系是通过接口是来实现的，这就是俗称的面向接口编程。</p><p>不知道有没有细心的同学发现,这六大原则的首字母可以组成一个单词:SOLID,可能这就是这六大设计原则想达到的目标吧.</p><h4 id="References"><a href="#References" class="headerlink" title="References"></a>References</h4><ul><li>《设计模式之禅》第二版</li><li>《重学Java设计模式》by xfg</li><li><a href="https://blog.csdn.net/txaz6/article/details/120138199" style="color: #177cb0; text-decoration: underline;text-decoration-style: dotted;">面向对象设计的六大设计原则</a><br>……</li></ul>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>乐观锁和悲观锁</title>
      <link href="/2023/10/30/%E4%B9%90%E8%A7%82%E9%94%81%E5%92%8C%E6%82%B2%E8%A7%82%E9%94%81/"/>
      <url>/2023/10/30/%E4%B9%90%E8%A7%82%E9%94%81%E5%92%8C%E6%82%B2%E8%A7%82%E9%94%81/</url>
      
        <content type="html"><![CDATA[<h2 id="乐观锁和悲观锁"><a href="#乐观锁和悲观锁" class="headerlink" title="乐观锁和悲观锁"></a>乐观锁和悲观锁</h2><h3 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h3><p>乐观认为不会有别的线程与它来抢占修改,直接对数据进行修改,在提交的时候进行检查,看是否有别的线程修改过数据,如果修改过,就放弃修改,返回错误或者重试.</p><p>乐观锁一般有两种实现方式:<strong>版本号机制和CAS算法</strong></p><h4 id="版本号机制-redis采用的方案"><a href="#版本号机制-redis采用的方案" class="headerlink" title="版本号机制(redis采用的方案)"></a>版本号机制(redis采用的方案)</h4><p>一般是在数据表中加上一个数据版本号 version 字段，表示数据被修改的次数。当数据被修改时，version 值会加一。当线程 A 要更新数据值时，在读取数据的同时也会读取 version 值，在提交更新时，若刚才读取到的 version 值为当前数据库中的 version 值相等时才更新，否则重试更新操作，直到更新成功。</p><h4 id="CAS算法"><a href="#CAS算法" class="headerlink" title="CAS算法"></a>CAS算法</h4><p>CAS 的全称是 <strong>Compare And Swap（比较与交换）</strong> ，用于实现乐观锁，被广泛应用于各大框架中。CAS 的思想很简单，就是用一个预期值和要更新的变量值进行比较，两值相等才会进行更新。</p><p>CAS算法会有一个<strong>巨大的问题</strong>,就是<strong><em>ABA问题</em></strong>.如果一个变量 V 初次读取的时候是 A 值，并且在准备赋值的时候检查到它仍然是 A 值，那我们就能说明它的值没有被其他线程修改过了吗？很明显是不能的，因为在这段时间它的值可能被改为其他值，然后又改回 A，那 CAS 操作就会误认为它从来没有被修改过。ABA 问题的解决思路是在变量前面追加上<strong>版本号或者时间戳(java采用的方案)</strong>。</p><p>CAS算法还有一个<strong>问题</strong>就是<strong>循环时间长开销大</strong>.CAS 经常会用到自旋操作来进行重试，也就是不成功就一直循环执行直到成功。如果长时间不成功，会给 CPU 带来非常大的执行开销。</p><h4 id="乐观锁的特点："><a href="#乐观锁的特点：" class="headerlink" title="乐观锁的特点："></a>乐观锁的特点：</h4><p>1.乐观锁适用于并发读操作较多的场景，因为读操作不涉及到数据的修改，不需要加锁。<br>2.乐观锁在更新数据时，只有在提交更新操作时才对数据进行版本检查，减少了加锁和解锁的开销。<br>3.乐观锁可能需要进行重试，以处理并发修改引起的冲突。</p><h3 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h3><p>悲观锁总认为会别的线程回来抢占修改,于是采用一种<strong>防御的姿态</strong>将数据锁住,所以每次在获取资源操作的时候都会上锁，这样其他线程想拿到这个资源就会阻塞直到锁被上一个持有者释放。也就是说，共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程。</p><h4 id="悲观锁的特点："><a href="#悲观锁的特点：" class="headerlink" title="悲观锁的特点："></a>悲观锁的特点：</h4><p>1.悲观锁适用于并发写操作较多的场景，因为写操作涉及到数据的修改，需要保证数据的一致性。<br>2.悲观锁在加锁期间，其他线程无法访问被锁定的资源，从而保证了数据的完整性。<br>3.悲观锁需要频繁地进行加锁和解锁操作，开销较大。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>经典组合问题</title>
      <link href="/2023/10/18/%E7%BB%8F%E5%85%B8%E7%BB%84%E5%90%88%E9%97%AE%E9%A2%98/"/>
      <url>/2023/10/18/%E7%BB%8F%E5%85%B8%E7%BB%84%E5%90%88%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="经典组合问题"><a href="#经典组合问题" class="headerlink" title="经典组合问题"></a>经典组合问题</h1><hr><p>在<strong>Leetcode</strong>刷过<strong>回溯算法</strong>的同学应该都知道,组合问题是回溯算法中经典的一种题型</p><p>本篇博客给大家介绍的就是组合问题三兄弟:<br><strong><em>39.数组总和</em></strong><br><strong><em>40.数组总和II</em></strong><br><strong><em>216.数组总和III</em></strong></p><p>为什么我想说说这三道题呢,因为这三道题的本质就是套回溯算法的模版</p><p>属于只要弄明白了,那么组合问题就一定没问题了,甚至大部分的回溯算法问题也能够解决</p><p>回溯法（back tracking）（探索与回溯法）是一种选优搜索法，又称为试探法，按选优条件向前搜索，以达到目标。<strong>但当探索到某一步时，发现原先选择并不优或达不到目标，就退回到上一步，重新选择</strong>,这种走不通就退回再走的技术为回溯法，而满足回溯条件的某个状态的点称为“回溯点”。</p><p>回溯算法的关键在于找到终止条件,无论是子过程结束的终止条件,还是回退到上一步的终止条件.</p><p>例如 <strong>39数组总和</strong> 这道题中子过程的终止条件为<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(target==<span class="number">0</span>)&#123;</span><br><span class="line">    ans.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(list));</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>回退到上一步的终止条件为<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(target-candidates[i]&lt;<span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这就是解决问题的关键</p><p><strong>回溯算法模版(伪代码版)</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">backtracking</span><span class="params">(参数)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (终止条件) &#123;</span><br><span class="line">        存放结果;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) &#123;</span><br><span class="line">        处理节点;</span><br><span class="line">        backtracking(路径，选择列表); <span class="comment">// 递归</span></span><br><span class="line">        回溯，撤销处理结果</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><strong>回溯算法模版(详细版)就是39数组总和的代码</strong></p><h2 id="39数组总和"><a href="#39数组总和" class="headerlink" title="39数组总和"></a>39数组总和</h2><h4 id="1-标准回溯"><a href="#1-标准回溯" class="headerlink" title="1.标准回溯"></a>1.标准回溯</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; ans=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">    List&lt;Integer&gt; list=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combinationSum</span><span class="params">(<span class="type">int</span>[] candidates, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        Arrays.sort(candidates);</span><br><span class="line">        backtrack(candidates,target,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backtrack</span><span class="params">(<span class="type">int</span>[] candidates,<span class="type">int</span> target,<span class="type">int</span> start)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(target==<span class="number">0</span>)&#123;</span><br><span class="line">            ans.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(list));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=start;i&lt;candidates.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(target-candidates[i]&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            list.add(candidates[i]);</span><br><span class="line">            backtrack(candidates,target-candidates[i],i);</span><br><span class="line">            list.remove(list.size()-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="40数组总和II"><a href="#40数组总和II" class="headerlink" title="40数组总和II"></a>40数组总和II</h2><p>跟39题非常像,就是要防止重复出现的子集<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; ans=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">    List&lt;Integer&gt; list=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combinationSum2</span><span class="params">(<span class="type">int</span>[] candidates, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        Arrays.sort(candidates);</span><br><span class="line">        combine(candidates,target,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">combine</span><span class="params">(<span class="type">int</span>[] candidates,<span class="type">int</span> target,<span class="type">int</span> start)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(target==<span class="number">0</span>)&#123;</span><br><span class="line">            ans.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(list));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=start;i&lt;candidates.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(target-candidates[i]&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(i&gt;start&amp;&amp;candidates[i]==candidates[i-<span class="number">1</span>])&#123;<span class="comment">//最关键的就是这个</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            list.add(candidates[i]);</span><br><span class="line">            combine(candidates,target-candidates[i],i+<span class="number">1</span>);</span><br><span class="line">            list.remove(list.size()-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="216数组总和III"><a href="#216数组总和III" class="headerlink" title="216数组总和III"></a>216数组总和III</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; ans=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">    List&lt;Integer&gt; list=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combinationSum3</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(n&lt;=k)&#123;</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line">        combine(k,n,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">combine</span><span class="params">(<span class="type">int</span> k,<span class="type">int</span> n,<span class="type">int</span> start)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(k==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(n==<span class="number">0</span>)&#123;</span><br><span class="line">                ans.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(list));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=start;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(n-i&lt;<span class="number">0</span>||k&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            list.add(i);</span><br><span class="line">            combine(k-<span class="number">1</span>,n-i,i+<span class="number">1</span>);</span><br><span class="line">            list.remove(list.size()-<span class="number">1</span>);</span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>估值原理听后感</title>
      <link href="/2023/10/12/%E4%BC%B0%E5%80%BC%E5%8E%9F%E7%90%86/"/>
      <url>/2023/10/12/%E4%BC%B0%E5%80%BC%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="估值原理听后感"><a href="#估值原理听后感" class="headerlink" title="估值原理听后感"></a>估值原理听后感</h1><hr><p>写本文的原因是在小宇宙上听了面基的一期博客:<a href="https://www.xiaoyuzhoufm.com/episode/6523d01550cf691d244cf8d5?s=eyJ1IjoiNjQ2MzY1NThlZGNlNjcxMDRhZjVlY2Q5In0%3D" style="color: #177cb0; text-decoration: underline;text-decoration-style: dotted;">《估值原理》:从没想过还可以这么看估值!</a>,给了我一些思考和启发</p><h2 id="估值"><a href="#估值" class="headerlink" title="估值"></a>估值</h2><p>估值是指评定一项资产当时价值的过程,这是百度百科的定义</p><p>那价值又是什么呢?价值,泛指客体对于主体表现出来的积极意义和有用性.这也是百度百科的定义.</p><p>所以说价值这个东西是因人而异的,每个人都有不同的观念,他们对同一样资产(物品)的看法是不同的,因而同一样资产对不同人来说具有不同的价值.</p><p>比如说,钻石,对于我这种理工科直男来说就是好看一点的碳,没有特殊的价值,但在另一些人眼里就是爱情的象征.</p><p>可虽然对不同的人来说资产的价值是有很大差异的,但是这些资产在市场上基本有着相对稳定的价格,这就可以引出这本书的一个观点:<strong>价值游戏论</strong></p><h2 id="价值游戏论"><a href="#价值游戏论" class="headerlink" title="价值游戏论"></a>价值游戏论</h2><p>价格是估值的最直观体现,所以人们总觉得,估值来源于交易,而交易脱胎于市场.但这其实是一种误解,市场只是提供了交易便利和清算服务而已,估值来自社会</p><p>如果一个社会要提倡某种价值观，就一定会用相应的资产去体现这种价值观.或者说,当一个社会决定用一场游戏来解决某个社会问题时,他们会根据情况选择是棒球赛还是足球赛还是篮球赛</p><p>这场游戏需要一些特定的美德、秩序、规范、共识,这些被鼓励的东西都需要一个很具体的载体.这个载体就是那颗球,那颗球就是被全社会追捧的资产,它一定享受高估值</p><p>房产、股票、黄金、碳排放额，任何一项资产都符合且服从于各自社会的估值体系。这些估值体系根植于全社会的思想观念和风俗习惯之中。</p><p>为什么有的国家股票涨得厉害?</p><p>为什么同一时期有的国家房产涨得厉害而股票却一跌再跌?</p><p>为什么央行释放了流动性，结果却导致房价上涨，股价下跌?</p><p>这是因为人们用资产在玩不同的游戏，使用了不同的规则导致的.所以，在价格涨跌之外，要观察大家在玩什么游戏？观察大家注重什么？要解决什么问题？</p><p>举几个例子:</p><p><strong>1.</strong><br>在金本位时代，这个社会会鼓励勤俭和孝顺。</p><p>因为货币以黄金为锚，很难超发，勤俭节约是有效的，本质是在储存有效购买力。</p><p>但一个人在践行勤俭节约的「美德」，往往是为了自己和孩子积攒更多的生活资料</p><p>金本位时代也一定鼓励储蓄这个美德，储蓄意味着不提现，不去兑换实物黄金。因为金本位时代的黄金储备根本不足以应对大量提取实物黄金。金本位就是一个承诺而已。</p><p>英格兰银行鼓励你把纸币存入银行，并支付利息，它对日常的纸币兑换黄金保证照付不议，它维护物价稳定，提倡省吃俭用，量入为出，他给你足够多的理由不去提取黄金，安心持有纸币。</p><p>喜欢储蓄，意味着拥有更多黄金，从而拥有更高的社会地位。</p><p>同时，当全社会都在玩这个游戏时，没什么出路的英国人也热衷去海外拓展殖民地获得更多的黄金，以便回国后提高自己的社会地位。</p><p><strong>2.</strong><br>在信用本位时代，把一堆钞票像黄金一样留给后代已经值不了几个钱了，社会需要别的传承资产。</p><p><strong><em>如果社会选择了房产游戏，它就在鼓励「勇敢」和「坚忍」。一个人必须勇敢地背上高额房贷，同时坚忍地努力工作30年来偿还月供。</em></strong></p><p>对男人来说，房产就像女人的钻石，那是阶层等级的标识，有了它，意味着择偶优先权。</p><p>房价越贵，就会有更多的年轻人对其趋之若骛，努力奋斗。而黄金的价格涨幅远远落后于房地产价格的涨幅。这说明我们现在和金本位时代玩的就是两种不同的游戏。</p><p><strong>3.</strong><br>如果社会选择了股票游戏，它就在鼓励「独立」和「效率」两种美德。</p><p>公司需要想办法，尤其是依靠科技和创新来提高社会的效率，以便拿到更高的估值。</p><p>本书作者周洛华也是一位股民，他以前并没有意识到股票是提升效率游戏的球，房产是地位晋升游戏的球。</p><p>他把股票当成了让自己地位晋升的球，结果他炒股总是亏钱。</p><p><strong>从游戏的角度看待估值，就会发现这场游戏把散户套在高位还是挺合理的。</strong></p><p><strong>只有把大量的散户投资人套在高位，才能使得他们放弃财富自由的幻想，才能使得他们努力工作。</strong></p><p><strong>这个社会没办法同时快速地让人大规模地发财。</strong></p><hr><p>当某项资产成为国民性的关键资产时，<strong>它一定是「低换手率」的</strong>。或者说，这类资产的换手率一定是被刻意压低的。</p><p>比如我们刚提到的，金本位时代鼓励储蓄，从而降低了黄金兑换。</p><p>再比如我们一线楼市之前的认房又认贷，京沪存量房源大概800万套，但每年的成交量只有二三十万套，年换手率不到5%。</p><p>只要共识还在、信心还在，你知道卖的时候市场的承接力接得住，也愿意接，那就长期持有。</p><p>金本位时代，大家愿意持有纸币而不是黄金，因为他们知道只要去英格兰银行，纸币就可以换出黄金。</p><p>类似的，大家相信京沪永远涨，就愿意持有房子，而不是急于把它抛掉。</p><p>大家相信美股长牛，就愿意持有股票，而不是像2020年3月那样在市场上疯狂抛售。</p><p><strong><em>社会在玩不同的游戏,就会导致不同的资产成为国民性资产,比如中国的房产,美国的股票,欧洲的债券,这不仅仅是由社会的发展阶段决定的,还夹杂了制定规则的阶级的强烈意志(他们总要保障自己的利益)</em></strong></p><p>只有少数的人能get到游戏的规则,从而获取高额收益,并且要时刻警醒,关注游戏规则,否则之前获得的高额收益很快就会消失</p><p>说个最近看到的例子,美国疯狂印钞大放水,美国政府的欠债也越来越多,可是他们的负债率却下降了,原因是在这场大放水中他们使资产的上涨幅度超过了负债的上涨幅度.正应了拜登曾说的一句话,<strong>通胀不是什么可怕的东西,通胀是一种武器.</strong></p><p>这就是美国的游戏,我们在他人制定的游戏规则里,永远不可能成为最终赢家,或者说我们不可能一直赢下去.</p><h2 id="估值责任论"><a href="#估值责任论" class="headerlink" title="估值责任论"></a>估值责任论</h2><p><strong>社会有显然的分成倾向。而且它不仅分层，还会垂直流动。</strong></p><p>中产和底层人民相互流动,只有最顶层相对稳定.这其实就是游戏规则的制定者希望看到的,他们永远处于最顶层,通过改变规则使得社会更加高效,社会的整体素质提高,获得更多的利益,得到更好的服务.</p><p>经济学教科书里有两种「和平方式」来实现垂直流动——</p><p>一是个体提高效率，勤奋努力的人会提高自己的社会地位。</p><p>二是全面的经济危机，主要是每当中层和上层过于拥挤时，通过危机出清掉一批人，给后来者腾出比赛场地。</p><p>有趣的是，每次切换游戏后，社会的主流价值观和风尚也会随之改变。人们会谴责上一场游戏中的胜者，从他们身上总结出一大堆缺点和毛病，并将其视为他们财富消亡的原因。</p><p>其实就是原来的游戏可能因为社会各阶层固化而无法刺激大家努力奋斗，玩不下去了(少数人的利益无法得到更好的保障了)</p><p>与此同时，接下来社会还会崇尚一种新的风尚，用来解释为什么有些人在新一轮经济繁荣中胜出。</p><p><strong>归根到底，是社会换了个新游戏。</strong></p><p>所以，每次金融危机发生之前，社会总是一片繁荣，人们已经习惯于相信自己的才能、努力和眼光。</p><p>每次危机之前，社会中上层都已经人满为患。</p><p>类似的，牛市末期有个重要特征，就是大家都在讨论财富自由和提前退休。<strong>呵呵，没门！社会不会答应的，它不会让那么多人都实现财富自由，进入上流社会，游山玩水，游手好闲，最后安享晚年。</strong></p><p>如果真的这样，那将是一场系统的灾难。</p><h2 id="结束的话"><a href="#结束的话" class="headerlink" title="结束的话"></a>结束的话</h2><p>在本篇博客中,我只介绍了《估值原理》这本书中的一部分内容,是我认可的主要部分,当然也夹杂了一些个人的看法,希望大家多多包涵一个年轻人不成熟的观点.想要了解更多,可以去小宇宙听这篇博客,也可以自己买来这本书阅读,最后感谢您的阅读.</p>]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>个人博客的搭建(全流程覆盖)</title>
      <link href="/2023/09/26/2023-9-26-%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%90%AD%E5%BB%BA/"/>
      <url>/2023/09/26/2023-9-26-%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%90%AD%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="个人博客的搭建教程推荐-踩坑记录"><a href="#个人博客的搭建教程推荐-踩坑记录" class="headerlink" title="个人博客的搭建教程推荐+踩坑记录"></a>个人博客的搭建教程推荐+踩坑记录</h1><hr><h2 id="本人博客的说明"><a href="#本人博客的说明" class="headerlink" title="本人博客的说明"></a>本人博客的说明</h2><p>趁着国庆假期,花了大概两天时间将这个博客搭了起来,主要是走了一些弯路(哭),其实主要是上午都在睡懒觉(雾)</p><p>采用的是<a href="https://hexo.io/zh-cn/index.html%" style="color: #177cb0; text-decoration: underline;text-decoration-style: dotted;">hexo框架</a></p><p>主题是<a href="https://butterfly.js.org/" style="color: #177cb0; text-decoration: underline;text-decoration-style: dotted;">butterfly</a>,加上了个人的一些魔改,由于本人喜欢简洁的风格,所以魔改的内容并不算太多</p><p>部署了两个远程仓库,一个是我的github仓库,另一个是我在阿里云服务器上的仓库</p><hr><h2 id="教程推荐"><a href="#教程推荐" class="headerlink" title="教程推荐"></a>教程推荐</h2><p>自学能力比较强的同学可以去看官方文档,上一趴已有链接</p><p>推荐一些保姆级教程: </p><ol><li><a href="https://www.fomal.cc/" style="color: #177cb0; text-decoration: underline;text-decoration-style: dotted;">Fomalhaut的博客</a>,既有基础教程,也包含了魔改教程,还有<a href="https://space.bilibili.com/220757832" style="color: #177cb0; text-decoration: underline;text-decoration-style: dotted;">Fomalhaut的bilibili主页</a></li><li><a href="https://blog.anheyu.com/" style="color: #177cb0; text-decoration: underline;text-decoration-style: dotted;">安知鱼的博客</a>,内容十分详细,安知鱼主题也十分好看哦,佬的<a href="https://space.bilibili.com/372204786" style="color: #177cb0; text-decoration: underline;text-decoration-style: dotted;">bilibili主页链接</a></li></ol><p>建议小白跟着视频一步步操作,掌握了基础就可以去魔改自己想要的效果啦</p><hr><h3 id="推荐一些别的主题"><a href="#推荐一些别的主题" class="headerlink" title="推荐一些别的主题"></a>推荐一些别的主题</h3><ol><li><a href="https://github.com/xzhih/hexo-theme-casper" style="color: #177cb0; text-decoration: underline;text-decoration-style: dotted;">casper主题</a>,这算是我看下来最简洁,最有大厂范的主题了,如果我还有空折腾的话,这就是我下一个博客的主题了</li><li><a href="https://docs.anheyu.com/" style="color: #177cb0; text-decoration: underline;text-decoration-style: dotted;">安知鱼</a>,这也是我很喜欢的一个主题,casper,忘了我吧(大雾)</li><li><a href="https://github.com/theme-next/hexo-theme-next" style="color: #177cb0; text-decoration: underline;text-decoration-style: dotted;">next主题</a></li><li><a href="https://github.com/litten/hexo-theme-yilia" style="color: #177cb0; text-decoration: underline;text-decoration-style: dotted;">yimlia主题</a></li></ol><p>更多主题可以去<del>世界最大男性交友网站</del><strong>github</strong>自行寻找</p><hr><h2 id="关于服务器"><a href="#关于服务器" class="headerlink" title="关于服务器"></a>关于服务器</h2><h3 id="github"><a href="#github" class="headerlink" title="github"></a>github</h3><p>觉得麻烦的同学可以直接使用github当网站托管,省事又省钱,就是访问速度有点捉襟见肘</p><h3 id="网站托管"><a href="#网站托管" class="headerlink" title="网站托管"></a>网站托管</h3><p>还有就是一些网站托管平台,像vercel,cloudflare等,不过会经常被墙就是了,似乎vercel已经寄了,托管和加速了太多诈骗网站(乐)</p><h3 id="拥有自己的云服务器-推荐"><a href="#拥有自己的云服务器-推荐" class="headerlink" title="拥有自己的云服务器(推荐)"></a>拥有自己的云服务器(推荐)</h3><p>有闲置的机器并且喜欢折腾的同学可以自己搞,网上有很多教程,不过大多数人应该没有多余的机器,所以就不详细描述了</p><p>国内云服务器厂商的主流选择就是阿里云,华为云和腾讯云,当然你去白嫖国外云服务器厂商的服务器也是可以的</p><hr><h2 id="将网站部署到自己的服务器上"><a href="#将网站部署到自己的服务器上" class="headerlink" title="将网站部署到自己的服务器上"></a>将网站部署到自己的服务器上</h2><p>推荐推荐yyyz的<a href="https://www.bilibili.com/video/BV1qU4y1K7Hk/?spm_id_from=333.999.0.0&vd_source=26068b3fc005480cb76f959e037a7a07" style="color: #177cb0; text-decoration: underline;text-decoration-style: dotted;">视频教程</a>和<a href="https://www.yyyzyyyz.cn/" style="color: #177cb0; text-decoration: underline;text-decoration-style: dotted;">博客</a></p><p>建议跟着一步步去操作,否则你就会发现通过服务器的公网ip访问不到你的博客,当然博客已经写的很详实了,有基础可以直接跟着操作</p><p>我用的是阿里云的服务器,建议先把白嫖六个月服务器要求的教程做了,这样你几乎不会碰到什么困难(血泪教训)</p><hr><h2 id="关于上线网站的手续"><a href="#关于上线网站的手续" class="headerlink" title="关于上线网站的手续"></a>关于上线网站的手续</h2><p>几乎全部流程都可以在云服务厂商那走完,而且还有代办服务,只不过要钱就是了</p><p>首先,要有自己的域名,在你的云服务厂商那购买即可,大家可以根据自己的经济实力和喜好购买,主要自己玩可以买.cc,主要访问者在国内推荐.cn,希望国际化一点就买.com(就是经济实力不允许,太贵了),建议多买两年,买完走报备流程,或者流程走完再买都可</p><p>然后就是ICT备案了,各个省份的要求有所不同,建议选择自己身份证所在地区进行报备,可能会少一些麻烦,我在江苏报备,需要身份证照片,人脸验证,居住证,两份承诺书,承诺视频,还有居住证(学生没有的话传身份证即可),个人觉得很繁琐.还有以博客的名义建站,站点名称需要带上个人真实姓名,互联网咩有隐私(悲)</p><p>最后就是公安备案啦,网上有说可备可不备的,但是建议备案一下,国内的监管越来越严了,到时候出事了就不好了</p>]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> blog </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
